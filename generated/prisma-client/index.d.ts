
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model OtpRecord
 * 
 */
export type OtpRecord = $Result.DefaultSelection<Prisma.$OtpRecordPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model Media
 * 
 */
export type Media = $Result.DefaultSelection<Prisma.$MediaPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Classroom
 * 
 */
export type Classroom = $Result.DefaultSelection<Prisma.$ClassroomPayload>
/**
 * Model ClassroomStudent
 * 
 */
export type ClassroomStudent = $Result.DefaultSelection<Prisma.$ClassroomStudentPayload>
/**
 * Model JoinRequest
 * 
 */
export type JoinRequest = $Result.DefaultSelection<Prisma.$JoinRequestPayload>
/**
 * Model Lesson
 * 
 */
export type Lesson = $Result.DefaultSelection<Prisma.$LessonPayload>
/**
 * Model Material
 * 
 */
export type Material = $Result.DefaultSelection<Prisma.$MaterialPayload>
/**
 * Model Exercise
 * 
 */
export type Exercise = $Result.DefaultSelection<Prisma.$ExercisePayload>
/**
 * Model ExerciseSubmission
 * 
 */
export type ExerciseSubmission = $Result.DefaultSelection<Prisma.$ExerciseSubmissionPayload>
/**
 * Model Quiz
 * 
 */
export type Quiz = $Result.DefaultSelection<Prisma.$QuizPayload>
/**
 * Model QuizSection
 * 
 */
export type QuizSection = $Result.DefaultSelection<Prisma.$QuizSectionPayload>
/**
 * Model QuizQuestionGroup
 * 
 */
export type QuizQuestionGroup = $Result.DefaultSelection<Prisma.$QuizQuestionGroupPayload>
/**
 * Model QuizQuestion
 * 
 */
export type QuizQuestion = $Result.DefaultSelection<Prisma.$QuizQuestionPayload>
/**
 * Model QuizOption
 * 
 */
export type QuizOption = $Result.DefaultSelection<Prisma.$QuizOptionPayload>
/**
 * Model QuizAttempt
 * 
 */
export type QuizAttempt = $Result.DefaultSelection<Prisma.$QuizAttemptPayload>
/**
 * Model QuizAnswer
 * 
 */
export type QuizAnswer = $Result.DefaultSelection<Prisma.$QuizAnswerPayload>
/**
 * Model QuizQuestionGroupMedia
 * 
 */
export type QuizQuestionGroupMedia = $Result.DefaultSelection<Prisma.$QuizQuestionGroupMediaPayload>
/**
 * Model QuizQuestionMedia
 * 
 */
export type QuizQuestionMedia = $Result.DefaultSelection<Prisma.$QuizQuestionMediaPayload>
/**
 * Model QuizOptionMedia
 * 
 */
export type QuizOptionMedia = $Result.DefaultSelection<Prisma.$QuizOptionMediaPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  student: 'student',
  admin: 'admin',
  rootAdmin: 'rootAdmin'
};

export type Role = (typeof Role)[keyof typeof Role]


export const LessonType: {
  lesson: 'lesson',
  exercise: 'exercise',
  quiz: 'quiz'
};

export type LessonType = (typeof LessonType)[keyof typeof LessonType]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type LessonType = $Enums.LessonType

export const LessonType: typeof $Enums.LessonType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more OtpRecords
 * const otpRecords = await prisma.otpRecord.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more OtpRecords
   * const otpRecords = await prisma.otpRecord.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.otpRecord`: Exposes CRUD operations for the **OtpRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OtpRecords
    * const otpRecords = await prisma.otpRecord.findMany()
    * ```
    */
  get otpRecord(): Prisma.OtpRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.media`: Exposes CRUD operations for the **Media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.MediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classroom`: Exposes CRUD operations for the **Classroom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classrooms
    * const classrooms = await prisma.classroom.findMany()
    * ```
    */
  get classroom(): Prisma.ClassroomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classroomStudent`: Exposes CRUD operations for the **ClassroomStudent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassroomStudents
    * const classroomStudents = await prisma.classroomStudent.findMany()
    * ```
    */
  get classroomStudent(): Prisma.ClassroomStudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.joinRequest`: Exposes CRUD operations for the **JoinRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JoinRequests
    * const joinRequests = await prisma.joinRequest.findMany()
    * ```
    */
  get joinRequest(): Prisma.JoinRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lesson`: Exposes CRUD operations for the **Lesson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lessons
    * const lessons = await prisma.lesson.findMany()
    * ```
    */
  get lesson(): Prisma.LessonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.material`: Exposes CRUD operations for the **Material** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materials
    * const materials = await prisma.material.findMany()
    * ```
    */
  get material(): Prisma.MaterialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exercise`: Exposes CRUD operations for the **Exercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exercises
    * const exercises = await prisma.exercise.findMany()
    * ```
    */
  get exercise(): Prisma.ExerciseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exerciseSubmission`: Exposes CRUD operations for the **ExerciseSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExerciseSubmissions
    * const exerciseSubmissions = await prisma.exerciseSubmission.findMany()
    * ```
    */
  get exerciseSubmission(): Prisma.ExerciseSubmissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quiz`: Exposes CRUD operations for the **Quiz** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quizzes
    * const quizzes = await prisma.quiz.findMany()
    * ```
    */
  get quiz(): Prisma.QuizDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizSection`: Exposes CRUD operations for the **QuizSection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizSections
    * const quizSections = await prisma.quizSection.findMany()
    * ```
    */
  get quizSection(): Prisma.QuizSectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizQuestionGroup`: Exposes CRUD operations for the **QuizQuestionGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizQuestionGroups
    * const quizQuestionGroups = await prisma.quizQuestionGroup.findMany()
    * ```
    */
  get quizQuestionGroup(): Prisma.QuizQuestionGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizQuestion`: Exposes CRUD operations for the **QuizQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizQuestions
    * const quizQuestions = await prisma.quizQuestion.findMany()
    * ```
    */
  get quizQuestion(): Prisma.QuizQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizOption`: Exposes CRUD operations for the **QuizOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizOptions
    * const quizOptions = await prisma.quizOption.findMany()
    * ```
    */
  get quizOption(): Prisma.QuizOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizAttempt`: Exposes CRUD operations for the **QuizAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizAttempts
    * const quizAttempts = await prisma.quizAttempt.findMany()
    * ```
    */
  get quizAttempt(): Prisma.QuizAttemptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizAnswer`: Exposes CRUD operations for the **QuizAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizAnswers
    * const quizAnswers = await prisma.quizAnswer.findMany()
    * ```
    */
  get quizAnswer(): Prisma.QuizAnswerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizQuestionGroupMedia`: Exposes CRUD operations for the **QuizQuestionGroupMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizQuestionGroupMedias
    * const quizQuestionGroupMedias = await prisma.quizQuestionGroupMedia.findMany()
    * ```
    */
  get quizQuestionGroupMedia(): Prisma.QuizQuestionGroupMediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizQuestionMedia`: Exposes CRUD operations for the **QuizQuestionMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizQuestionMedias
    * const quizQuestionMedias = await prisma.quizQuestionMedia.findMany()
    * ```
    */
  get quizQuestionMedia(): Prisma.QuizQuestionMediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizOptionMedia`: Exposes CRUD operations for the **QuizOptionMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizOptionMedias
    * const quizOptionMedias = await prisma.quizOptionMedia.findMany()
    * ```
    */
  get quizOptionMedia(): Prisma.QuizOptionMediaDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    OtpRecord: 'OtpRecord',
    RefreshToken: 'RefreshToken',
    Media: 'Media',
    User: 'User',
    Classroom: 'Classroom',
    ClassroomStudent: 'ClassroomStudent',
    JoinRequest: 'JoinRequest',
    Lesson: 'Lesson',
    Material: 'Material',
    Exercise: 'Exercise',
    ExerciseSubmission: 'ExerciseSubmission',
    Quiz: 'Quiz',
    QuizSection: 'QuizSection',
    QuizQuestionGroup: 'QuizQuestionGroup',
    QuizQuestion: 'QuizQuestion',
    QuizOption: 'QuizOption',
    QuizAttempt: 'QuizAttempt',
    QuizAnswer: 'QuizAnswer',
    QuizQuestionGroupMedia: 'QuizQuestionGroupMedia',
    QuizQuestionMedia: 'QuizQuestionMedia',
    QuizOptionMedia: 'QuizOptionMedia'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "otpRecord" | "refreshToken" | "media" | "user" | "classroom" | "classroomStudent" | "joinRequest" | "lesson" | "material" | "exercise" | "exerciseSubmission" | "quiz" | "quizSection" | "quizQuestionGroup" | "quizQuestion" | "quizOption" | "quizAttempt" | "quizAnswer" | "quizQuestionGroupMedia" | "quizQuestionMedia" | "quizOptionMedia"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      OtpRecord: {
        payload: Prisma.$OtpRecordPayload<ExtArgs>
        fields: Prisma.OtpRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OtpRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OtpRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpRecordPayload>
          }
          findFirst: {
            args: Prisma.OtpRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OtpRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpRecordPayload>
          }
          findMany: {
            args: Prisma.OtpRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpRecordPayload>[]
          }
          create: {
            args: Prisma.OtpRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpRecordPayload>
          }
          createMany: {
            args: Prisma.OtpRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OtpRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpRecordPayload>[]
          }
          delete: {
            args: Prisma.OtpRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpRecordPayload>
          }
          update: {
            args: Prisma.OtpRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpRecordPayload>
          }
          deleteMany: {
            args: Prisma.OtpRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OtpRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OtpRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpRecordPayload>[]
          }
          upsert: {
            args: Prisma.OtpRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpRecordPayload>
          }
          aggregate: {
            args: Prisma.OtpRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOtpRecord>
          }
          groupBy: {
            args: Prisma.OtpRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<OtpRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.OtpRecordCountArgs<ExtArgs>
            result: $Utils.Optional<OtpRecordCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      Media: {
        payload: Prisma.$MediaPayload<ExtArgs>
        fields: Prisma.MediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findFirst: {
            args: Prisma.MediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findMany: {
            args: Prisma.MediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          create: {
            args: Prisma.MediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          createMany: {
            args: Prisma.MediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          delete: {
            args: Prisma.MediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          update: {
            args: Prisma.MediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          deleteMany: {
            args: Prisma.MediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          upsert: {
            args: Prisma.MediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          aggregate: {
            args: Prisma.MediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedia>
          }
          groupBy: {
            args: Prisma.MediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaCountArgs<ExtArgs>
            result: $Utils.Optional<MediaCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Classroom: {
        payload: Prisma.$ClassroomPayload<ExtArgs>
        fields: Prisma.ClassroomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassroomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassroomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>
          }
          findFirst: {
            args: Prisma.ClassroomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassroomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>
          }
          findMany: {
            args: Prisma.ClassroomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>[]
          }
          create: {
            args: Prisma.ClassroomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>
          }
          createMany: {
            args: Prisma.ClassroomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassroomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>[]
          }
          delete: {
            args: Prisma.ClassroomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>
          }
          update: {
            args: Prisma.ClassroomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>
          }
          deleteMany: {
            args: Prisma.ClassroomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassroomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassroomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>[]
          }
          upsert: {
            args: Prisma.ClassroomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>
          }
          aggregate: {
            args: Prisma.ClassroomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassroom>
          }
          groupBy: {
            args: Prisma.ClassroomGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassroomGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassroomCountArgs<ExtArgs>
            result: $Utils.Optional<ClassroomCountAggregateOutputType> | number
          }
        }
      }
      ClassroomStudent: {
        payload: Prisma.$ClassroomStudentPayload<ExtArgs>
        fields: Prisma.ClassroomStudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassroomStudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomStudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassroomStudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomStudentPayload>
          }
          findFirst: {
            args: Prisma.ClassroomStudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomStudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassroomStudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomStudentPayload>
          }
          findMany: {
            args: Prisma.ClassroomStudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomStudentPayload>[]
          }
          create: {
            args: Prisma.ClassroomStudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomStudentPayload>
          }
          createMany: {
            args: Prisma.ClassroomStudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassroomStudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomStudentPayload>[]
          }
          delete: {
            args: Prisma.ClassroomStudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomStudentPayload>
          }
          update: {
            args: Prisma.ClassroomStudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomStudentPayload>
          }
          deleteMany: {
            args: Prisma.ClassroomStudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassroomStudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassroomStudentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomStudentPayload>[]
          }
          upsert: {
            args: Prisma.ClassroomStudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomStudentPayload>
          }
          aggregate: {
            args: Prisma.ClassroomStudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassroomStudent>
          }
          groupBy: {
            args: Prisma.ClassroomStudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassroomStudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassroomStudentCountArgs<ExtArgs>
            result: $Utils.Optional<ClassroomStudentCountAggregateOutputType> | number
          }
        }
      }
      JoinRequest: {
        payload: Prisma.$JoinRequestPayload<ExtArgs>
        fields: Prisma.JoinRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JoinRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JoinRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinRequestPayload>
          }
          findFirst: {
            args: Prisma.JoinRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JoinRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinRequestPayload>
          }
          findMany: {
            args: Prisma.JoinRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinRequestPayload>[]
          }
          create: {
            args: Prisma.JoinRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinRequestPayload>
          }
          createMany: {
            args: Prisma.JoinRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JoinRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinRequestPayload>[]
          }
          delete: {
            args: Prisma.JoinRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinRequestPayload>
          }
          update: {
            args: Prisma.JoinRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinRequestPayload>
          }
          deleteMany: {
            args: Prisma.JoinRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JoinRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JoinRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinRequestPayload>[]
          }
          upsert: {
            args: Prisma.JoinRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JoinRequestPayload>
          }
          aggregate: {
            args: Prisma.JoinRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJoinRequest>
          }
          groupBy: {
            args: Prisma.JoinRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<JoinRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.JoinRequestCountArgs<ExtArgs>
            result: $Utils.Optional<JoinRequestCountAggregateOutputType> | number
          }
        }
      }
      Lesson: {
        payload: Prisma.$LessonPayload<ExtArgs>
        fields: Prisma.LessonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findFirst: {
            args: Prisma.LessonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findMany: {
            args: Prisma.LessonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          create: {
            args: Prisma.LessonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          createMany: {
            args: Prisma.LessonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          delete: {
            args: Prisma.LessonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          update: {
            args: Prisma.LessonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          deleteMany: {
            args: Prisma.LessonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          upsert: {
            args: Prisma.LessonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          aggregate: {
            args: Prisma.LessonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLesson>
          }
          groupBy: {
            args: Prisma.LessonGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonCountArgs<ExtArgs>
            result: $Utils.Optional<LessonCountAggregateOutputType> | number
          }
        }
      }
      Material: {
        payload: Prisma.$MaterialPayload<ExtArgs>
        fields: Prisma.MaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findFirst: {
            args: Prisma.MaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findMany: {
            args: Prisma.MaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          create: {
            args: Prisma.MaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          createMany: {
            args: Prisma.MaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          delete: {
            args: Prisma.MaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          update: {
            args: Prisma.MaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          deleteMany: {
            args: Prisma.MaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaterialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          upsert: {
            args: Prisma.MaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          aggregate: {
            args: Prisma.MaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterial>
          }
          groupBy: {
            args: Prisma.MaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialCountAggregateOutputType> | number
          }
        }
      }
      Exercise: {
        payload: Prisma.$ExercisePayload<ExtArgs>
        fields: Prisma.ExerciseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExerciseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExerciseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          findFirst: {
            args: Prisma.ExerciseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExerciseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          findMany: {
            args: Prisma.ExerciseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          create: {
            args: Prisma.ExerciseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          createMany: {
            args: Prisma.ExerciseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExerciseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          delete: {
            args: Prisma.ExerciseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          update: {
            args: Prisma.ExerciseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          deleteMany: {
            args: Prisma.ExerciseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExerciseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExerciseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          upsert: {
            args: Prisma.ExerciseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          aggregate: {
            args: Prisma.ExerciseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExercise>
          }
          groupBy: {
            args: Prisma.ExerciseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExerciseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExerciseCountArgs<ExtArgs>
            result: $Utils.Optional<ExerciseCountAggregateOutputType> | number
          }
        }
      }
      ExerciseSubmission: {
        payload: Prisma.$ExerciseSubmissionPayload<ExtArgs>
        fields: Prisma.ExerciseSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExerciseSubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExerciseSubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseSubmissionPayload>
          }
          findFirst: {
            args: Prisma.ExerciseSubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExerciseSubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseSubmissionPayload>
          }
          findMany: {
            args: Prisma.ExerciseSubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseSubmissionPayload>[]
          }
          create: {
            args: Prisma.ExerciseSubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseSubmissionPayload>
          }
          createMany: {
            args: Prisma.ExerciseSubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExerciseSubmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseSubmissionPayload>[]
          }
          delete: {
            args: Prisma.ExerciseSubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseSubmissionPayload>
          }
          update: {
            args: Prisma.ExerciseSubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.ExerciseSubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExerciseSubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExerciseSubmissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseSubmissionPayload>[]
          }
          upsert: {
            args: Prisma.ExerciseSubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciseSubmissionPayload>
          }
          aggregate: {
            args: Prisma.ExerciseSubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExerciseSubmission>
          }
          groupBy: {
            args: Prisma.ExerciseSubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExerciseSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExerciseSubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<ExerciseSubmissionCountAggregateOutputType> | number
          }
        }
      }
      Quiz: {
        payload: Prisma.$QuizPayload<ExtArgs>
        fields: Prisma.QuizFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          findFirst: {
            args: Prisma.QuizFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          findMany: {
            args: Prisma.QuizFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          create: {
            args: Prisma.QuizCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          createMany: {
            args: Prisma.QuizCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          delete: {
            args: Prisma.QuizDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          update: {
            args: Prisma.QuizUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          deleteMany: {
            args: Prisma.QuizDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          upsert: {
            args: Prisma.QuizUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          aggregate: {
            args: Prisma.QuizAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuiz>
          }
          groupBy: {
            args: Prisma.QuizGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizCountArgs<ExtArgs>
            result: $Utils.Optional<QuizCountAggregateOutputType> | number
          }
        }
      }
      QuizSection: {
        payload: Prisma.$QuizSectionPayload<ExtArgs>
        fields: Prisma.QuizSectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizSectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizSectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSectionPayload>
          }
          findFirst: {
            args: Prisma.QuizSectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizSectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSectionPayload>
          }
          findMany: {
            args: Prisma.QuizSectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSectionPayload>[]
          }
          create: {
            args: Prisma.QuizSectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSectionPayload>
          }
          createMany: {
            args: Prisma.QuizSectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizSectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSectionPayload>[]
          }
          delete: {
            args: Prisma.QuizSectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSectionPayload>
          }
          update: {
            args: Prisma.QuizSectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSectionPayload>
          }
          deleteMany: {
            args: Prisma.QuizSectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizSectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizSectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSectionPayload>[]
          }
          upsert: {
            args: Prisma.QuizSectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSectionPayload>
          }
          aggregate: {
            args: Prisma.QuizSectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizSection>
          }
          groupBy: {
            args: Prisma.QuizSectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizSectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizSectionCountArgs<ExtArgs>
            result: $Utils.Optional<QuizSectionCountAggregateOutputType> | number
          }
        }
      }
      QuizQuestionGroup: {
        payload: Prisma.$QuizQuestionGroupPayload<ExtArgs>
        fields: Prisma.QuizQuestionGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizQuestionGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizQuestionGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionGroupPayload>
          }
          findFirst: {
            args: Prisma.QuizQuestionGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizQuestionGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionGroupPayload>
          }
          findMany: {
            args: Prisma.QuizQuestionGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionGroupPayload>[]
          }
          create: {
            args: Prisma.QuizQuestionGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionGroupPayload>
          }
          createMany: {
            args: Prisma.QuizQuestionGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizQuestionGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionGroupPayload>[]
          }
          delete: {
            args: Prisma.QuizQuestionGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionGroupPayload>
          }
          update: {
            args: Prisma.QuizQuestionGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionGroupPayload>
          }
          deleteMany: {
            args: Prisma.QuizQuestionGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizQuestionGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizQuestionGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionGroupPayload>[]
          }
          upsert: {
            args: Prisma.QuizQuestionGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionGroupPayload>
          }
          aggregate: {
            args: Prisma.QuizQuestionGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizQuestionGroup>
          }
          groupBy: {
            args: Prisma.QuizQuestionGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizQuestionGroupCountArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionGroupCountAggregateOutputType> | number
          }
        }
      }
      QuizQuestion: {
        payload: Prisma.$QuizQuestionPayload<ExtArgs>
        fields: Prisma.QuizQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          findFirst: {
            args: Prisma.QuizQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          findMany: {
            args: Prisma.QuizQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          create: {
            args: Prisma.QuizQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          createMany: {
            args: Prisma.QuizQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          delete: {
            args: Prisma.QuizQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          update: {
            args: Prisma.QuizQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuizQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          upsert: {
            args: Prisma.QuizQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          aggregate: {
            args: Prisma.QuizQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizQuestion>
          }
          groupBy: {
            args: Prisma.QuizQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionCountAggregateOutputType> | number
          }
        }
      }
      QuizOption: {
        payload: Prisma.$QuizOptionPayload<ExtArgs>
        fields: Prisma.QuizOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionPayload>
          }
          findFirst: {
            args: Prisma.QuizOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionPayload>
          }
          findMany: {
            args: Prisma.QuizOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionPayload>[]
          }
          create: {
            args: Prisma.QuizOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionPayload>
          }
          createMany: {
            args: Prisma.QuizOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionPayload>[]
          }
          delete: {
            args: Prisma.QuizOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionPayload>
          }
          update: {
            args: Prisma.QuizOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionPayload>
          }
          deleteMany: {
            args: Prisma.QuizOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionPayload>[]
          }
          upsert: {
            args: Prisma.QuizOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionPayload>
          }
          aggregate: {
            args: Prisma.QuizOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizOption>
          }
          groupBy: {
            args: Prisma.QuizOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizOptionCountArgs<ExtArgs>
            result: $Utils.Optional<QuizOptionCountAggregateOutputType> | number
          }
        }
      }
      QuizAttempt: {
        payload: Prisma.$QuizAttemptPayload<ExtArgs>
        fields: Prisma.QuizAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          findFirst: {
            args: Prisma.QuizAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          findMany: {
            args: Prisma.QuizAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>[]
          }
          create: {
            args: Prisma.QuizAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          createMany: {
            args: Prisma.QuizAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>[]
          }
          delete: {
            args: Prisma.QuizAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          update: {
            args: Prisma.QuizAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          deleteMany: {
            args: Prisma.QuizAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizAttemptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>[]
          }
          upsert: {
            args: Prisma.QuizAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          aggregate: {
            args: Prisma.QuizAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizAttempt>
          }
          groupBy: {
            args: Prisma.QuizAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<QuizAttemptCountAggregateOutputType> | number
          }
        }
      }
      QuizAnswer: {
        payload: Prisma.$QuizAnswerPayload<ExtArgs>
        fields: Prisma.QuizAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizAnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizAnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
          }
          findFirst: {
            args: Prisma.QuizAnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizAnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
          }
          findMany: {
            args: Prisma.QuizAnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>[]
          }
          create: {
            args: Prisma.QuizAnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
          }
          createMany: {
            args: Prisma.QuizAnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizAnswerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>[]
          }
          delete: {
            args: Prisma.QuizAnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
          }
          update: {
            args: Prisma.QuizAnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
          }
          deleteMany: {
            args: Prisma.QuizAnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizAnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizAnswerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>[]
          }
          upsert: {
            args: Prisma.QuizAnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAnswerPayload>
          }
          aggregate: {
            args: Prisma.QuizAnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizAnswer>
          }
          groupBy: {
            args: Prisma.QuizAnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizAnswerCountArgs<ExtArgs>
            result: $Utils.Optional<QuizAnswerCountAggregateOutputType> | number
          }
        }
      }
      QuizQuestionGroupMedia: {
        payload: Prisma.$QuizQuestionGroupMediaPayload<ExtArgs>
        fields: Prisma.QuizQuestionGroupMediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizQuestionGroupMediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionGroupMediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizQuestionGroupMediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionGroupMediaPayload>
          }
          findFirst: {
            args: Prisma.QuizQuestionGroupMediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionGroupMediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizQuestionGroupMediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionGroupMediaPayload>
          }
          findMany: {
            args: Prisma.QuizQuestionGroupMediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionGroupMediaPayload>[]
          }
          create: {
            args: Prisma.QuizQuestionGroupMediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionGroupMediaPayload>
          }
          createMany: {
            args: Prisma.QuizQuestionGroupMediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizQuestionGroupMediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionGroupMediaPayload>[]
          }
          delete: {
            args: Prisma.QuizQuestionGroupMediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionGroupMediaPayload>
          }
          update: {
            args: Prisma.QuizQuestionGroupMediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionGroupMediaPayload>
          }
          deleteMany: {
            args: Prisma.QuizQuestionGroupMediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizQuestionGroupMediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizQuestionGroupMediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionGroupMediaPayload>[]
          }
          upsert: {
            args: Prisma.QuizQuestionGroupMediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionGroupMediaPayload>
          }
          aggregate: {
            args: Prisma.QuizQuestionGroupMediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizQuestionGroupMedia>
          }
          groupBy: {
            args: Prisma.QuizQuestionGroupMediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionGroupMediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizQuestionGroupMediaCountArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionGroupMediaCountAggregateOutputType> | number
          }
        }
      }
      QuizQuestionMedia: {
        payload: Prisma.$QuizQuestionMediaPayload<ExtArgs>
        fields: Prisma.QuizQuestionMediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizQuestionMediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionMediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizQuestionMediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionMediaPayload>
          }
          findFirst: {
            args: Prisma.QuizQuestionMediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionMediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizQuestionMediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionMediaPayload>
          }
          findMany: {
            args: Prisma.QuizQuestionMediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionMediaPayload>[]
          }
          create: {
            args: Prisma.QuizQuestionMediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionMediaPayload>
          }
          createMany: {
            args: Prisma.QuizQuestionMediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizQuestionMediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionMediaPayload>[]
          }
          delete: {
            args: Prisma.QuizQuestionMediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionMediaPayload>
          }
          update: {
            args: Prisma.QuizQuestionMediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionMediaPayload>
          }
          deleteMany: {
            args: Prisma.QuizQuestionMediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizQuestionMediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizQuestionMediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionMediaPayload>[]
          }
          upsert: {
            args: Prisma.QuizQuestionMediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionMediaPayload>
          }
          aggregate: {
            args: Prisma.QuizQuestionMediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizQuestionMedia>
          }
          groupBy: {
            args: Prisma.QuizQuestionMediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionMediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizQuestionMediaCountArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionMediaCountAggregateOutputType> | number
          }
        }
      }
      QuizOptionMedia: {
        payload: Prisma.$QuizOptionMediaPayload<ExtArgs>
        fields: Prisma.QuizOptionMediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizOptionMediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionMediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizOptionMediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionMediaPayload>
          }
          findFirst: {
            args: Prisma.QuizOptionMediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionMediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizOptionMediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionMediaPayload>
          }
          findMany: {
            args: Prisma.QuizOptionMediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionMediaPayload>[]
          }
          create: {
            args: Prisma.QuizOptionMediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionMediaPayload>
          }
          createMany: {
            args: Prisma.QuizOptionMediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizOptionMediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionMediaPayload>[]
          }
          delete: {
            args: Prisma.QuizOptionMediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionMediaPayload>
          }
          update: {
            args: Prisma.QuizOptionMediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionMediaPayload>
          }
          deleteMany: {
            args: Prisma.QuizOptionMediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizOptionMediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizOptionMediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionMediaPayload>[]
          }
          upsert: {
            args: Prisma.QuizOptionMediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizOptionMediaPayload>
          }
          aggregate: {
            args: Prisma.QuizOptionMediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizOptionMedia>
          }
          groupBy: {
            args: Prisma.QuizOptionMediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizOptionMediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizOptionMediaCountArgs<ExtArgs>
            result: $Utils.Optional<QuizOptionMediaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    otpRecord?: OtpRecordOmit
    refreshToken?: RefreshTokenOmit
    media?: MediaOmit
    user?: UserOmit
    classroom?: ClassroomOmit
    classroomStudent?: ClassroomStudentOmit
    joinRequest?: JoinRequestOmit
    lesson?: LessonOmit
    material?: MaterialOmit
    exercise?: ExerciseOmit
    exerciseSubmission?: ExerciseSubmissionOmit
    quiz?: QuizOmit
    quizSection?: QuizSectionOmit
    quizQuestionGroup?: QuizQuestionGroupOmit
    quizQuestion?: QuizQuestionOmit
    quizOption?: QuizOptionOmit
    quizAttempt?: QuizAttemptOmit
    quizAnswer?: QuizAnswerOmit
    quizQuestionGroupMedia?: QuizQuestionGroupMediaOmit
    quizQuestionMedia?: QuizQuestionMediaOmit
    quizOptionMedia?: QuizOptionMediaOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type MediaCountOutputType
   */

  export type MediaCountOutputType = {
    userAvatars: number
    classroomCovers: number
    materials: number
    exerciseAttachments: number
    exerciseSubmissions: number
    quizQuestionGroupMedias: number
    quizQuestionMedias: number
    quizOptionMedias: number
  }

  export type MediaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAvatars?: boolean | MediaCountOutputTypeCountUserAvatarsArgs
    classroomCovers?: boolean | MediaCountOutputTypeCountClassroomCoversArgs
    materials?: boolean | MediaCountOutputTypeCountMaterialsArgs
    exerciseAttachments?: boolean | MediaCountOutputTypeCountExerciseAttachmentsArgs
    exerciseSubmissions?: boolean | MediaCountOutputTypeCountExerciseSubmissionsArgs
    quizQuestionGroupMedias?: boolean | MediaCountOutputTypeCountQuizQuestionGroupMediasArgs
    quizQuestionMedias?: boolean | MediaCountOutputTypeCountQuizQuestionMediasArgs
    quizOptionMedias?: boolean | MediaCountOutputTypeCountQuizOptionMediasArgs
  }

  // Custom InputTypes
  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaCountOutputType
     */
    select?: MediaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountUserAvatarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountClassroomCoversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountExerciseAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountExerciseSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseSubmissionWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountQuizQuestionGroupMediasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionGroupMediaWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountQuizQuestionMediasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionMediaWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountQuizOptionMediasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizOptionMediaWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    uploadedMedia: number
    taughtClassrooms: number
    createdClassrooms: number
    classroomStudents: number
    joinRequests: number
    uploadedMaterials: number
    createdExercises: number
    exerciseSubmissions: number
    createdQuizzes: number
    quizAttempts: number
    refreshTokens: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploadedMedia?: boolean | UserCountOutputTypeCountUploadedMediaArgs
    taughtClassrooms?: boolean | UserCountOutputTypeCountTaughtClassroomsArgs
    createdClassrooms?: boolean | UserCountOutputTypeCountCreatedClassroomsArgs
    classroomStudents?: boolean | UserCountOutputTypeCountClassroomStudentsArgs
    joinRequests?: boolean | UserCountOutputTypeCountJoinRequestsArgs
    uploadedMaterials?: boolean | UserCountOutputTypeCountUploadedMaterialsArgs
    createdExercises?: boolean | UserCountOutputTypeCountCreatedExercisesArgs
    exerciseSubmissions?: boolean | UserCountOutputTypeCountExerciseSubmissionsArgs
    createdQuizzes?: boolean | UserCountOutputTypeCountCreatedQuizzesArgs
    quizAttempts?: boolean | UserCountOutputTypeCountQuizAttemptsArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTaughtClassroomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedClassroomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClassroomStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomStudentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountJoinRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JoinRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExerciseSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseSubmissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedQuizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAttemptWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }


  /**
   * Count Type ClassroomCountOutputType
   */

  export type ClassroomCountOutputType = {
    classroomStudents: number
    joinRequests: number
    lessons: number
  }

  export type ClassroomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classroomStudents?: boolean | ClassroomCountOutputTypeCountClassroomStudentsArgs
    joinRequests?: boolean | ClassroomCountOutputTypeCountJoinRequestsArgs
    lessons?: boolean | ClassroomCountOutputTypeCountLessonsArgs
  }

  // Custom InputTypes
  /**
   * ClassroomCountOutputType without action
   */
  export type ClassroomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomCountOutputType
     */
    select?: ClassroomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassroomCountOutputType without action
   */
  export type ClassroomCountOutputTypeCountClassroomStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomStudentWhereInput
  }

  /**
   * ClassroomCountOutputType without action
   */
  export type ClassroomCountOutputTypeCountJoinRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JoinRequestWhereInput
  }

  /**
   * ClassroomCountOutputType without action
   */
  export type ClassroomCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }


  /**
   * Count Type LessonCountOutputType
   */

  export type LessonCountOutputType = {
    materials: number
    exercises: number
    quizzes: number
    subLessons: number
  }

  export type LessonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materials?: boolean | LessonCountOutputTypeCountMaterialsArgs
    exercises?: boolean | LessonCountOutputTypeCountExercisesArgs
    quizzes?: boolean | LessonCountOutputTypeCountQuizzesArgs
    subLessons?: boolean | LessonCountOutputTypeCountSubLessonsArgs
  }

  // Custom InputTypes
  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCountOutputType
     */
    select?: LessonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountQuizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizWhereInput
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountSubLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }


  /**
   * Count Type ExerciseCountOutputType
   */

  export type ExerciseCountOutputType = {
    submissions: number
  }

  export type ExerciseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submissions?: boolean | ExerciseCountOutputTypeCountSubmissionsArgs
  }

  // Custom InputTypes
  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseCountOutputType
     */
    select?: ExerciseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseSubmissionWhereInput
  }


  /**
   * Count Type QuizCountOutputType
   */

  export type QuizCountOutputType = {
    sections: number
    questionGroups: number
    questions: number
    attempts: number
  }

  export type QuizCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sections?: boolean | QuizCountOutputTypeCountSectionsArgs
    questionGroups?: boolean | QuizCountOutputTypeCountQuestionGroupsArgs
    questions?: boolean | QuizCountOutputTypeCountQuestionsArgs
    attempts?: boolean | QuizCountOutputTypeCountAttemptsArgs
  }

  // Custom InputTypes
  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizCountOutputType
     */
    select?: QuizCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizSectionWhereInput
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountQuestionGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionGroupWhereInput
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionWhereInput
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAttemptWhereInput
  }


  /**
   * Count Type QuizSectionCountOutputType
   */

  export type QuizSectionCountOutputType = {
    questionGroups: number
    questions: number
  }

  export type QuizSectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questionGroups?: boolean | QuizSectionCountOutputTypeCountQuestionGroupsArgs
    questions?: boolean | QuizSectionCountOutputTypeCountQuestionsArgs
  }

  // Custom InputTypes
  /**
   * QuizSectionCountOutputType without action
   */
  export type QuizSectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSectionCountOutputType
     */
    select?: QuizSectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizSectionCountOutputType without action
   */
  export type QuizSectionCountOutputTypeCountQuestionGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionGroupWhereInput
  }

  /**
   * QuizSectionCountOutputType without action
   */
  export type QuizSectionCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionWhereInput
  }


  /**
   * Count Type QuizQuestionGroupCountOutputType
   */

  export type QuizQuestionGroupCountOutputType = {
    questions: number
    medias: number
  }

  export type QuizQuestionGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | QuizQuestionGroupCountOutputTypeCountQuestionsArgs
    medias?: boolean | QuizQuestionGroupCountOutputTypeCountMediasArgs
  }

  // Custom InputTypes
  /**
   * QuizQuestionGroupCountOutputType without action
   */
  export type QuizQuestionGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroupCountOutputType
     */
    select?: QuizQuestionGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizQuestionGroupCountOutputType without action
   */
  export type QuizQuestionGroupCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionWhereInput
  }

  /**
   * QuizQuestionGroupCountOutputType without action
   */
  export type QuizQuestionGroupCountOutputTypeCountMediasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionGroupMediaWhereInput
  }


  /**
   * Count Type QuizQuestionCountOutputType
   */

  export type QuizQuestionCountOutputType = {
    options: number
    answers: number
    medias: number
  }

  export type QuizQuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    options?: boolean | QuizQuestionCountOutputTypeCountOptionsArgs
    answers?: boolean | QuizQuestionCountOutputTypeCountAnswersArgs
    medias?: boolean | QuizQuestionCountOutputTypeCountMediasArgs
  }

  // Custom InputTypes
  /**
   * QuizQuestionCountOutputType without action
   */
  export type QuizQuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionCountOutputType
     */
    select?: QuizQuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizQuestionCountOutputType without action
   */
  export type QuizQuestionCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizOptionWhereInput
  }

  /**
   * QuizQuestionCountOutputType without action
   */
  export type QuizQuestionCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAnswerWhereInput
  }

  /**
   * QuizQuestionCountOutputType without action
   */
  export type QuizQuestionCountOutputTypeCountMediasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionMediaWhereInput
  }


  /**
   * Count Type QuizOptionCountOutputType
   */

  export type QuizOptionCountOutputType = {
    answers: number
    medias: number
  }

  export type QuizOptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | QuizOptionCountOutputTypeCountAnswersArgs
    medias?: boolean | QuizOptionCountOutputTypeCountMediasArgs
  }

  // Custom InputTypes
  /**
   * QuizOptionCountOutputType without action
   */
  export type QuizOptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOptionCountOutputType
     */
    select?: QuizOptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizOptionCountOutputType without action
   */
  export type QuizOptionCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAnswerWhereInput
  }

  /**
   * QuizOptionCountOutputType without action
   */
  export type QuizOptionCountOutputTypeCountMediasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizOptionMediaWhereInput
  }


  /**
   * Count Type QuizAttemptCountOutputType
   */

  export type QuizAttemptCountOutputType = {
    answers: number
  }

  export type QuizAttemptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | QuizAttemptCountOutputTypeCountAnswersArgs
  }

  // Custom InputTypes
  /**
   * QuizAttemptCountOutputType without action
   */
  export type QuizAttemptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttemptCountOutputType
     */
    select?: QuizAttemptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizAttemptCountOutputType without action
   */
  export type QuizAttemptCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAnswerWhereInput
  }


  /**
   * Models
   */

  /**
   * Model OtpRecord
   */

  export type AggregateOtpRecord = {
    _count: OtpRecordCountAggregateOutputType | null
    _avg: OtpRecordAvgAggregateOutputType | null
    _sum: OtpRecordSumAggregateOutputType | null
    _min: OtpRecordMinAggregateOutputType | null
    _max: OtpRecordMaxAggregateOutputType | null
  }

  export type OtpRecordAvgAggregateOutputType = {
    id: number | null
  }

  export type OtpRecordSumAggregateOutputType = {
    id: bigint | null
  }

  export type OtpRecordMinAggregateOutputType = {
    id: bigint | null
    email: string | null
    OtpCode: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type OtpRecordMaxAggregateOutputType = {
    id: bigint | null
    email: string | null
    OtpCode: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type OtpRecordCountAggregateOutputType = {
    id: number
    email: number
    OtpCode: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type OtpRecordAvgAggregateInputType = {
    id?: true
  }

  export type OtpRecordSumAggregateInputType = {
    id?: true
  }

  export type OtpRecordMinAggregateInputType = {
    id?: true
    email?: true
    OtpCode?: true
    createdAt?: true
    expiresAt?: true
  }

  export type OtpRecordMaxAggregateInputType = {
    id?: true
    email?: true
    OtpCode?: true
    createdAt?: true
    expiresAt?: true
  }

  export type OtpRecordCountAggregateInputType = {
    id?: true
    email?: true
    OtpCode?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type OtpRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OtpRecord to aggregate.
     */
    where?: OtpRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtpRecords to fetch.
     */
    orderBy?: OtpRecordOrderByWithRelationInput | OtpRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OtpRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtpRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtpRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OtpRecords
    **/
    _count?: true | OtpRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OtpRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OtpRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtpRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtpRecordMaxAggregateInputType
  }

  export type GetOtpRecordAggregateType<T extends OtpRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateOtpRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtpRecord[P]>
      : GetScalarType<T[P], AggregateOtpRecord[P]>
  }




  export type OtpRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtpRecordWhereInput
    orderBy?: OtpRecordOrderByWithAggregationInput | OtpRecordOrderByWithAggregationInput[]
    by: OtpRecordScalarFieldEnum[] | OtpRecordScalarFieldEnum
    having?: OtpRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtpRecordCountAggregateInputType | true
    _avg?: OtpRecordAvgAggregateInputType
    _sum?: OtpRecordSumAggregateInputType
    _min?: OtpRecordMinAggregateInputType
    _max?: OtpRecordMaxAggregateInputType
  }

  export type OtpRecordGroupByOutputType = {
    id: bigint
    email: string
    OtpCode: string
    createdAt: Date
    expiresAt: Date
    _count: OtpRecordCountAggregateOutputType | null
    _avg: OtpRecordAvgAggregateOutputType | null
    _sum: OtpRecordSumAggregateOutputType | null
    _min: OtpRecordMinAggregateOutputType | null
    _max: OtpRecordMaxAggregateOutputType | null
  }

  type GetOtpRecordGroupByPayload<T extends OtpRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtpRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtpRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtpRecordGroupByOutputType[P]>
            : GetScalarType<T[P], OtpRecordGroupByOutputType[P]>
        }
      >
    >


  export type OtpRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    OtpCode?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["otpRecord"]>

  export type OtpRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    OtpCode?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["otpRecord"]>

  export type OtpRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    OtpCode?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["otpRecord"]>

  export type OtpRecordSelectScalar = {
    id?: boolean
    email?: boolean
    OtpCode?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type OtpRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "OtpCode" | "createdAt" | "expiresAt", ExtArgs["result"]["otpRecord"]>

  export type $OtpRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OtpRecord"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      email: string
      OtpCode: string
      createdAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["otpRecord"]>
    composites: {}
  }

  type OtpRecordGetPayload<S extends boolean | null | undefined | OtpRecordDefaultArgs> = $Result.GetResult<Prisma.$OtpRecordPayload, S>

  type OtpRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OtpRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OtpRecordCountAggregateInputType | true
    }

  export interface OtpRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OtpRecord'], meta: { name: 'OtpRecord' } }
    /**
     * Find zero or one OtpRecord that matches the filter.
     * @param {OtpRecordFindUniqueArgs} args - Arguments to find a OtpRecord
     * @example
     * // Get one OtpRecord
     * const otpRecord = await prisma.otpRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OtpRecordFindUniqueArgs>(args: SelectSubset<T, OtpRecordFindUniqueArgs<ExtArgs>>): Prisma__OtpRecordClient<$Result.GetResult<Prisma.$OtpRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OtpRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OtpRecordFindUniqueOrThrowArgs} args - Arguments to find a OtpRecord
     * @example
     * // Get one OtpRecord
     * const otpRecord = await prisma.otpRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OtpRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, OtpRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OtpRecordClient<$Result.GetResult<Prisma.$OtpRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OtpRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpRecordFindFirstArgs} args - Arguments to find a OtpRecord
     * @example
     * // Get one OtpRecord
     * const otpRecord = await prisma.otpRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OtpRecordFindFirstArgs>(args?: SelectSubset<T, OtpRecordFindFirstArgs<ExtArgs>>): Prisma__OtpRecordClient<$Result.GetResult<Prisma.$OtpRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OtpRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpRecordFindFirstOrThrowArgs} args - Arguments to find a OtpRecord
     * @example
     * // Get one OtpRecord
     * const otpRecord = await prisma.otpRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OtpRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, OtpRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__OtpRecordClient<$Result.GetResult<Prisma.$OtpRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OtpRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OtpRecords
     * const otpRecords = await prisma.otpRecord.findMany()
     * 
     * // Get first 10 OtpRecords
     * const otpRecords = await prisma.otpRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otpRecordWithIdOnly = await prisma.otpRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OtpRecordFindManyArgs>(args?: SelectSubset<T, OtpRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OtpRecord.
     * @param {OtpRecordCreateArgs} args - Arguments to create a OtpRecord.
     * @example
     * // Create one OtpRecord
     * const OtpRecord = await prisma.otpRecord.create({
     *   data: {
     *     // ... data to create a OtpRecord
     *   }
     * })
     * 
     */
    create<T extends OtpRecordCreateArgs>(args: SelectSubset<T, OtpRecordCreateArgs<ExtArgs>>): Prisma__OtpRecordClient<$Result.GetResult<Prisma.$OtpRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OtpRecords.
     * @param {OtpRecordCreateManyArgs} args - Arguments to create many OtpRecords.
     * @example
     * // Create many OtpRecords
     * const otpRecord = await prisma.otpRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OtpRecordCreateManyArgs>(args?: SelectSubset<T, OtpRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OtpRecords and returns the data saved in the database.
     * @param {OtpRecordCreateManyAndReturnArgs} args - Arguments to create many OtpRecords.
     * @example
     * // Create many OtpRecords
     * const otpRecord = await prisma.otpRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OtpRecords and only return the `id`
     * const otpRecordWithIdOnly = await prisma.otpRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OtpRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, OtpRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OtpRecord.
     * @param {OtpRecordDeleteArgs} args - Arguments to delete one OtpRecord.
     * @example
     * // Delete one OtpRecord
     * const OtpRecord = await prisma.otpRecord.delete({
     *   where: {
     *     // ... filter to delete one OtpRecord
     *   }
     * })
     * 
     */
    delete<T extends OtpRecordDeleteArgs>(args: SelectSubset<T, OtpRecordDeleteArgs<ExtArgs>>): Prisma__OtpRecordClient<$Result.GetResult<Prisma.$OtpRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OtpRecord.
     * @param {OtpRecordUpdateArgs} args - Arguments to update one OtpRecord.
     * @example
     * // Update one OtpRecord
     * const otpRecord = await prisma.otpRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OtpRecordUpdateArgs>(args: SelectSubset<T, OtpRecordUpdateArgs<ExtArgs>>): Prisma__OtpRecordClient<$Result.GetResult<Prisma.$OtpRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OtpRecords.
     * @param {OtpRecordDeleteManyArgs} args - Arguments to filter OtpRecords to delete.
     * @example
     * // Delete a few OtpRecords
     * const { count } = await prisma.otpRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OtpRecordDeleteManyArgs>(args?: SelectSubset<T, OtpRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OtpRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OtpRecords
     * const otpRecord = await prisma.otpRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OtpRecordUpdateManyArgs>(args: SelectSubset<T, OtpRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OtpRecords and returns the data updated in the database.
     * @param {OtpRecordUpdateManyAndReturnArgs} args - Arguments to update many OtpRecords.
     * @example
     * // Update many OtpRecords
     * const otpRecord = await prisma.otpRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OtpRecords and only return the `id`
     * const otpRecordWithIdOnly = await prisma.otpRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OtpRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, OtpRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OtpRecord.
     * @param {OtpRecordUpsertArgs} args - Arguments to update or create a OtpRecord.
     * @example
     * // Update or create a OtpRecord
     * const otpRecord = await prisma.otpRecord.upsert({
     *   create: {
     *     // ... data to create a OtpRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OtpRecord we want to update
     *   }
     * })
     */
    upsert<T extends OtpRecordUpsertArgs>(args: SelectSubset<T, OtpRecordUpsertArgs<ExtArgs>>): Prisma__OtpRecordClient<$Result.GetResult<Prisma.$OtpRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OtpRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpRecordCountArgs} args - Arguments to filter OtpRecords to count.
     * @example
     * // Count the number of OtpRecords
     * const count = await prisma.otpRecord.count({
     *   where: {
     *     // ... the filter for the OtpRecords we want to count
     *   }
     * })
    **/
    count<T extends OtpRecordCountArgs>(
      args?: Subset<T, OtpRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtpRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OtpRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtpRecordAggregateArgs>(args: Subset<T, OtpRecordAggregateArgs>): Prisma.PrismaPromise<GetOtpRecordAggregateType<T>>

    /**
     * Group by OtpRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OtpRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OtpRecordGroupByArgs['orderBy'] }
        : { orderBy?: OtpRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OtpRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtpRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OtpRecord model
   */
  readonly fields: OtpRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OtpRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OtpRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OtpRecord model
   */
  interface OtpRecordFieldRefs {
    readonly id: FieldRef<"OtpRecord", 'BigInt'>
    readonly email: FieldRef<"OtpRecord", 'String'>
    readonly OtpCode: FieldRef<"OtpRecord", 'String'>
    readonly createdAt: FieldRef<"OtpRecord", 'DateTime'>
    readonly expiresAt: FieldRef<"OtpRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OtpRecord findUnique
   */
  export type OtpRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpRecord
     */
    select?: OtpRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpRecord
     */
    omit?: OtpRecordOmit<ExtArgs> | null
    /**
     * Filter, which OtpRecord to fetch.
     */
    where: OtpRecordWhereUniqueInput
  }

  /**
   * OtpRecord findUniqueOrThrow
   */
  export type OtpRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpRecord
     */
    select?: OtpRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpRecord
     */
    omit?: OtpRecordOmit<ExtArgs> | null
    /**
     * Filter, which OtpRecord to fetch.
     */
    where: OtpRecordWhereUniqueInput
  }

  /**
   * OtpRecord findFirst
   */
  export type OtpRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpRecord
     */
    select?: OtpRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpRecord
     */
    omit?: OtpRecordOmit<ExtArgs> | null
    /**
     * Filter, which OtpRecord to fetch.
     */
    where?: OtpRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtpRecords to fetch.
     */
    orderBy?: OtpRecordOrderByWithRelationInput | OtpRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OtpRecords.
     */
    cursor?: OtpRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtpRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtpRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OtpRecords.
     */
    distinct?: OtpRecordScalarFieldEnum | OtpRecordScalarFieldEnum[]
  }

  /**
   * OtpRecord findFirstOrThrow
   */
  export type OtpRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpRecord
     */
    select?: OtpRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpRecord
     */
    omit?: OtpRecordOmit<ExtArgs> | null
    /**
     * Filter, which OtpRecord to fetch.
     */
    where?: OtpRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtpRecords to fetch.
     */
    orderBy?: OtpRecordOrderByWithRelationInput | OtpRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OtpRecords.
     */
    cursor?: OtpRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtpRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtpRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OtpRecords.
     */
    distinct?: OtpRecordScalarFieldEnum | OtpRecordScalarFieldEnum[]
  }

  /**
   * OtpRecord findMany
   */
  export type OtpRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpRecord
     */
    select?: OtpRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpRecord
     */
    omit?: OtpRecordOmit<ExtArgs> | null
    /**
     * Filter, which OtpRecords to fetch.
     */
    where?: OtpRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtpRecords to fetch.
     */
    orderBy?: OtpRecordOrderByWithRelationInput | OtpRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OtpRecords.
     */
    cursor?: OtpRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtpRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtpRecords.
     */
    skip?: number
    distinct?: OtpRecordScalarFieldEnum | OtpRecordScalarFieldEnum[]
  }

  /**
   * OtpRecord create
   */
  export type OtpRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpRecord
     */
    select?: OtpRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpRecord
     */
    omit?: OtpRecordOmit<ExtArgs> | null
    /**
     * The data needed to create a OtpRecord.
     */
    data: XOR<OtpRecordCreateInput, OtpRecordUncheckedCreateInput>
  }

  /**
   * OtpRecord createMany
   */
  export type OtpRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OtpRecords.
     */
    data: OtpRecordCreateManyInput | OtpRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OtpRecord createManyAndReturn
   */
  export type OtpRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpRecord
     */
    select?: OtpRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OtpRecord
     */
    omit?: OtpRecordOmit<ExtArgs> | null
    /**
     * The data used to create many OtpRecords.
     */
    data: OtpRecordCreateManyInput | OtpRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OtpRecord update
   */
  export type OtpRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpRecord
     */
    select?: OtpRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpRecord
     */
    omit?: OtpRecordOmit<ExtArgs> | null
    /**
     * The data needed to update a OtpRecord.
     */
    data: XOR<OtpRecordUpdateInput, OtpRecordUncheckedUpdateInput>
    /**
     * Choose, which OtpRecord to update.
     */
    where: OtpRecordWhereUniqueInput
  }

  /**
   * OtpRecord updateMany
   */
  export type OtpRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OtpRecords.
     */
    data: XOR<OtpRecordUpdateManyMutationInput, OtpRecordUncheckedUpdateManyInput>
    /**
     * Filter which OtpRecords to update
     */
    where?: OtpRecordWhereInput
    /**
     * Limit how many OtpRecords to update.
     */
    limit?: number
  }

  /**
   * OtpRecord updateManyAndReturn
   */
  export type OtpRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpRecord
     */
    select?: OtpRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OtpRecord
     */
    omit?: OtpRecordOmit<ExtArgs> | null
    /**
     * The data used to update OtpRecords.
     */
    data: XOR<OtpRecordUpdateManyMutationInput, OtpRecordUncheckedUpdateManyInput>
    /**
     * Filter which OtpRecords to update
     */
    where?: OtpRecordWhereInput
    /**
     * Limit how many OtpRecords to update.
     */
    limit?: number
  }

  /**
   * OtpRecord upsert
   */
  export type OtpRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpRecord
     */
    select?: OtpRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpRecord
     */
    omit?: OtpRecordOmit<ExtArgs> | null
    /**
     * The filter to search for the OtpRecord to update in case it exists.
     */
    where: OtpRecordWhereUniqueInput
    /**
     * In case the OtpRecord found by the `where` argument doesn't exist, create a new OtpRecord with this data.
     */
    create: XOR<OtpRecordCreateInput, OtpRecordUncheckedCreateInput>
    /**
     * In case the OtpRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OtpRecordUpdateInput, OtpRecordUncheckedUpdateInput>
  }

  /**
   * OtpRecord delete
   */
  export type OtpRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpRecord
     */
    select?: OtpRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpRecord
     */
    omit?: OtpRecordOmit<ExtArgs> | null
    /**
     * Filter which OtpRecord to delete.
     */
    where: OtpRecordWhereUniqueInput
  }

  /**
   * OtpRecord deleteMany
   */
  export type OtpRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OtpRecords to delete
     */
    where?: OtpRecordWhereInput
    /**
     * Limit how many OtpRecords to delete.
     */
    limit?: number
  }

  /**
   * OtpRecord without action
   */
  export type OtpRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpRecord
     */
    select?: OtpRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OtpRecord
     */
    omit?: OtpRecordOmit<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _avg: RefreshTokenAvgAggregateOutputType | null
    _sum: RefreshTokenSumAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type RefreshTokenSumAggregateOutputType = {
    id: bigint | null
    userId: number | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: bigint | null
    userId: number | null
    tokenHash: string | null
    issuedAt: Date | null
    expiresAt: Date | null
    revokedAt: Date | null
    replacedByHash: string | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: bigint | null
    userId: number | null
    tokenHash: string | null
    issuedAt: Date | null
    expiresAt: Date | null
    revokedAt: Date | null
    replacedByHash: string | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    userId: number
    tokenHash: number
    issuedAt: number
    expiresAt: number
    revokedAt: number
    replacedByHash: number
    _all: number
  }


  export type RefreshTokenAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type RefreshTokenSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type RefreshTokenMinAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    issuedAt?: true
    expiresAt?: true
    revokedAt?: true
    replacedByHash?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    issuedAt?: true
    expiresAt?: true
    revokedAt?: true
    replacedByHash?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    issuedAt?: true
    expiresAt?: true
    revokedAt?: true
    replacedByHash?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefreshTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefreshTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _avg?: RefreshTokenAvgAggregateInputType
    _sum?: RefreshTokenSumAggregateInputType
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: bigint
    userId: number
    tokenHash: string
    issuedAt: Date
    expiresAt: Date
    revokedAt: Date | null
    replacedByHash: string | null
    _count: RefreshTokenCountAggregateOutputType | null
    _avg: RefreshTokenAvgAggregateOutputType | null
    _sum: RefreshTokenSumAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    replacedByHash?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    replacedByHash?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    replacedByHash?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    replacedByHash?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "tokenHash" | "issuedAt" | "expiresAt" | "revokedAt" | "replacedByHash", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      userId: number
      tokenHash: string
      issuedAt: Date
      expiresAt: Date
      revokedAt: Date | null
      replacedByHash: string | null
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'BigInt'>
    readonly userId: FieldRef<"RefreshToken", 'Int'>
    readonly tokenHash: FieldRef<"RefreshToken", 'String'>
    readonly issuedAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly revokedAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly replacedByHash: FieldRef<"RefreshToken", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model Media
   */

  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaAvgAggregateOutputType = {
    id: number | null
    sizeBytes: number | null
    uploadedBy: number | null
  }

  export type MediaSumAggregateOutputType = {
    id: number | null
    sizeBytes: bigint | null
    uploadedBy: number | null
  }

  export type MediaMinAggregateOutputType = {
    id: number | null
    disk: string | null
    bucket: string | null
    objectKey: string | null
    mimeType: string | null
    sizeBytes: bigint | null
    visibility: string | null
    uploadedBy: number | null
    createdAt: Date | null
  }

  export type MediaMaxAggregateOutputType = {
    id: number | null
    disk: string | null
    bucket: string | null
    objectKey: string | null
    mimeType: string | null
    sizeBytes: bigint | null
    visibility: string | null
    uploadedBy: number | null
    createdAt: Date | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    disk: number
    bucket: number
    objectKey: number
    mimeType: number
    sizeBytes: number
    visibility: number
    uploadedBy: number
    createdAt: number
    _all: number
  }


  export type MediaAvgAggregateInputType = {
    id?: true
    sizeBytes?: true
    uploadedBy?: true
  }

  export type MediaSumAggregateInputType = {
    id?: true
    sizeBytes?: true
    uploadedBy?: true
  }

  export type MediaMinAggregateInputType = {
    id?: true
    disk?: true
    bucket?: true
    objectKey?: true
    mimeType?: true
    sizeBytes?: true
    visibility?: true
    uploadedBy?: true
    createdAt?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    disk?: true
    bucket?: true
    objectKey?: true
    mimeType?: true
    sizeBytes?: true
    visibility?: true
    uploadedBy?: true
    createdAt?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    disk?: true
    bucket?: true
    objectKey?: true
    mimeType?: true
    sizeBytes?: true
    visibility?: true
    uploadedBy?: true
    createdAt?: true
    _all?: true
  }

  export type MediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to aggregate.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithAggregationInput | MediaOrderByWithAggregationInput[]
    by: MediaScalarFieldEnum[] | MediaScalarFieldEnum
    having?: MediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _avg?: MediaAvgAggregateInputType
    _sum?: MediaSumAggregateInputType
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }

  export type MediaGroupByOutputType = {
    id: number
    disk: string
    bucket: string | null
    objectKey: string
    mimeType: string | null
    sizeBytes: bigint | null
    visibility: string
    uploadedBy: number | null
    createdAt: Date
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type MediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    disk?: boolean
    bucket?: boolean
    objectKey?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    visibility?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    uploader?: boolean | Media$uploaderArgs<ExtArgs>
    userAvatars?: boolean | Media$userAvatarsArgs<ExtArgs>
    classroomCovers?: boolean | Media$classroomCoversArgs<ExtArgs>
    materials?: boolean | Media$materialsArgs<ExtArgs>
    exerciseAttachments?: boolean | Media$exerciseAttachmentsArgs<ExtArgs>
    exerciseSubmissions?: boolean | Media$exerciseSubmissionsArgs<ExtArgs>
    quizQuestionGroupMedias?: boolean | Media$quizQuestionGroupMediasArgs<ExtArgs>
    quizQuestionMedias?: boolean | Media$quizQuestionMediasArgs<ExtArgs>
    quizOptionMedias?: boolean | Media$quizOptionMediasArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    disk?: boolean
    bucket?: boolean
    objectKey?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    visibility?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    uploader?: boolean | Media$uploaderArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    disk?: boolean
    bucket?: boolean
    objectKey?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    visibility?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    uploader?: boolean | Media$uploaderArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectScalar = {
    id?: boolean
    disk?: boolean
    bucket?: boolean
    objectKey?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    visibility?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
  }

  export type MediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "disk" | "bucket" | "objectKey" | "mimeType" | "sizeBytes" | "visibility" | "uploadedBy" | "createdAt", ExtArgs["result"]["media"]>
  export type MediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploader?: boolean | Media$uploaderArgs<ExtArgs>
    userAvatars?: boolean | Media$userAvatarsArgs<ExtArgs>
    classroomCovers?: boolean | Media$classroomCoversArgs<ExtArgs>
    materials?: boolean | Media$materialsArgs<ExtArgs>
    exerciseAttachments?: boolean | Media$exerciseAttachmentsArgs<ExtArgs>
    exerciseSubmissions?: boolean | Media$exerciseSubmissionsArgs<ExtArgs>
    quizQuestionGroupMedias?: boolean | Media$quizQuestionGroupMediasArgs<ExtArgs>
    quizQuestionMedias?: boolean | Media$quizQuestionMediasArgs<ExtArgs>
    quizOptionMedias?: boolean | Media$quizOptionMediasArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploader?: boolean | Media$uploaderArgs<ExtArgs>
  }
  export type MediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploader?: boolean | Media$uploaderArgs<ExtArgs>
  }

  export type $MediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Media"
    objects: {
      uploader: Prisma.$UserPayload<ExtArgs> | null
      userAvatars: Prisma.$UserPayload<ExtArgs>[]
      classroomCovers: Prisma.$ClassroomPayload<ExtArgs>[]
      materials: Prisma.$MaterialPayload<ExtArgs>[]
      exerciseAttachments: Prisma.$ExercisePayload<ExtArgs>[]
      exerciseSubmissions: Prisma.$ExerciseSubmissionPayload<ExtArgs>[]
      quizQuestionGroupMedias: Prisma.$QuizQuestionGroupMediaPayload<ExtArgs>[]
      quizQuestionMedias: Prisma.$QuizQuestionMediaPayload<ExtArgs>[]
      quizOptionMedias: Prisma.$QuizOptionMediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      disk: string
      bucket: string | null
      objectKey: string
      mimeType: string | null
      sizeBytes: bigint | null
      visibility: string
      uploadedBy: number | null
      createdAt: Date
    }, ExtArgs["result"]["media"]>
    composites: {}
  }

  type MediaGetPayload<S extends boolean | null | undefined | MediaDefaultArgs> = $Result.GetResult<Prisma.$MediaPayload, S>

  type MediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediaCountAggregateInputType | true
    }

  export interface MediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Media'], meta: { name: 'Media' } }
    /**
     * Find zero or one Media that matches the filter.
     * @param {MediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFindUniqueArgs>(args: SelectSubset<T, MediaFindUniqueArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Media that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MediaFindUniqueOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFindFirstArgs>(args?: SelectSubset<T, MediaFindFirstArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFindManyArgs>(args?: SelectSubset<T, MediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Media.
     * @param {MediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
     */
    create<T extends MediaCreateArgs>(args: SelectSubset<T, MediaCreateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Media.
     * @param {MediaCreateManyArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaCreateManyArgs>(args?: SelectSubset<T, MediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Media and returns the data saved in the database.
     * @param {MediaCreateManyAndReturnArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Media.
     * @param {MediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
     */
    delete<T extends MediaDeleteArgs>(args: SelectSubset<T, MediaDeleteArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Media.
     * @param {MediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaUpdateArgs>(args: SelectSubset<T, MediaUpdateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Media.
     * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaDeleteManyArgs>(args?: SelectSubset<T, MediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaUpdateManyArgs>(args: SelectSubset<T, MediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media and returns the data updated in the database.
     * @param {MediaUpdateManyAndReturnArgs} args - Arguments to update many Media.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MediaUpdateManyAndReturnArgs>(args: SelectSubset<T, MediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Media.
     * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
     */
    upsert<T extends MediaUpsertArgs>(args: SelectSubset<T, MediaUpsertArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends MediaCountArgs>(
      args?: Subset<T, MediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): Prisma.PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Media model
   */
  readonly fields: MediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    uploader<T extends Media$uploaderArgs<ExtArgs> = {}>(args?: Subset<T, Media$uploaderArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userAvatars<T extends Media$userAvatarsArgs<ExtArgs> = {}>(args?: Subset<T, Media$userAvatarsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classroomCovers<T extends Media$classroomCoversArgs<ExtArgs> = {}>(args?: Subset<T, Media$classroomCoversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    materials<T extends Media$materialsArgs<ExtArgs> = {}>(args?: Subset<T, Media$materialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exerciseAttachments<T extends Media$exerciseAttachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Media$exerciseAttachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exerciseSubmissions<T extends Media$exerciseSubmissionsArgs<ExtArgs> = {}>(args?: Subset<T, Media$exerciseSubmissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quizQuestionGroupMedias<T extends Media$quizQuestionGroupMediasArgs<ExtArgs> = {}>(args?: Subset<T, Media$quizQuestionGroupMediasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionGroupMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quizQuestionMedias<T extends Media$quizQuestionMediasArgs<ExtArgs> = {}>(args?: Subset<T, Media$quizQuestionMediasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quizOptionMedias<T extends Media$quizOptionMediasArgs<ExtArgs> = {}>(args?: Subset<T, Media$quizOptionMediasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizOptionMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Media model
   */
  interface MediaFieldRefs {
    readonly id: FieldRef<"Media", 'Int'>
    readonly disk: FieldRef<"Media", 'String'>
    readonly bucket: FieldRef<"Media", 'String'>
    readonly objectKey: FieldRef<"Media", 'String'>
    readonly mimeType: FieldRef<"Media", 'String'>
    readonly sizeBytes: FieldRef<"Media", 'BigInt'>
    readonly visibility: FieldRef<"Media", 'String'>
    readonly uploadedBy: FieldRef<"Media", 'Int'>
    readonly createdAt: FieldRef<"Media", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Media findUnique
   */
  export type MediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findUniqueOrThrow
   */
  export type MediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findFirst
   */
  export type MediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findFirstOrThrow
   */
  export type MediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findMany
   */
  export type MediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media create
   */
  export type MediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to create a Media.
     */
    data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
  }

  /**
   * Media createMany
   */
  export type MediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Media createManyAndReturn
   */
  export type MediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Media update
   */
  export type MediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to update a Media.
     */
    data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    /**
     * Choose, which Media to update.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media updateMany
   */
  export type MediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to update.
     */
    limit?: number
  }

  /**
   * Media updateManyAndReturn
   */
  export type MediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Media upsert
   */
  export type MediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The filter to search for the Media to update in case it exists.
     */
    where: MediaWhereUniqueInput
    /**
     * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
     */
    create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    /**
     * In case the Media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
  }

  /**
   * Media delete
   */
  export type MediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter which Media to delete.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media deleteMany
   */
  export type MediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to delete
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to delete.
     */
    limit?: number
  }

  /**
   * Media.uploader
   */
  export type Media$uploaderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Media.userAvatars
   */
  export type Media$userAvatarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Media.classroomCovers
   */
  export type Media$classroomCoversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    where?: ClassroomWhereInput
    orderBy?: ClassroomOrderByWithRelationInput | ClassroomOrderByWithRelationInput[]
    cursor?: ClassroomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassroomScalarFieldEnum | ClassroomScalarFieldEnum[]
  }

  /**
   * Media.materials
   */
  export type Media$materialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    cursor?: MaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Media.exerciseAttachments
   */
  export type Media$exerciseAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    cursor?: ExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Media.exerciseSubmissions
   */
  export type Media$exerciseSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionInclude<ExtArgs> | null
    where?: ExerciseSubmissionWhereInput
    orderBy?: ExerciseSubmissionOrderByWithRelationInput | ExerciseSubmissionOrderByWithRelationInput[]
    cursor?: ExerciseSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseSubmissionScalarFieldEnum | ExerciseSubmissionScalarFieldEnum[]
  }

  /**
   * Media.quizQuestionGroupMedias
   */
  export type Media$quizQuestionGroupMediasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroupMedia
     */
    select?: QuizQuestionGroupMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroupMedia
     */
    omit?: QuizQuestionGroupMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupMediaInclude<ExtArgs> | null
    where?: QuizQuestionGroupMediaWhereInput
    orderBy?: QuizQuestionGroupMediaOrderByWithRelationInput | QuizQuestionGroupMediaOrderByWithRelationInput[]
    cursor?: QuizQuestionGroupMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizQuestionGroupMediaScalarFieldEnum | QuizQuestionGroupMediaScalarFieldEnum[]
  }

  /**
   * Media.quizQuestionMedias
   */
  export type Media$quizQuestionMediasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionMedia
     */
    select?: QuizQuestionMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionMedia
     */
    omit?: QuizQuestionMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionMediaInclude<ExtArgs> | null
    where?: QuizQuestionMediaWhereInput
    orderBy?: QuizQuestionMediaOrderByWithRelationInput | QuizQuestionMediaOrderByWithRelationInput[]
    cursor?: QuizQuestionMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizQuestionMediaScalarFieldEnum | QuizQuestionMediaScalarFieldEnum[]
  }

  /**
   * Media.quizOptionMedias
   */
  export type Media$quizOptionMediasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOptionMedia
     */
    select?: QuizOptionMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOptionMedia
     */
    omit?: QuizOptionMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionMediaInclude<ExtArgs> | null
    where?: QuizOptionMediaWhereInput
    orderBy?: QuizOptionMediaOrderByWithRelationInput | QuizOptionMediaOrderByWithRelationInput[]
    cursor?: QuizOptionMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizOptionMediaScalarFieldEnum | QuizOptionMediaScalarFieldEnum[]
  }

  /**
   * Media without action
   */
  export type MediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    avatarMediaId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    avatarMediaId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    fullName: string | null
    email: string | null
    passwordHash: string | null
    phone: string | null
    role: $Enums.Role | null
    avatarMediaId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    fullName: string | null
    email: string | null
    passwordHash: string | null
    phone: string | null
    role: $Enums.Role | null
    avatarMediaId: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    fullName: number
    email: number
    passwordHash: number
    phone: number
    role: number
    avatarMediaId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    avatarMediaId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    avatarMediaId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    fullName?: true
    email?: true
    passwordHash?: true
    phone?: true
    role?: true
    avatarMediaId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    fullName?: true
    email?: true
    passwordHash?: true
    phone?: true
    role?: true
    avatarMediaId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    fullName?: true
    email?: true
    passwordHash?: true
    phone?: true
    role?: true
    avatarMediaId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role: $Enums.Role
    avatarMediaId: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    email?: boolean
    passwordHash?: boolean
    phone?: boolean
    role?: boolean
    avatarMediaId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    avatarMedia?: boolean | User$avatarMediaArgs<ExtArgs>
    uploadedMedia?: boolean | User$uploadedMediaArgs<ExtArgs>
    taughtClassrooms?: boolean | User$taughtClassroomsArgs<ExtArgs>
    createdClassrooms?: boolean | User$createdClassroomsArgs<ExtArgs>
    classroomStudents?: boolean | User$classroomStudentsArgs<ExtArgs>
    joinRequests?: boolean | User$joinRequestsArgs<ExtArgs>
    uploadedMaterials?: boolean | User$uploadedMaterialsArgs<ExtArgs>
    createdExercises?: boolean | User$createdExercisesArgs<ExtArgs>
    exerciseSubmissions?: boolean | User$exerciseSubmissionsArgs<ExtArgs>
    createdQuizzes?: boolean | User$createdQuizzesArgs<ExtArgs>
    quizAttempts?: boolean | User$quizAttemptsArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    email?: boolean
    passwordHash?: boolean
    phone?: boolean
    role?: boolean
    avatarMediaId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    avatarMedia?: boolean | User$avatarMediaArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    email?: boolean
    passwordHash?: boolean
    phone?: boolean
    role?: boolean
    avatarMediaId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    avatarMedia?: boolean | User$avatarMediaArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    fullName?: boolean
    email?: boolean
    passwordHash?: boolean
    phone?: boolean
    role?: boolean
    avatarMediaId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fullName" | "email" | "passwordHash" | "phone" | "role" | "avatarMediaId" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avatarMedia?: boolean | User$avatarMediaArgs<ExtArgs>
    uploadedMedia?: boolean | User$uploadedMediaArgs<ExtArgs>
    taughtClassrooms?: boolean | User$taughtClassroomsArgs<ExtArgs>
    createdClassrooms?: boolean | User$createdClassroomsArgs<ExtArgs>
    classroomStudents?: boolean | User$classroomStudentsArgs<ExtArgs>
    joinRequests?: boolean | User$joinRequestsArgs<ExtArgs>
    uploadedMaterials?: boolean | User$uploadedMaterialsArgs<ExtArgs>
    createdExercises?: boolean | User$createdExercisesArgs<ExtArgs>
    exerciseSubmissions?: boolean | User$exerciseSubmissionsArgs<ExtArgs>
    createdQuizzes?: boolean | User$createdQuizzesArgs<ExtArgs>
    quizAttempts?: boolean | User$quizAttemptsArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avatarMedia?: boolean | User$avatarMediaArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avatarMedia?: boolean | User$avatarMediaArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      avatarMedia: Prisma.$MediaPayload<ExtArgs> | null
      uploadedMedia: Prisma.$MediaPayload<ExtArgs>[]
      taughtClassrooms: Prisma.$ClassroomPayload<ExtArgs>[]
      createdClassrooms: Prisma.$ClassroomPayload<ExtArgs>[]
      classroomStudents: Prisma.$ClassroomStudentPayload<ExtArgs>[]
      joinRequests: Prisma.$JoinRequestPayload<ExtArgs>[]
      uploadedMaterials: Prisma.$MaterialPayload<ExtArgs>[]
      createdExercises: Prisma.$ExercisePayload<ExtArgs>[]
      exerciseSubmissions: Prisma.$ExerciseSubmissionPayload<ExtArgs>[]
      createdQuizzes: Prisma.$QuizPayload<ExtArgs>[]
      quizAttempts: Prisma.$QuizAttemptPayload<ExtArgs>[]
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fullName: string
      email: string
      passwordHash: string
      phone: string
      role: $Enums.Role
      avatarMediaId: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    avatarMedia<T extends User$avatarMediaArgs<ExtArgs> = {}>(args?: Subset<T, User$avatarMediaArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    uploadedMedia<T extends User$uploadedMediaArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedMediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taughtClassrooms<T extends User$taughtClassroomsArgs<ExtArgs> = {}>(args?: Subset<T, User$taughtClassroomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdClassrooms<T extends User$createdClassroomsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdClassroomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classroomStudents<T extends User$classroomStudentsArgs<ExtArgs> = {}>(args?: Subset<T, User$classroomStudentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomStudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    joinRequests<T extends User$joinRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$joinRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploadedMaterials<T extends User$uploadedMaterialsArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedMaterialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdExercises<T extends User$createdExercisesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdExercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exerciseSubmissions<T extends User$exerciseSubmissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$exerciseSubmissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdQuizzes<T extends User$createdQuizzesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdQuizzesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quizAttempts<T extends User$quizAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, User$quizAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly avatarMediaId: FieldRef<"User", 'Int'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.avatarMedia
   */
  export type User$avatarMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * User.uploadedMedia
   */
  export type User$uploadedMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * User.taughtClassrooms
   */
  export type User$taughtClassroomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    where?: ClassroomWhereInput
    orderBy?: ClassroomOrderByWithRelationInput | ClassroomOrderByWithRelationInput[]
    cursor?: ClassroomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassroomScalarFieldEnum | ClassroomScalarFieldEnum[]
  }

  /**
   * User.createdClassrooms
   */
  export type User$createdClassroomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    where?: ClassroomWhereInput
    orderBy?: ClassroomOrderByWithRelationInput | ClassroomOrderByWithRelationInput[]
    cursor?: ClassroomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassroomScalarFieldEnum | ClassroomScalarFieldEnum[]
  }

  /**
   * User.classroomStudents
   */
  export type User$classroomStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomStudent
     */
    select?: ClassroomStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassroomStudent
     */
    omit?: ClassroomStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomStudentInclude<ExtArgs> | null
    where?: ClassroomStudentWhereInput
    orderBy?: ClassroomStudentOrderByWithRelationInput | ClassroomStudentOrderByWithRelationInput[]
    cursor?: ClassroomStudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassroomStudentScalarFieldEnum | ClassroomStudentScalarFieldEnum[]
  }

  /**
   * User.joinRequests
   */
  export type User$joinRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinRequest
     */
    select?: JoinRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinRequest
     */
    omit?: JoinRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinRequestInclude<ExtArgs> | null
    where?: JoinRequestWhereInput
    orderBy?: JoinRequestOrderByWithRelationInput | JoinRequestOrderByWithRelationInput[]
    cursor?: JoinRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JoinRequestScalarFieldEnum | JoinRequestScalarFieldEnum[]
  }

  /**
   * User.uploadedMaterials
   */
  export type User$uploadedMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    cursor?: MaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * User.createdExercises
   */
  export type User$createdExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    cursor?: ExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * User.exerciseSubmissions
   */
  export type User$exerciseSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionInclude<ExtArgs> | null
    where?: ExerciseSubmissionWhereInput
    orderBy?: ExerciseSubmissionOrderByWithRelationInput | ExerciseSubmissionOrderByWithRelationInput[]
    cursor?: ExerciseSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseSubmissionScalarFieldEnum | ExerciseSubmissionScalarFieldEnum[]
  }

  /**
   * User.createdQuizzes
   */
  export type User$createdQuizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    where?: QuizWhereInput
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    cursor?: QuizWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * User.quizAttempts
   */
  export type User$quizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    where?: QuizAttemptWhereInput
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    cursor?: QuizAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Classroom
   */

  export type AggregateClassroom = {
    _count: ClassroomCountAggregateOutputType | null
    _avg: ClassroomAvgAggregateOutputType | null
    _sum: ClassroomSumAggregateOutputType | null
    _min: ClassroomMinAggregateOutputType | null
    _max: ClassroomMaxAggregateOutputType | null
  }

  export type ClassroomAvgAggregateOutputType = {
    id: number | null
    tutorId: number | null
    coverMediaId: number | null
    createdBy: number | null
  }

  export type ClassroomSumAggregateOutputType = {
    id: number | null
    tutorId: number | null
    coverMediaId: number | null
    createdBy: number | null
  }

  export type ClassroomMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    tutorId: number | null
    coverMediaId: number | null
    isArchived: boolean | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassroomMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    tutorId: number | null
    coverMediaId: number | null
    isArchived: boolean | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassroomCountAggregateOutputType = {
    id: number
    name: number
    description: number
    tutorId: number
    coverMediaId: number
    isArchived: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClassroomAvgAggregateInputType = {
    id?: true
    tutorId?: true
    coverMediaId?: true
    createdBy?: true
  }

  export type ClassroomSumAggregateInputType = {
    id?: true
    tutorId?: true
    coverMediaId?: true
    createdBy?: true
  }

  export type ClassroomMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tutorId?: true
    coverMediaId?: true
    isArchived?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassroomMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tutorId?: true
    coverMediaId?: true
    isArchived?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassroomCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tutorId?: true
    coverMediaId?: true
    isArchived?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClassroomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classroom to aggregate.
     */
    where?: ClassroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classrooms to fetch.
     */
    orderBy?: ClassroomOrderByWithRelationInput | ClassroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classrooms
    **/
    _count?: true | ClassroomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassroomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassroomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassroomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassroomMaxAggregateInputType
  }

  export type GetClassroomAggregateType<T extends ClassroomAggregateArgs> = {
        [P in keyof T & keyof AggregateClassroom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassroom[P]>
      : GetScalarType<T[P], AggregateClassroom[P]>
  }




  export type ClassroomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomWhereInput
    orderBy?: ClassroomOrderByWithAggregationInput | ClassroomOrderByWithAggregationInput[]
    by: ClassroomScalarFieldEnum[] | ClassroomScalarFieldEnum
    having?: ClassroomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassroomCountAggregateInputType | true
    _avg?: ClassroomAvgAggregateInputType
    _sum?: ClassroomSumAggregateInputType
    _min?: ClassroomMinAggregateInputType
    _max?: ClassroomMaxAggregateInputType
  }

  export type ClassroomGroupByOutputType = {
    id: number
    name: string
    description: string | null
    tutorId: number
    coverMediaId: number | null
    isArchived: boolean
    createdBy: number
    createdAt: Date
    updatedAt: Date
    _count: ClassroomCountAggregateOutputType | null
    _avg: ClassroomAvgAggregateOutputType | null
    _sum: ClassroomSumAggregateOutputType | null
    _min: ClassroomMinAggregateOutputType | null
    _max: ClassroomMaxAggregateOutputType | null
  }

  type GetClassroomGroupByPayload<T extends ClassroomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassroomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassroomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassroomGroupByOutputType[P]>
            : GetScalarType<T[P], ClassroomGroupByOutputType[P]>
        }
      >
    >


  export type ClassroomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tutorId?: boolean
    coverMediaId?: boolean
    isArchived?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tutor?: boolean | UserDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    coverMedia?: boolean | Classroom$coverMediaArgs<ExtArgs>
    classroomStudents?: boolean | Classroom$classroomStudentsArgs<ExtArgs>
    joinRequests?: boolean | Classroom$joinRequestsArgs<ExtArgs>
    lessons?: boolean | Classroom$lessonsArgs<ExtArgs>
    _count?: boolean | ClassroomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classroom"]>

  export type ClassroomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tutorId?: boolean
    coverMediaId?: boolean
    isArchived?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tutor?: boolean | UserDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    coverMedia?: boolean | Classroom$coverMediaArgs<ExtArgs>
  }, ExtArgs["result"]["classroom"]>

  export type ClassroomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tutorId?: boolean
    coverMediaId?: boolean
    isArchived?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tutor?: boolean | UserDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    coverMedia?: boolean | Classroom$coverMediaArgs<ExtArgs>
  }, ExtArgs["result"]["classroom"]>

  export type ClassroomSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    tutorId?: boolean
    coverMediaId?: boolean
    isArchived?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClassroomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "tutorId" | "coverMediaId" | "isArchived" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["classroom"]>
  export type ClassroomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tutor?: boolean | UserDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    coverMedia?: boolean | Classroom$coverMediaArgs<ExtArgs>
    classroomStudents?: boolean | Classroom$classroomStudentsArgs<ExtArgs>
    joinRequests?: boolean | Classroom$joinRequestsArgs<ExtArgs>
    lessons?: boolean | Classroom$lessonsArgs<ExtArgs>
    _count?: boolean | ClassroomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassroomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tutor?: boolean | UserDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    coverMedia?: boolean | Classroom$coverMediaArgs<ExtArgs>
  }
  export type ClassroomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tutor?: boolean | UserDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    coverMedia?: boolean | Classroom$coverMediaArgs<ExtArgs>
  }

  export type $ClassroomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Classroom"
    objects: {
      tutor: Prisma.$UserPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      coverMedia: Prisma.$MediaPayload<ExtArgs> | null
      classroomStudents: Prisma.$ClassroomStudentPayload<ExtArgs>[]
      joinRequests: Prisma.$JoinRequestPayload<ExtArgs>[]
      lessons: Prisma.$LessonPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      tutorId: number
      coverMediaId: number | null
      isArchived: boolean
      createdBy: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["classroom"]>
    composites: {}
  }

  type ClassroomGetPayload<S extends boolean | null | undefined | ClassroomDefaultArgs> = $Result.GetResult<Prisma.$ClassroomPayload, S>

  type ClassroomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassroomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassroomCountAggregateInputType | true
    }

  export interface ClassroomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Classroom'], meta: { name: 'Classroom' } }
    /**
     * Find zero or one Classroom that matches the filter.
     * @param {ClassroomFindUniqueArgs} args - Arguments to find a Classroom
     * @example
     * // Get one Classroom
     * const classroom = await prisma.classroom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassroomFindUniqueArgs>(args: SelectSubset<T, ClassroomFindUniqueArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Classroom that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassroomFindUniqueOrThrowArgs} args - Arguments to find a Classroom
     * @example
     * // Get one Classroom
     * const classroom = await prisma.classroom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassroomFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassroomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Classroom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomFindFirstArgs} args - Arguments to find a Classroom
     * @example
     * // Get one Classroom
     * const classroom = await prisma.classroom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassroomFindFirstArgs>(args?: SelectSubset<T, ClassroomFindFirstArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Classroom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomFindFirstOrThrowArgs} args - Arguments to find a Classroom
     * @example
     * // Get one Classroom
     * const classroom = await prisma.classroom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassroomFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassroomFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Classrooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classrooms
     * const classrooms = await prisma.classroom.findMany()
     * 
     * // Get first 10 Classrooms
     * const classrooms = await prisma.classroom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classroomWithIdOnly = await prisma.classroom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassroomFindManyArgs>(args?: SelectSubset<T, ClassroomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Classroom.
     * @param {ClassroomCreateArgs} args - Arguments to create a Classroom.
     * @example
     * // Create one Classroom
     * const Classroom = await prisma.classroom.create({
     *   data: {
     *     // ... data to create a Classroom
     *   }
     * })
     * 
     */
    create<T extends ClassroomCreateArgs>(args: SelectSubset<T, ClassroomCreateArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Classrooms.
     * @param {ClassroomCreateManyArgs} args - Arguments to create many Classrooms.
     * @example
     * // Create many Classrooms
     * const classroom = await prisma.classroom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassroomCreateManyArgs>(args?: SelectSubset<T, ClassroomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classrooms and returns the data saved in the database.
     * @param {ClassroomCreateManyAndReturnArgs} args - Arguments to create many Classrooms.
     * @example
     * // Create many Classrooms
     * const classroom = await prisma.classroom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classrooms and only return the `id`
     * const classroomWithIdOnly = await prisma.classroom.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassroomCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassroomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Classroom.
     * @param {ClassroomDeleteArgs} args - Arguments to delete one Classroom.
     * @example
     * // Delete one Classroom
     * const Classroom = await prisma.classroom.delete({
     *   where: {
     *     // ... filter to delete one Classroom
     *   }
     * })
     * 
     */
    delete<T extends ClassroomDeleteArgs>(args: SelectSubset<T, ClassroomDeleteArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Classroom.
     * @param {ClassroomUpdateArgs} args - Arguments to update one Classroom.
     * @example
     * // Update one Classroom
     * const classroom = await prisma.classroom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassroomUpdateArgs>(args: SelectSubset<T, ClassroomUpdateArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Classrooms.
     * @param {ClassroomDeleteManyArgs} args - Arguments to filter Classrooms to delete.
     * @example
     * // Delete a few Classrooms
     * const { count } = await prisma.classroom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassroomDeleteManyArgs>(args?: SelectSubset<T, ClassroomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classrooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classrooms
     * const classroom = await prisma.classroom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassroomUpdateManyArgs>(args: SelectSubset<T, ClassroomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classrooms and returns the data updated in the database.
     * @param {ClassroomUpdateManyAndReturnArgs} args - Arguments to update many Classrooms.
     * @example
     * // Update many Classrooms
     * const classroom = await prisma.classroom.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Classrooms and only return the `id`
     * const classroomWithIdOnly = await prisma.classroom.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassroomUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassroomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Classroom.
     * @param {ClassroomUpsertArgs} args - Arguments to update or create a Classroom.
     * @example
     * // Update or create a Classroom
     * const classroom = await prisma.classroom.upsert({
     *   create: {
     *     // ... data to create a Classroom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Classroom we want to update
     *   }
     * })
     */
    upsert<T extends ClassroomUpsertArgs>(args: SelectSubset<T, ClassroomUpsertArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Classrooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomCountArgs} args - Arguments to filter Classrooms to count.
     * @example
     * // Count the number of Classrooms
     * const count = await prisma.classroom.count({
     *   where: {
     *     // ... the filter for the Classrooms we want to count
     *   }
     * })
    **/
    count<T extends ClassroomCountArgs>(
      args?: Subset<T, ClassroomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassroomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Classroom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassroomAggregateArgs>(args: Subset<T, ClassroomAggregateArgs>): Prisma.PrismaPromise<GetClassroomAggregateType<T>>

    /**
     * Group by Classroom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassroomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassroomGroupByArgs['orderBy'] }
        : { orderBy?: ClassroomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassroomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassroomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Classroom model
   */
  readonly fields: ClassroomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Classroom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassroomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tutor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    coverMedia<T extends Classroom$coverMediaArgs<ExtArgs> = {}>(args?: Subset<T, Classroom$coverMediaArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    classroomStudents<T extends Classroom$classroomStudentsArgs<ExtArgs> = {}>(args?: Subset<T, Classroom$classroomStudentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomStudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    joinRequests<T extends Classroom$joinRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Classroom$joinRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lessons<T extends Classroom$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, Classroom$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Classroom model
   */
  interface ClassroomFieldRefs {
    readonly id: FieldRef<"Classroom", 'Int'>
    readonly name: FieldRef<"Classroom", 'String'>
    readonly description: FieldRef<"Classroom", 'String'>
    readonly tutorId: FieldRef<"Classroom", 'Int'>
    readonly coverMediaId: FieldRef<"Classroom", 'Int'>
    readonly isArchived: FieldRef<"Classroom", 'Boolean'>
    readonly createdBy: FieldRef<"Classroom", 'Int'>
    readonly createdAt: FieldRef<"Classroom", 'DateTime'>
    readonly updatedAt: FieldRef<"Classroom", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Classroom findUnique
   */
  export type ClassroomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * Filter, which Classroom to fetch.
     */
    where: ClassroomWhereUniqueInput
  }

  /**
   * Classroom findUniqueOrThrow
   */
  export type ClassroomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * Filter, which Classroom to fetch.
     */
    where: ClassroomWhereUniqueInput
  }

  /**
   * Classroom findFirst
   */
  export type ClassroomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * Filter, which Classroom to fetch.
     */
    where?: ClassroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classrooms to fetch.
     */
    orderBy?: ClassroomOrderByWithRelationInput | ClassroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classrooms.
     */
    cursor?: ClassroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classrooms.
     */
    distinct?: ClassroomScalarFieldEnum | ClassroomScalarFieldEnum[]
  }

  /**
   * Classroom findFirstOrThrow
   */
  export type ClassroomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * Filter, which Classroom to fetch.
     */
    where?: ClassroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classrooms to fetch.
     */
    orderBy?: ClassroomOrderByWithRelationInput | ClassroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classrooms.
     */
    cursor?: ClassroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classrooms.
     */
    distinct?: ClassroomScalarFieldEnum | ClassroomScalarFieldEnum[]
  }

  /**
   * Classroom findMany
   */
  export type ClassroomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * Filter, which Classrooms to fetch.
     */
    where?: ClassroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classrooms to fetch.
     */
    orderBy?: ClassroomOrderByWithRelationInput | ClassroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classrooms.
     */
    cursor?: ClassroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classrooms.
     */
    skip?: number
    distinct?: ClassroomScalarFieldEnum | ClassroomScalarFieldEnum[]
  }

  /**
   * Classroom create
   */
  export type ClassroomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * The data needed to create a Classroom.
     */
    data: XOR<ClassroomCreateInput, ClassroomUncheckedCreateInput>
  }

  /**
   * Classroom createMany
   */
  export type ClassroomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classrooms.
     */
    data: ClassroomCreateManyInput | ClassroomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Classroom createManyAndReturn
   */
  export type ClassroomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * The data used to create many Classrooms.
     */
    data: ClassroomCreateManyInput | ClassroomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Classroom update
   */
  export type ClassroomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * The data needed to update a Classroom.
     */
    data: XOR<ClassroomUpdateInput, ClassroomUncheckedUpdateInput>
    /**
     * Choose, which Classroom to update.
     */
    where: ClassroomWhereUniqueInput
  }

  /**
   * Classroom updateMany
   */
  export type ClassroomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classrooms.
     */
    data: XOR<ClassroomUpdateManyMutationInput, ClassroomUncheckedUpdateManyInput>
    /**
     * Filter which Classrooms to update
     */
    where?: ClassroomWhereInput
    /**
     * Limit how many Classrooms to update.
     */
    limit?: number
  }

  /**
   * Classroom updateManyAndReturn
   */
  export type ClassroomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * The data used to update Classrooms.
     */
    data: XOR<ClassroomUpdateManyMutationInput, ClassroomUncheckedUpdateManyInput>
    /**
     * Filter which Classrooms to update
     */
    where?: ClassroomWhereInput
    /**
     * Limit how many Classrooms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Classroom upsert
   */
  export type ClassroomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * The filter to search for the Classroom to update in case it exists.
     */
    where: ClassroomWhereUniqueInput
    /**
     * In case the Classroom found by the `where` argument doesn't exist, create a new Classroom with this data.
     */
    create: XOR<ClassroomCreateInput, ClassroomUncheckedCreateInput>
    /**
     * In case the Classroom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassroomUpdateInput, ClassroomUncheckedUpdateInput>
  }

  /**
   * Classroom delete
   */
  export type ClassroomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * Filter which Classroom to delete.
     */
    where: ClassroomWhereUniqueInput
  }

  /**
   * Classroom deleteMany
   */
  export type ClassroomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classrooms to delete
     */
    where?: ClassroomWhereInput
    /**
     * Limit how many Classrooms to delete.
     */
    limit?: number
  }

  /**
   * Classroom.coverMedia
   */
  export type Classroom$coverMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Classroom.classroomStudents
   */
  export type Classroom$classroomStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomStudent
     */
    select?: ClassroomStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassroomStudent
     */
    omit?: ClassroomStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomStudentInclude<ExtArgs> | null
    where?: ClassroomStudentWhereInput
    orderBy?: ClassroomStudentOrderByWithRelationInput | ClassroomStudentOrderByWithRelationInput[]
    cursor?: ClassroomStudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassroomStudentScalarFieldEnum | ClassroomStudentScalarFieldEnum[]
  }

  /**
   * Classroom.joinRequests
   */
  export type Classroom$joinRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinRequest
     */
    select?: JoinRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinRequest
     */
    omit?: JoinRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinRequestInclude<ExtArgs> | null
    where?: JoinRequestWhereInput
    orderBy?: JoinRequestOrderByWithRelationInput | JoinRequestOrderByWithRelationInput[]
    cursor?: JoinRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JoinRequestScalarFieldEnum | JoinRequestScalarFieldEnum[]
  }

  /**
   * Classroom.lessons
   */
  export type Classroom$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Classroom without action
   */
  export type ClassroomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
  }


  /**
   * Model ClassroomStudent
   */

  export type AggregateClassroomStudent = {
    _count: ClassroomStudentCountAggregateOutputType | null
    _avg: ClassroomStudentAvgAggregateOutputType | null
    _sum: ClassroomStudentSumAggregateOutputType | null
    _min: ClassroomStudentMinAggregateOutputType | null
    _max: ClassroomStudentMaxAggregateOutputType | null
  }

  export type ClassroomStudentAvgAggregateOutputType = {
    classroomId: number | null
    studentId: number | null
    status: number | null
  }

  export type ClassroomStudentSumAggregateOutputType = {
    classroomId: number | null
    studentId: number | null
    status: number | null
  }

  export type ClassroomStudentMinAggregateOutputType = {
    classroomId: number | null
    studentId: number | null
    joinedAt: Date | null
    status: number | null
  }

  export type ClassroomStudentMaxAggregateOutputType = {
    classroomId: number | null
    studentId: number | null
    joinedAt: Date | null
    status: number | null
  }

  export type ClassroomStudentCountAggregateOutputType = {
    classroomId: number
    studentId: number
    joinedAt: number
    status: number
    _all: number
  }


  export type ClassroomStudentAvgAggregateInputType = {
    classroomId?: true
    studentId?: true
    status?: true
  }

  export type ClassroomStudentSumAggregateInputType = {
    classroomId?: true
    studentId?: true
    status?: true
  }

  export type ClassroomStudentMinAggregateInputType = {
    classroomId?: true
    studentId?: true
    joinedAt?: true
    status?: true
  }

  export type ClassroomStudentMaxAggregateInputType = {
    classroomId?: true
    studentId?: true
    joinedAt?: true
    status?: true
  }

  export type ClassroomStudentCountAggregateInputType = {
    classroomId?: true
    studentId?: true
    joinedAt?: true
    status?: true
    _all?: true
  }

  export type ClassroomStudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassroomStudent to aggregate.
     */
    where?: ClassroomStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassroomStudents to fetch.
     */
    orderBy?: ClassroomStudentOrderByWithRelationInput | ClassroomStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassroomStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassroomStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassroomStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassroomStudents
    **/
    _count?: true | ClassroomStudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassroomStudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassroomStudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassroomStudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassroomStudentMaxAggregateInputType
  }

  export type GetClassroomStudentAggregateType<T extends ClassroomStudentAggregateArgs> = {
        [P in keyof T & keyof AggregateClassroomStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassroomStudent[P]>
      : GetScalarType<T[P], AggregateClassroomStudent[P]>
  }




  export type ClassroomStudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomStudentWhereInput
    orderBy?: ClassroomStudentOrderByWithAggregationInput | ClassroomStudentOrderByWithAggregationInput[]
    by: ClassroomStudentScalarFieldEnum[] | ClassroomStudentScalarFieldEnum
    having?: ClassroomStudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassroomStudentCountAggregateInputType | true
    _avg?: ClassroomStudentAvgAggregateInputType
    _sum?: ClassroomStudentSumAggregateInputType
    _min?: ClassroomStudentMinAggregateInputType
    _max?: ClassroomStudentMaxAggregateInputType
  }

  export type ClassroomStudentGroupByOutputType = {
    classroomId: number
    studentId: number
    joinedAt: Date
    status: number
    _count: ClassroomStudentCountAggregateOutputType | null
    _avg: ClassroomStudentAvgAggregateOutputType | null
    _sum: ClassroomStudentSumAggregateOutputType | null
    _min: ClassroomStudentMinAggregateOutputType | null
    _max: ClassroomStudentMaxAggregateOutputType | null
  }

  type GetClassroomStudentGroupByPayload<T extends ClassroomStudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassroomStudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassroomStudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassroomStudentGroupByOutputType[P]>
            : GetScalarType<T[P], ClassroomStudentGroupByOutputType[P]>
        }
      >
    >


  export type ClassroomStudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    classroomId?: boolean
    studentId?: boolean
    joinedAt?: boolean
    status?: boolean
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classroomStudent"]>

  export type ClassroomStudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    classroomId?: boolean
    studentId?: boolean
    joinedAt?: boolean
    status?: boolean
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classroomStudent"]>

  export type ClassroomStudentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    classroomId?: boolean
    studentId?: boolean
    joinedAt?: boolean
    status?: boolean
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classroomStudent"]>

  export type ClassroomStudentSelectScalar = {
    classroomId?: boolean
    studentId?: boolean
    joinedAt?: boolean
    status?: boolean
  }

  export type ClassroomStudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"classroomId" | "studentId" | "joinedAt" | "status", ExtArgs["result"]["classroomStudent"]>
  export type ClassroomStudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClassroomStudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClassroomStudentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClassroomStudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassroomStudent"
    objects: {
      classroom: Prisma.$ClassroomPayload<ExtArgs>
      student: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      classroomId: number
      studentId: number
      joinedAt: Date
      status: number
    }, ExtArgs["result"]["classroomStudent"]>
    composites: {}
  }

  type ClassroomStudentGetPayload<S extends boolean | null | undefined | ClassroomStudentDefaultArgs> = $Result.GetResult<Prisma.$ClassroomStudentPayload, S>

  type ClassroomStudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassroomStudentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassroomStudentCountAggregateInputType | true
    }

  export interface ClassroomStudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassroomStudent'], meta: { name: 'ClassroomStudent' } }
    /**
     * Find zero or one ClassroomStudent that matches the filter.
     * @param {ClassroomStudentFindUniqueArgs} args - Arguments to find a ClassroomStudent
     * @example
     * // Get one ClassroomStudent
     * const classroomStudent = await prisma.classroomStudent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassroomStudentFindUniqueArgs>(args: SelectSubset<T, ClassroomStudentFindUniqueArgs<ExtArgs>>): Prisma__ClassroomStudentClient<$Result.GetResult<Prisma.$ClassroomStudentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClassroomStudent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassroomStudentFindUniqueOrThrowArgs} args - Arguments to find a ClassroomStudent
     * @example
     * // Get one ClassroomStudent
     * const classroomStudent = await prisma.classroomStudent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassroomStudentFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassroomStudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassroomStudentClient<$Result.GetResult<Prisma.$ClassroomStudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassroomStudent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomStudentFindFirstArgs} args - Arguments to find a ClassroomStudent
     * @example
     * // Get one ClassroomStudent
     * const classroomStudent = await prisma.classroomStudent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassroomStudentFindFirstArgs>(args?: SelectSubset<T, ClassroomStudentFindFirstArgs<ExtArgs>>): Prisma__ClassroomStudentClient<$Result.GetResult<Prisma.$ClassroomStudentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassroomStudent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomStudentFindFirstOrThrowArgs} args - Arguments to find a ClassroomStudent
     * @example
     * // Get one ClassroomStudent
     * const classroomStudent = await prisma.classroomStudent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassroomStudentFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassroomStudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassroomStudentClient<$Result.GetResult<Prisma.$ClassroomStudentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClassroomStudents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomStudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassroomStudents
     * const classroomStudents = await prisma.classroomStudent.findMany()
     * 
     * // Get first 10 ClassroomStudents
     * const classroomStudents = await prisma.classroomStudent.findMany({ take: 10 })
     * 
     * // Only select the `classroomId`
     * const classroomStudentWithClassroomIdOnly = await prisma.classroomStudent.findMany({ select: { classroomId: true } })
     * 
     */
    findMany<T extends ClassroomStudentFindManyArgs>(args?: SelectSubset<T, ClassroomStudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomStudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClassroomStudent.
     * @param {ClassroomStudentCreateArgs} args - Arguments to create a ClassroomStudent.
     * @example
     * // Create one ClassroomStudent
     * const ClassroomStudent = await prisma.classroomStudent.create({
     *   data: {
     *     // ... data to create a ClassroomStudent
     *   }
     * })
     * 
     */
    create<T extends ClassroomStudentCreateArgs>(args: SelectSubset<T, ClassroomStudentCreateArgs<ExtArgs>>): Prisma__ClassroomStudentClient<$Result.GetResult<Prisma.$ClassroomStudentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClassroomStudents.
     * @param {ClassroomStudentCreateManyArgs} args - Arguments to create many ClassroomStudents.
     * @example
     * // Create many ClassroomStudents
     * const classroomStudent = await prisma.classroomStudent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassroomStudentCreateManyArgs>(args?: SelectSubset<T, ClassroomStudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClassroomStudents and returns the data saved in the database.
     * @param {ClassroomStudentCreateManyAndReturnArgs} args - Arguments to create many ClassroomStudents.
     * @example
     * // Create many ClassroomStudents
     * const classroomStudent = await prisma.classroomStudent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClassroomStudents and only return the `classroomId`
     * const classroomStudentWithClassroomIdOnly = await prisma.classroomStudent.createManyAndReturn({
     *   select: { classroomId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassroomStudentCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassroomStudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomStudentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClassroomStudent.
     * @param {ClassroomStudentDeleteArgs} args - Arguments to delete one ClassroomStudent.
     * @example
     * // Delete one ClassroomStudent
     * const ClassroomStudent = await prisma.classroomStudent.delete({
     *   where: {
     *     // ... filter to delete one ClassroomStudent
     *   }
     * })
     * 
     */
    delete<T extends ClassroomStudentDeleteArgs>(args: SelectSubset<T, ClassroomStudentDeleteArgs<ExtArgs>>): Prisma__ClassroomStudentClient<$Result.GetResult<Prisma.$ClassroomStudentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClassroomStudent.
     * @param {ClassroomStudentUpdateArgs} args - Arguments to update one ClassroomStudent.
     * @example
     * // Update one ClassroomStudent
     * const classroomStudent = await prisma.classroomStudent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassroomStudentUpdateArgs>(args: SelectSubset<T, ClassroomStudentUpdateArgs<ExtArgs>>): Prisma__ClassroomStudentClient<$Result.GetResult<Prisma.$ClassroomStudentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClassroomStudents.
     * @param {ClassroomStudentDeleteManyArgs} args - Arguments to filter ClassroomStudents to delete.
     * @example
     * // Delete a few ClassroomStudents
     * const { count } = await prisma.classroomStudent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassroomStudentDeleteManyArgs>(args?: SelectSubset<T, ClassroomStudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassroomStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomStudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassroomStudents
     * const classroomStudent = await prisma.classroomStudent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassroomStudentUpdateManyArgs>(args: SelectSubset<T, ClassroomStudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassroomStudents and returns the data updated in the database.
     * @param {ClassroomStudentUpdateManyAndReturnArgs} args - Arguments to update many ClassroomStudents.
     * @example
     * // Update many ClassroomStudents
     * const classroomStudent = await prisma.classroomStudent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClassroomStudents and only return the `classroomId`
     * const classroomStudentWithClassroomIdOnly = await prisma.classroomStudent.updateManyAndReturn({
     *   select: { classroomId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassroomStudentUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassroomStudentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomStudentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClassroomStudent.
     * @param {ClassroomStudentUpsertArgs} args - Arguments to update or create a ClassroomStudent.
     * @example
     * // Update or create a ClassroomStudent
     * const classroomStudent = await prisma.classroomStudent.upsert({
     *   create: {
     *     // ... data to create a ClassroomStudent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassroomStudent we want to update
     *   }
     * })
     */
    upsert<T extends ClassroomStudentUpsertArgs>(args: SelectSubset<T, ClassroomStudentUpsertArgs<ExtArgs>>): Prisma__ClassroomStudentClient<$Result.GetResult<Prisma.$ClassroomStudentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClassroomStudents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomStudentCountArgs} args - Arguments to filter ClassroomStudents to count.
     * @example
     * // Count the number of ClassroomStudents
     * const count = await prisma.classroomStudent.count({
     *   where: {
     *     // ... the filter for the ClassroomStudents we want to count
     *   }
     * })
    **/
    count<T extends ClassroomStudentCountArgs>(
      args?: Subset<T, ClassroomStudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassroomStudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassroomStudent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomStudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassroomStudentAggregateArgs>(args: Subset<T, ClassroomStudentAggregateArgs>): Prisma.PrismaPromise<GetClassroomStudentAggregateType<T>>

    /**
     * Group by ClassroomStudent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomStudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassroomStudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassroomStudentGroupByArgs['orderBy'] }
        : { orderBy?: ClassroomStudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassroomStudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassroomStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassroomStudent model
   */
  readonly fields: ClassroomStudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassroomStudent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassroomStudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classroom<T extends ClassroomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassroomDefaultArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassroomStudent model
   */
  interface ClassroomStudentFieldRefs {
    readonly classroomId: FieldRef<"ClassroomStudent", 'Int'>
    readonly studentId: FieldRef<"ClassroomStudent", 'Int'>
    readonly joinedAt: FieldRef<"ClassroomStudent", 'DateTime'>
    readonly status: FieldRef<"ClassroomStudent", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ClassroomStudent findUnique
   */
  export type ClassroomStudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomStudent
     */
    select?: ClassroomStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassroomStudent
     */
    omit?: ClassroomStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomStudentInclude<ExtArgs> | null
    /**
     * Filter, which ClassroomStudent to fetch.
     */
    where: ClassroomStudentWhereUniqueInput
  }

  /**
   * ClassroomStudent findUniqueOrThrow
   */
  export type ClassroomStudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomStudent
     */
    select?: ClassroomStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassroomStudent
     */
    omit?: ClassroomStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomStudentInclude<ExtArgs> | null
    /**
     * Filter, which ClassroomStudent to fetch.
     */
    where: ClassroomStudentWhereUniqueInput
  }

  /**
   * ClassroomStudent findFirst
   */
  export type ClassroomStudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomStudent
     */
    select?: ClassroomStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassroomStudent
     */
    omit?: ClassroomStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomStudentInclude<ExtArgs> | null
    /**
     * Filter, which ClassroomStudent to fetch.
     */
    where?: ClassroomStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassroomStudents to fetch.
     */
    orderBy?: ClassroomStudentOrderByWithRelationInput | ClassroomStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassroomStudents.
     */
    cursor?: ClassroomStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassroomStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassroomStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassroomStudents.
     */
    distinct?: ClassroomStudentScalarFieldEnum | ClassroomStudentScalarFieldEnum[]
  }

  /**
   * ClassroomStudent findFirstOrThrow
   */
  export type ClassroomStudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomStudent
     */
    select?: ClassroomStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassroomStudent
     */
    omit?: ClassroomStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomStudentInclude<ExtArgs> | null
    /**
     * Filter, which ClassroomStudent to fetch.
     */
    where?: ClassroomStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassroomStudents to fetch.
     */
    orderBy?: ClassroomStudentOrderByWithRelationInput | ClassroomStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassroomStudents.
     */
    cursor?: ClassroomStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassroomStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassroomStudents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassroomStudents.
     */
    distinct?: ClassroomStudentScalarFieldEnum | ClassroomStudentScalarFieldEnum[]
  }

  /**
   * ClassroomStudent findMany
   */
  export type ClassroomStudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomStudent
     */
    select?: ClassroomStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassroomStudent
     */
    omit?: ClassroomStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomStudentInclude<ExtArgs> | null
    /**
     * Filter, which ClassroomStudents to fetch.
     */
    where?: ClassroomStudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassroomStudents to fetch.
     */
    orderBy?: ClassroomStudentOrderByWithRelationInput | ClassroomStudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassroomStudents.
     */
    cursor?: ClassroomStudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassroomStudents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassroomStudents.
     */
    skip?: number
    distinct?: ClassroomStudentScalarFieldEnum | ClassroomStudentScalarFieldEnum[]
  }

  /**
   * ClassroomStudent create
   */
  export type ClassroomStudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomStudent
     */
    select?: ClassroomStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassroomStudent
     */
    omit?: ClassroomStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomStudentInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassroomStudent.
     */
    data: XOR<ClassroomStudentCreateInput, ClassroomStudentUncheckedCreateInput>
  }

  /**
   * ClassroomStudent createMany
   */
  export type ClassroomStudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassroomStudents.
     */
    data: ClassroomStudentCreateManyInput | ClassroomStudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassroomStudent createManyAndReturn
   */
  export type ClassroomStudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomStudent
     */
    select?: ClassroomStudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassroomStudent
     */
    omit?: ClassroomStudentOmit<ExtArgs> | null
    /**
     * The data used to create many ClassroomStudents.
     */
    data: ClassroomStudentCreateManyInput | ClassroomStudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomStudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassroomStudent update
   */
  export type ClassroomStudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomStudent
     */
    select?: ClassroomStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassroomStudent
     */
    omit?: ClassroomStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomStudentInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassroomStudent.
     */
    data: XOR<ClassroomStudentUpdateInput, ClassroomStudentUncheckedUpdateInput>
    /**
     * Choose, which ClassroomStudent to update.
     */
    where: ClassroomStudentWhereUniqueInput
  }

  /**
   * ClassroomStudent updateMany
   */
  export type ClassroomStudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassroomStudents.
     */
    data: XOR<ClassroomStudentUpdateManyMutationInput, ClassroomStudentUncheckedUpdateManyInput>
    /**
     * Filter which ClassroomStudents to update
     */
    where?: ClassroomStudentWhereInput
    /**
     * Limit how many ClassroomStudents to update.
     */
    limit?: number
  }

  /**
   * ClassroomStudent updateManyAndReturn
   */
  export type ClassroomStudentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomStudent
     */
    select?: ClassroomStudentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassroomStudent
     */
    omit?: ClassroomStudentOmit<ExtArgs> | null
    /**
     * The data used to update ClassroomStudents.
     */
    data: XOR<ClassroomStudentUpdateManyMutationInput, ClassroomStudentUncheckedUpdateManyInput>
    /**
     * Filter which ClassroomStudents to update
     */
    where?: ClassroomStudentWhereInput
    /**
     * Limit how many ClassroomStudents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomStudentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassroomStudent upsert
   */
  export type ClassroomStudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomStudent
     */
    select?: ClassroomStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassroomStudent
     */
    omit?: ClassroomStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomStudentInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassroomStudent to update in case it exists.
     */
    where: ClassroomStudentWhereUniqueInput
    /**
     * In case the ClassroomStudent found by the `where` argument doesn't exist, create a new ClassroomStudent with this data.
     */
    create: XOR<ClassroomStudentCreateInput, ClassroomStudentUncheckedCreateInput>
    /**
     * In case the ClassroomStudent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassroomStudentUpdateInput, ClassroomStudentUncheckedUpdateInput>
  }

  /**
   * ClassroomStudent delete
   */
  export type ClassroomStudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomStudent
     */
    select?: ClassroomStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassroomStudent
     */
    omit?: ClassroomStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomStudentInclude<ExtArgs> | null
    /**
     * Filter which ClassroomStudent to delete.
     */
    where: ClassroomStudentWhereUniqueInput
  }

  /**
   * ClassroomStudent deleteMany
   */
  export type ClassroomStudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassroomStudents to delete
     */
    where?: ClassroomStudentWhereInput
    /**
     * Limit how many ClassroomStudents to delete.
     */
    limit?: number
  }

  /**
   * ClassroomStudent without action
   */
  export type ClassroomStudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomStudent
     */
    select?: ClassroomStudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassroomStudent
     */
    omit?: ClassroomStudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomStudentInclude<ExtArgs> | null
  }


  /**
   * Model JoinRequest
   */

  export type AggregateJoinRequest = {
    _count: JoinRequestCountAggregateOutputType | null
    _avg: JoinRequestAvgAggregateOutputType | null
    _sum: JoinRequestSumAggregateOutputType | null
    _min: JoinRequestMinAggregateOutputType | null
    _max: JoinRequestMaxAggregateOutputType | null
  }

  export type JoinRequestAvgAggregateOutputType = {
    id: number | null
    classroomId: number | null
    studentId: number | null
  }

  export type JoinRequestSumAggregateOutputType = {
    id: number | null
    classroomId: number | null
    studentId: number | null
  }

  export type JoinRequestMinAggregateOutputType = {
    id: number | null
    classroomId: number | null
    studentId: number | null
    status: string | null
    requestedAt: Date | null
    handledAt: Date | null
  }

  export type JoinRequestMaxAggregateOutputType = {
    id: number | null
    classroomId: number | null
    studentId: number | null
    status: string | null
    requestedAt: Date | null
    handledAt: Date | null
  }

  export type JoinRequestCountAggregateOutputType = {
    id: number
    classroomId: number
    studentId: number
    status: number
    requestedAt: number
    handledAt: number
    _all: number
  }


  export type JoinRequestAvgAggregateInputType = {
    id?: true
    classroomId?: true
    studentId?: true
  }

  export type JoinRequestSumAggregateInputType = {
    id?: true
    classroomId?: true
    studentId?: true
  }

  export type JoinRequestMinAggregateInputType = {
    id?: true
    classroomId?: true
    studentId?: true
    status?: true
    requestedAt?: true
    handledAt?: true
  }

  export type JoinRequestMaxAggregateInputType = {
    id?: true
    classroomId?: true
    studentId?: true
    status?: true
    requestedAt?: true
    handledAt?: true
  }

  export type JoinRequestCountAggregateInputType = {
    id?: true
    classroomId?: true
    studentId?: true
    status?: true
    requestedAt?: true
    handledAt?: true
    _all?: true
  }

  export type JoinRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JoinRequest to aggregate.
     */
    where?: JoinRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinRequests to fetch.
     */
    orderBy?: JoinRequestOrderByWithRelationInput | JoinRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JoinRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JoinRequests
    **/
    _count?: true | JoinRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JoinRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JoinRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JoinRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JoinRequestMaxAggregateInputType
  }

  export type GetJoinRequestAggregateType<T extends JoinRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateJoinRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJoinRequest[P]>
      : GetScalarType<T[P], AggregateJoinRequest[P]>
  }




  export type JoinRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JoinRequestWhereInput
    orderBy?: JoinRequestOrderByWithAggregationInput | JoinRequestOrderByWithAggregationInput[]
    by: JoinRequestScalarFieldEnum[] | JoinRequestScalarFieldEnum
    having?: JoinRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JoinRequestCountAggregateInputType | true
    _avg?: JoinRequestAvgAggregateInputType
    _sum?: JoinRequestSumAggregateInputType
    _min?: JoinRequestMinAggregateInputType
    _max?: JoinRequestMaxAggregateInputType
  }

  export type JoinRequestGroupByOutputType = {
    id: number
    classroomId: number
    studentId: number
    status: string
    requestedAt: Date
    handledAt: Date | null
    _count: JoinRequestCountAggregateOutputType | null
    _avg: JoinRequestAvgAggregateOutputType | null
    _sum: JoinRequestSumAggregateOutputType | null
    _min: JoinRequestMinAggregateOutputType | null
    _max: JoinRequestMaxAggregateOutputType | null
  }

  type GetJoinRequestGroupByPayload<T extends JoinRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JoinRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JoinRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JoinRequestGroupByOutputType[P]>
            : GetScalarType<T[P], JoinRequestGroupByOutputType[P]>
        }
      >
    >


  export type JoinRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classroomId?: boolean
    studentId?: boolean
    status?: boolean
    requestedAt?: boolean
    handledAt?: boolean
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["joinRequest"]>

  export type JoinRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classroomId?: boolean
    studentId?: boolean
    status?: boolean
    requestedAt?: boolean
    handledAt?: boolean
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["joinRequest"]>

  export type JoinRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classroomId?: boolean
    studentId?: boolean
    status?: boolean
    requestedAt?: boolean
    handledAt?: boolean
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["joinRequest"]>

  export type JoinRequestSelectScalar = {
    id?: boolean
    classroomId?: boolean
    studentId?: boolean
    status?: boolean
    requestedAt?: boolean
    handledAt?: boolean
  }

  export type JoinRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "classroomId" | "studentId" | "status" | "requestedAt" | "handledAt", ExtArgs["result"]["joinRequest"]>
  export type JoinRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type JoinRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type JoinRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $JoinRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JoinRequest"
    objects: {
      classroom: Prisma.$ClassroomPayload<ExtArgs>
      student: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      classroomId: number
      studentId: number
      status: string
      requestedAt: Date
      handledAt: Date | null
    }, ExtArgs["result"]["joinRequest"]>
    composites: {}
  }

  type JoinRequestGetPayload<S extends boolean | null | undefined | JoinRequestDefaultArgs> = $Result.GetResult<Prisma.$JoinRequestPayload, S>

  type JoinRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JoinRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JoinRequestCountAggregateInputType | true
    }

  export interface JoinRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JoinRequest'], meta: { name: 'JoinRequest' } }
    /**
     * Find zero or one JoinRequest that matches the filter.
     * @param {JoinRequestFindUniqueArgs} args - Arguments to find a JoinRequest
     * @example
     * // Get one JoinRequest
     * const joinRequest = await prisma.joinRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JoinRequestFindUniqueArgs>(args: SelectSubset<T, JoinRequestFindUniqueArgs<ExtArgs>>): Prisma__JoinRequestClient<$Result.GetResult<Prisma.$JoinRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JoinRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JoinRequestFindUniqueOrThrowArgs} args - Arguments to find a JoinRequest
     * @example
     * // Get one JoinRequest
     * const joinRequest = await prisma.joinRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JoinRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, JoinRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JoinRequestClient<$Result.GetResult<Prisma.$JoinRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JoinRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinRequestFindFirstArgs} args - Arguments to find a JoinRequest
     * @example
     * // Get one JoinRequest
     * const joinRequest = await prisma.joinRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JoinRequestFindFirstArgs>(args?: SelectSubset<T, JoinRequestFindFirstArgs<ExtArgs>>): Prisma__JoinRequestClient<$Result.GetResult<Prisma.$JoinRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JoinRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinRequestFindFirstOrThrowArgs} args - Arguments to find a JoinRequest
     * @example
     * // Get one JoinRequest
     * const joinRequest = await prisma.joinRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JoinRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, JoinRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__JoinRequestClient<$Result.GetResult<Prisma.$JoinRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JoinRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JoinRequests
     * const joinRequests = await prisma.joinRequest.findMany()
     * 
     * // Get first 10 JoinRequests
     * const joinRequests = await prisma.joinRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const joinRequestWithIdOnly = await prisma.joinRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JoinRequestFindManyArgs>(args?: SelectSubset<T, JoinRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JoinRequest.
     * @param {JoinRequestCreateArgs} args - Arguments to create a JoinRequest.
     * @example
     * // Create one JoinRequest
     * const JoinRequest = await prisma.joinRequest.create({
     *   data: {
     *     // ... data to create a JoinRequest
     *   }
     * })
     * 
     */
    create<T extends JoinRequestCreateArgs>(args: SelectSubset<T, JoinRequestCreateArgs<ExtArgs>>): Prisma__JoinRequestClient<$Result.GetResult<Prisma.$JoinRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JoinRequests.
     * @param {JoinRequestCreateManyArgs} args - Arguments to create many JoinRequests.
     * @example
     * // Create many JoinRequests
     * const joinRequest = await prisma.joinRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JoinRequestCreateManyArgs>(args?: SelectSubset<T, JoinRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JoinRequests and returns the data saved in the database.
     * @param {JoinRequestCreateManyAndReturnArgs} args - Arguments to create many JoinRequests.
     * @example
     * // Create many JoinRequests
     * const joinRequest = await prisma.joinRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JoinRequests and only return the `id`
     * const joinRequestWithIdOnly = await prisma.joinRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JoinRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, JoinRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JoinRequest.
     * @param {JoinRequestDeleteArgs} args - Arguments to delete one JoinRequest.
     * @example
     * // Delete one JoinRequest
     * const JoinRequest = await prisma.joinRequest.delete({
     *   where: {
     *     // ... filter to delete one JoinRequest
     *   }
     * })
     * 
     */
    delete<T extends JoinRequestDeleteArgs>(args: SelectSubset<T, JoinRequestDeleteArgs<ExtArgs>>): Prisma__JoinRequestClient<$Result.GetResult<Prisma.$JoinRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JoinRequest.
     * @param {JoinRequestUpdateArgs} args - Arguments to update one JoinRequest.
     * @example
     * // Update one JoinRequest
     * const joinRequest = await prisma.joinRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JoinRequestUpdateArgs>(args: SelectSubset<T, JoinRequestUpdateArgs<ExtArgs>>): Prisma__JoinRequestClient<$Result.GetResult<Prisma.$JoinRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JoinRequests.
     * @param {JoinRequestDeleteManyArgs} args - Arguments to filter JoinRequests to delete.
     * @example
     * // Delete a few JoinRequests
     * const { count } = await prisma.joinRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JoinRequestDeleteManyArgs>(args?: SelectSubset<T, JoinRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JoinRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JoinRequests
     * const joinRequest = await prisma.joinRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JoinRequestUpdateManyArgs>(args: SelectSubset<T, JoinRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JoinRequests and returns the data updated in the database.
     * @param {JoinRequestUpdateManyAndReturnArgs} args - Arguments to update many JoinRequests.
     * @example
     * // Update many JoinRequests
     * const joinRequest = await prisma.joinRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JoinRequests and only return the `id`
     * const joinRequestWithIdOnly = await prisma.joinRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JoinRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, JoinRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JoinRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JoinRequest.
     * @param {JoinRequestUpsertArgs} args - Arguments to update or create a JoinRequest.
     * @example
     * // Update or create a JoinRequest
     * const joinRequest = await prisma.joinRequest.upsert({
     *   create: {
     *     // ... data to create a JoinRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JoinRequest we want to update
     *   }
     * })
     */
    upsert<T extends JoinRequestUpsertArgs>(args: SelectSubset<T, JoinRequestUpsertArgs<ExtArgs>>): Prisma__JoinRequestClient<$Result.GetResult<Prisma.$JoinRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JoinRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinRequestCountArgs} args - Arguments to filter JoinRequests to count.
     * @example
     * // Count the number of JoinRequests
     * const count = await prisma.joinRequest.count({
     *   where: {
     *     // ... the filter for the JoinRequests we want to count
     *   }
     * })
    **/
    count<T extends JoinRequestCountArgs>(
      args?: Subset<T, JoinRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JoinRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JoinRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JoinRequestAggregateArgs>(args: Subset<T, JoinRequestAggregateArgs>): Prisma.PrismaPromise<GetJoinRequestAggregateType<T>>

    /**
     * Group by JoinRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JoinRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JoinRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JoinRequestGroupByArgs['orderBy'] }
        : { orderBy?: JoinRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JoinRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJoinRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JoinRequest model
   */
  readonly fields: JoinRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JoinRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JoinRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classroom<T extends ClassroomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassroomDefaultArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JoinRequest model
   */
  interface JoinRequestFieldRefs {
    readonly id: FieldRef<"JoinRequest", 'Int'>
    readonly classroomId: FieldRef<"JoinRequest", 'Int'>
    readonly studentId: FieldRef<"JoinRequest", 'Int'>
    readonly status: FieldRef<"JoinRequest", 'String'>
    readonly requestedAt: FieldRef<"JoinRequest", 'DateTime'>
    readonly handledAt: FieldRef<"JoinRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JoinRequest findUnique
   */
  export type JoinRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinRequest
     */
    select?: JoinRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinRequest
     */
    omit?: JoinRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinRequestInclude<ExtArgs> | null
    /**
     * Filter, which JoinRequest to fetch.
     */
    where: JoinRequestWhereUniqueInput
  }

  /**
   * JoinRequest findUniqueOrThrow
   */
  export type JoinRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinRequest
     */
    select?: JoinRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinRequest
     */
    omit?: JoinRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinRequestInclude<ExtArgs> | null
    /**
     * Filter, which JoinRequest to fetch.
     */
    where: JoinRequestWhereUniqueInput
  }

  /**
   * JoinRequest findFirst
   */
  export type JoinRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinRequest
     */
    select?: JoinRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinRequest
     */
    omit?: JoinRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinRequestInclude<ExtArgs> | null
    /**
     * Filter, which JoinRequest to fetch.
     */
    where?: JoinRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinRequests to fetch.
     */
    orderBy?: JoinRequestOrderByWithRelationInput | JoinRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JoinRequests.
     */
    cursor?: JoinRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JoinRequests.
     */
    distinct?: JoinRequestScalarFieldEnum | JoinRequestScalarFieldEnum[]
  }

  /**
   * JoinRequest findFirstOrThrow
   */
  export type JoinRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinRequest
     */
    select?: JoinRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinRequest
     */
    omit?: JoinRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinRequestInclude<ExtArgs> | null
    /**
     * Filter, which JoinRequest to fetch.
     */
    where?: JoinRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinRequests to fetch.
     */
    orderBy?: JoinRequestOrderByWithRelationInput | JoinRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JoinRequests.
     */
    cursor?: JoinRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JoinRequests.
     */
    distinct?: JoinRequestScalarFieldEnum | JoinRequestScalarFieldEnum[]
  }

  /**
   * JoinRequest findMany
   */
  export type JoinRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinRequest
     */
    select?: JoinRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinRequest
     */
    omit?: JoinRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinRequestInclude<ExtArgs> | null
    /**
     * Filter, which JoinRequests to fetch.
     */
    where?: JoinRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JoinRequests to fetch.
     */
    orderBy?: JoinRequestOrderByWithRelationInput | JoinRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JoinRequests.
     */
    cursor?: JoinRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JoinRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JoinRequests.
     */
    skip?: number
    distinct?: JoinRequestScalarFieldEnum | JoinRequestScalarFieldEnum[]
  }

  /**
   * JoinRequest create
   */
  export type JoinRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinRequest
     */
    select?: JoinRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinRequest
     */
    omit?: JoinRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a JoinRequest.
     */
    data: XOR<JoinRequestCreateInput, JoinRequestUncheckedCreateInput>
  }

  /**
   * JoinRequest createMany
   */
  export type JoinRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JoinRequests.
     */
    data: JoinRequestCreateManyInput | JoinRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JoinRequest createManyAndReturn
   */
  export type JoinRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinRequest
     */
    select?: JoinRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JoinRequest
     */
    omit?: JoinRequestOmit<ExtArgs> | null
    /**
     * The data used to create many JoinRequests.
     */
    data: JoinRequestCreateManyInput | JoinRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JoinRequest update
   */
  export type JoinRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinRequest
     */
    select?: JoinRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinRequest
     */
    omit?: JoinRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a JoinRequest.
     */
    data: XOR<JoinRequestUpdateInput, JoinRequestUncheckedUpdateInput>
    /**
     * Choose, which JoinRequest to update.
     */
    where: JoinRequestWhereUniqueInput
  }

  /**
   * JoinRequest updateMany
   */
  export type JoinRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JoinRequests.
     */
    data: XOR<JoinRequestUpdateManyMutationInput, JoinRequestUncheckedUpdateManyInput>
    /**
     * Filter which JoinRequests to update
     */
    where?: JoinRequestWhereInput
    /**
     * Limit how many JoinRequests to update.
     */
    limit?: number
  }

  /**
   * JoinRequest updateManyAndReturn
   */
  export type JoinRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinRequest
     */
    select?: JoinRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JoinRequest
     */
    omit?: JoinRequestOmit<ExtArgs> | null
    /**
     * The data used to update JoinRequests.
     */
    data: XOR<JoinRequestUpdateManyMutationInput, JoinRequestUncheckedUpdateManyInput>
    /**
     * Filter which JoinRequests to update
     */
    where?: JoinRequestWhereInput
    /**
     * Limit how many JoinRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JoinRequest upsert
   */
  export type JoinRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinRequest
     */
    select?: JoinRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinRequest
     */
    omit?: JoinRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the JoinRequest to update in case it exists.
     */
    where: JoinRequestWhereUniqueInput
    /**
     * In case the JoinRequest found by the `where` argument doesn't exist, create a new JoinRequest with this data.
     */
    create: XOR<JoinRequestCreateInput, JoinRequestUncheckedCreateInput>
    /**
     * In case the JoinRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JoinRequestUpdateInput, JoinRequestUncheckedUpdateInput>
  }

  /**
   * JoinRequest delete
   */
  export type JoinRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinRequest
     */
    select?: JoinRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinRequest
     */
    omit?: JoinRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinRequestInclude<ExtArgs> | null
    /**
     * Filter which JoinRequest to delete.
     */
    where: JoinRequestWhereUniqueInput
  }

  /**
   * JoinRequest deleteMany
   */
  export type JoinRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JoinRequests to delete
     */
    where?: JoinRequestWhereInput
    /**
     * Limit how many JoinRequests to delete.
     */
    limit?: number
  }

  /**
   * JoinRequest without action
   */
  export type JoinRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JoinRequest
     */
    select?: JoinRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JoinRequest
     */
    omit?: JoinRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JoinRequestInclude<ExtArgs> | null
  }


  /**
   * Model Lesson
   */

  export type AggregateLesson = {
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  export type LessonAvgAggregateOutputType = {
    id: number | null
    classroomId: number | null
    parentId: number | null
    orderIndex: number | null
  }

  export type LessonSumAggregateOutputType = {
    id: number | null
    classroomId: number | null
    parentId: number | null
    orderIndex: number | null
  }

  export type LessonMinAggregateOutputType = {
    id: number | null
    classroomId: number | null
    parentId: number | null
    title: string | null
    content: string | null
    lessonType: $Enums.LessonType | null
    orderIndex: number | null
    publishedAt: Date | null
  }

  export type LessonMaxAggregateOutputType = {
    id: number | null
    classroomId: number | null
    parentId: number | null
    title: string | null
    content: string | null
    lessonType: $Enums.LessonType | null
    orderIndex: number | null
    publishedAt: Date | null
  }

  export type LessonCountAggregateOutputType = {
    id: number
    classroomId: number
    parentId: number
    title: number
    content: number
    lessonType: number
    orderIndex: number
    publishedAt: number
    _all: number
  }


  export type LessonAvgAggregateInputType = {
    id?: true
    classroomId?: true
    parentId?: true
    orderIndex?: true
  }

  export type LessonSumAggregateInputType = {
    id?: true
    classroomId?: true
    parentId?: true
    orderIndex?: true
  }

  export type LessonMinAggregateInputType = {
    id?: true
    classroomId?: true
    parentId?: true
    title?: true
    content?: true
    lessonType?: true
    orderIndex?: true
    publishedAt?: true
  }

  export type LessonMaxAggregateInputType = {
    id?: true
    classroomId?: true
    parentId?: true
    title?: true
    content?: true
    lessonType?: true
    orderIndex?: true
    publishedAt?: true
  }

  export type LessonCountAggregateInputType = {
    id?: true
    classroomId?: true
    parentId?: true
    title?: true
    content?: true
    lessonType?: true
    orderIndex?: true
    publishedAt?: true
    _all?: true
  }

  export type LessonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lesson to aggregate.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lessons
    **/
    _count?: true | LessonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonMaxAggregateInputType
  }

  export type GetLessonAggregateType<T extends LessonAggregateArgs> = {
        [P in keyof T & keyof AggregateLesson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLesson[P]>
      : GetScalarType<T[P], AggregateLesson[P]>
  }




  export type LessonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithAggregationInput | LessonOrderByWithAggregationInput[]
    by: LessonScalarFieldEnum[] | LessonScalarFieldEnum
    having?: LessonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonCountAggregateInputType | true
    _avg?: LessonAvgAggregateInputType
    _sum?: LessonSumAggregateInputType
    _min?: LessonMinAggregateInputType
    _max?: LessonMaxAggregateInputType
  }

  export type LessonGroupByOutputType = {
    id: number
    classroomId: number
    parentId: number | null
    title: string
    content: string | null
    lessonType: $Enums.LessonType
    orderIndex: number
    publishedAt: Date | null
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  type GetLessonGroupByPayload<T extends LessonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonGroupByOutputType[P]>
            : GetScalarType<T[P], LessonGroupByOutputType[P]>
        }
      >
    >


  export type LessonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classroomId?: boolean
    parentId?: boolean
    title?: boolean
    content?: boolean
    lessonType?: boolean
    orderIndex?: boolean
    publishedAt?: boolean
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    materials?: boolean | Lesson$materialsArgs<ExtArgs>
    exercises?: boolean | Lesson$exercisesArgs<ExtArgs>
    quizzes?: boolean | Lesson$quizzesArgs<ExtArgs>
    parent?: boolean | Lesson$parentArgs<ExtArgs>
    subLessons?: boolean | Lesson$subLessonsArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classroomId?: boolean
    parentId?: boolean
    title?: boolean
    content?: boolean
    lessonType?: boolean
    orderIndex?: boolean
    publishedAt?: boolean
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    parent?: boolean | Lesson$parentArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classroomId?: boolean
    parentId?: boolean
    title?: boolean
    content?: boolean
    lessonType?: boolean
    orderIndex?: boolean
    publishedAt?: boolean
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    parent?: boolean | Lesson$parentArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectScalar = {
    id?: boolean
    classroomId?: boolean
    parentId?: boolean
    title?: boolean
    content?: boolean
    lessonType?: boolean
    orderIndex?: boolean
    publishedAt?: boolean
  }

  export type LessonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "classroomId" | "parentId" | "title" | "content" | "lessonType" | "orderIndex" | "publishedAt", ExtArgs["result"]["lesson"]>
  export type LessonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    materials?: boolean | Lesson$materialsArgs<ExtArgs>
    exercises?: boolean | Lesson$exercisesArgs<ExtArgs>
    quizzes?: boolean | Lesson$quizzesArgs<ExtArgs>
    parent?: boolean | Lesson$parentArgs<ExtArgs>
    subLessons?: boolean | Lesson$subLessonsArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LessonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    parent?: boolean | Lesson$parentArgs<ExtArgs>
  }
  export type LessonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classroom?: boolean | ClassroomDefaultArgs<ExtArgs>
    parent?: boolean | Lesson$parentArgs<ExtArgs>
  }

  export type $LessonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lesson"
    objects: {
      classroom: Prisma.$ClassroomPayload<ExtArgs>
      materials: Prisma.$MaterialPayload<ExtArgs>[]
      exercises: Prisma.$ExercisePayload<ExtArgs>[]
      quizzes: Prisma.$QuizPayload<ExtArgs>[]
      parent: Prisma.$LessonPayload<ExtArgs> | null
      subLessons: Prisma.$LessonPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      classroomId: number
      parentId: number | null
      title: string
      content: string | null
      lessonType: $Enums.LessonType
      orderIndex: number
      publishedAt: Date | null
    }, ExtArgs["result"]["lesson"]>
    composites: {}
  }

  type LessonGetPayload<S extends boolean | null | undefined | LessonDefaultArgs> = $Result.GetResult<Prisma.$LessonPayload, S>

  type LessonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonCountAggregateInputType | true
    }

  export interface LessonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lesson'], meta: { name: 'Lesson' } }
    /**
     * Find zero or one Lesson that matches the filter.
     * @param {LessonFindUniqueArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonFindUniqueArgs>(args: SelectSubset<T, LessonFindUniqueArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lesson that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonFindUniqueOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lesson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonFindFirstArgs>(args?: SelectSubset<T, LessonFindFirstArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lesson that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lessons
     * const lessons = await prisma.lesson.findMany()
     * 
     * // Get first 10 Lessons
     * const lessons = await prisma.lesson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonWithIdOnly = await prisma.lesson.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonFindManyArgs>(args?: SelectSubset<T, LessonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lesson.
     * @param {LessonCreateArgs} args - Arguments to create a Lesson.
     * @example
     * // Create one Lesson
     * const Lesson = await prisma.lesson.create({
     *   data: {
     *     // ... data to create a Lesson
     *   }
     * })
     * 
     */
    create<T extends LessonCreateArgs>(args: SelectSubset<T, LessonCreateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lessons.
     * @param {LessonCreateManyArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonCreateManyArgs>(args?: SelectSubset<T, LessonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lessons and returns the data saved in the database.
     * @param {LessonCreateManyAndReturnArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lessons and only return the `id`
     * const lessonWithIdOnly = await prisma.lesson.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lesson.
     * @param {LessonDeleteArgs} args - Arguments to delete one Lesson.
     * @example
     * // Delete one Lesson
     * const Lesson = await prisma.lesson.delete({
     *   where: {
     *     // ... filter to delete one Lesson
     *   }
     * })
     * 
     */
    delete<T extends LessonDeleteArgs>(args: SelectSubset<T, LessonDeleteArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lesson.
     * @param {LessonUpdateArgs} args - Arguments to update one Lesson.
     * @example
     * // Update one Lesson
     * const lesson = await prisma.lesson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonUpdateArgs>(args: SelectSubset<T, LessonUpdateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lessons.
     * @param {LessonDeleteManyArgs} args - Arguments to filter Lessons to delete.
     * @example
     * // Delete a few Lessons
     * const { count } = await prisma.lesson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonDeleteManyArgs>(args?: SelectSubset<T, LessonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonUpdateManyArgs>(args: SelectSubset<T, LessonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons and returns the data updated in the database.
     * @param {LessonUpdateManyAndReturnArgs} args - Arguments to update many Lessons.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lessons and only return the `id`
     * const lessonWithIdOnly = await prisma.lesson.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lesson.
     * @param {LessonUpsertArgs} args - Arguments to update or create a Lesson.
     * @example
     * // Update or create a Lesson
     * const lesson = await prisma.lesson.upsert({
     *   create: {
     *     // ... data to create a Lesson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lesson we want to update
     *   }
     * })
     */
    upsert<T extends LessonUpsertArgs>(args: SelectSubset<T, LessonUpsertArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCountArgs} args - Arguments to filter Lessons to count.
     * @example
     * // Count the number of Lessons
     * const count = await prisma.lesson.count({
     *   where: {
     *     // ... the filter for the Lessons we want to count
     *   }
     * })
    **/
    count<T extends LessonCountArgs>(
      args?: Subset<T, LessonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonAggregateArgs>(args: Subset<T, LessonAggregateArgs>): Prisma.PrismaPromise<GetLessonAggregateType<T>>

    /**
     * Group by Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonGroupByArgs['orderBy'] }
        : { orderBy?: LessonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lesson model
   */
  readonly fields: LessonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lesson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classroom<T extends ClassroomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassroomDefaultArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    materials<T extends Lesson$materialsArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$materialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exercises<T extends Lesson$exercisesArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$exercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quizzes<T extends Lesson$quizzesArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$quizzesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parent<T extends Lesson$parentArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$parentArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subLessons<T extends Lesson$subLessonsArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$subLessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lesson model
   */
  interface LessonFieldRefs {
    readonly id: FieldRef<"Lesson", 'Int'>
    readonly classroomId: FieldRef<"Lesson", 'Int'>
    readonly parentId: FieldRef<"Lesson", 'Int'>
    readonly title: FieldRef<"Lesson", 'String'>
    readonly content: FieldRef<"Lesson", 'String'>
    readonly lessonType: FieldRef<"Lesson", 'LessonType'>
    readonly orderIndex: FieldRef<"Lesson", 'Int'>
    readonly publishedAt: FieldRef<"Lesson", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lesson findUnique
   */
  export type LessonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findUniqueOrThrow
   */
  export type LessonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findFirst
   */
  export type LessonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findFirstOrThrow
   */
  export type LessonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findMany
   */
  export type LessonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson create
   */
  export type LessonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to create a Lesson.
     */
    data: XOR<LessonCreateInput, LessonUncheckedCreateInput>
  }

  /**
   * Lesson createMany
   */
  export type LessonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lesson createManyAndReturn
   */
  export type LessonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson update
   */
  export type LessonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to update a Lesson.
     */
    data: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
    /**
     * Choose, which Lesson to update.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson updateMany
   */
  export type LessonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
  }

  /**
   * Lesson updateManyAndReturn
   */
  export type LessonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson upsert
   */
  export type LessonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The filter to search for the Lesson to update in case it exists.
     */
    where: LessonWhereUniqueInput
    /**
     * In case the Lesson found by the `where` argument doesn't exist, create a new Lesson with this data.
     */
    create: XOR<LessonCreateInput, LessonUncheckedCreateInput>
    /**
     * In case the Lesson was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
  }

  /**
   * Lesson delete
   */
  export type LessonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter which Lesson to delete.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson deleteMany
   */
  export type LessonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lessons to delete
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to delete.
     */
    limit?: number
  }

  /**
   * Lesson.materials
   */
  export type Lesson$materialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    cursor?: MaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Lesson.exercises
   */
  export type Lesson$exercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    cursor?: ExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Lesson.quizzes
   */
  export type Lesson$quizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    where?: QuizWhereInput
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    cursor?: QuizWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Lesson.parent
   */
  export type Lesson$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
  }

  /**
   * Lesson.subLessons
   */
  export type Lesson$subLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson without action
   */
  export type LessonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
  }


  /**
   * Model Material
   */

  export type AggregateMaterial = {
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  export type MaterialAvgAggregateOutputType = {
    id: number | null
    lessonId: number | null
    mediaId: number | null
    uploadedBy: number | null
  }

  export type MaterialSumAggregateOutputType = {
    id: number | null
    lessonId: number | null
    mediaId: number | null
    uploadedBy: number | null
  }

  export type MaterialMinAggregateOutputType = {
    id: number | null
    lessonId: number | null
    title: string | null
    mediaId: number | null
    uploadedBy: number | null
    uploadedAt: Date | null
  }

  export type MaterialMaxAggregateOutputType = {
    id: number | null
    lessonId: number | null
    title: string | null
    mediaId: number | null
    uploadedBy: number | null
    uploadedAt: Date | null
  }

  export type MaterialCountAggregateOutputType = {
    id: number
    lessonId: number
    title: number
    mediaId: number
    uploadedBy: number
    uploadedAt: number
    _all: number
  }


  export type MaterialAvgAggregateInputType = {
    id?: true
    lessonId?: true
    mediaId?: true
    uploadedBy?: true
  }

  export type MaterialSumAggregateInputType = {
    id?: true
    lessonId?: true
    mediaId?: true
    uploadedBy?: true
  }

  export type MaterialMinAggregateInputType = {
    id?: true
    lessonId?: true
    title?: true
    mediaId?: true
    uploadedBy?: true
    uploadedAt?: true
  }

  export type MaterialMaxAggregateInputType = {
    id?: true
    lessonId?: true
    title?: true
    mediaId?: true
    uploadedBy?: true
    uploadedAt?: true
  }

  export type MaterialCountAggregateInputType = {
    id?: true
    lessonId?: true
    title?: true
    mediaId?: true
    uploadedBy?: true
    uploadedAt?: true
    _all?: true
  }

  export type MaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Material to aggregate.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materials
    **/
    _count?: true | MaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialMaxAggregateInputType
  }

  export type GetMaterialAggregateType<T extends MaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterial[P]>
      : GetScalarType<T[P], AggregateMaterial[P]>
  }




  export type MaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithAggregationInput | MaterialOrderByWithAggregationInput[]
    by: MaterialScalarFieldEnum[] | MaterialScalarFieldEnum
    having?: MaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialCountAggregateInputType | true
    _avg?: MaterialAvgAggregateInputType
    _sum?: MaterialSumAggregateInputType
    _min?: MaterialMinAggregateInputType
    _max?: MaterialMaxAggregateInputType
  }

  export type MaterialGroupByOutputType = {
    id: number
    lessonId: number
    title: string
    mediaId: number
    uploadedBy: number
    uploadedAt: Date
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  type GetMaterialGroupByPayload<T extends MaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialGroupByOutputType[P]>
        }
      >
    >


  export type MaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    title?: boolean
    mediaId?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    lesson?: boolean | Material$lessonArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    title?: boolean
    mediaId?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    lesson?: boolean | Material$lessonArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    title?: boolean
    mediaId?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    lesson?: boolean | Material$lessonArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectScalar = {
    id?: boolean
    lessonId?: boolean
    title?: boolean
    mediaId?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
  }

  export type MaterialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lessonId" | "title" | "mediaId" | "uploadedBy" | "uploadedAt", ExtArgs["result"]["material"]>
  export type MaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | Material$lessonArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | Material$lessonArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MaterialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | Material$lessonArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Material"
    objects: {
      lesson: Prisma.$LessonPayload<ExtArgs> | null
      media: Prisma.$MediaPayload<ExtArgs>
      uploader: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      lessonId: number
      title: string
      mediaId: number
      uploadedBy: number
      uploadedAt: Date
    }, ExtArgs["result"]["material"]>
    composites: {}
  }

  type MaterialGetPayload<S extends boolean | null | undefined | MaterialDefaultArgs> = $Result.GetResult<Prisma.$MaterialPayload, S>

  type MaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaterialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaterialCountAggregateInputType | true
    }

  export interface MaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Material'], meta: { name: 'Material' } }
    /**
     * Find zero or one Material that matches the filter.
     * @param {MaterialFindUniqueArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialFindUniqueArgs>(args: SelectSubset<T, MaterialFindUniqueArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Material that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaterialFindUniqueOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Material that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialFindFirstArgs>(args?: SelectSubset<T, MaterialFindFirstArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Material that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materials
     * const materials = await prisma.material.findMany()
     * 
     * // Get first 10 Materials
     * const materials = await prisma.material.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialWithIdOnly = await prisma.material.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialFindManyArgs>(args?: SelectSubset<T, MaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Material.
     * @param {MaterialCreateArgs} args - Arguments to create a Material.
     * @example
     * // Create one Material
     * const Material = await prisma.material.create({
     *   data: {
     *     // ... data to create a Material
     *   }
     * })
     * 
     */
    create<T extends MaterialCreateArgs>(args: SelectSubset<T, MaterialCreateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Materials.
     * @param {MaterialCreateManyArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialCreateManyArgs>(args?: SelectSubset<T, MaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Materials and returns the data saved in the database.
     * @param {MaterialCreateManyAndReturnArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Materials and only return the `id`
     * const materialWithIdOnly = await prisma.material.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, MaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Material.
     * @param {MaterialDeleteArgs} args - Arguments to delete one Material.
     * @example
     * // Delete one Material
     * const Material = await prisma.material.delete({
     *   where: {
     *     // ... filter to delete one Material
     *   }
     * })
     * 
     */
    delete<T extends MaterialDeleteArgs>(args: SelectSubset<T, MaterialDeleteArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Material.
     * @param {MaterialUpdateArgs} args - Arguments to update one Material.
     * @example
     * // Update one Material
     * const material = await prisma.material.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialUpdateArgs>(args: SelectSubset<T, MaterialUpdateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Materials.
     * @param {MaterialDeleteManyArgs} args - Arguments to filter Materials to delete.
     * @example
     * // Delete a few Materials
     * const { count } = await prisma.material.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialDeleteManyArgs>(args?: SelectSubset<T, MaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialUpdateManyArgs>(args: SelectSubset<T, MaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials and returns the data updated in the database.
     * @param {MaterialUpdateManyAndReturnArgs} args - Arguments to update many Materials.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Materials and only return the `id`
     * const materialWithIdOnly = await prisma.material.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaterialUpdateManyAndReturnArgs>(args: SelectSubset<T, MaterialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Material.
     * @param {MaterialUpsertArgs} args - Arguments to update or create a Material.
     * @example
     * // Update or create a Material
     * const material = await prisma.material.upsert({
     *   create: {
     *     // ... data to create a Material
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Material we want to update
     *   }
     * })
     */
    upsert<T extends MaterialUpsertArgs>(args: SelectSubset<T, MaterialUpsertArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialCountArgs} args - Arguments to filter Materials to count.
     * @example
     * // Count the number of Materials
     * const count = await prisma.material.count({
     *   where: {
     *     // ... the filter for the Materials we want to count
     *   }
     * })
    **/
    count<T extends MaterialCountArgs>(
      args?: Subset<T, MaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialAggregateArgs>(args: Subset<T, MaterialAggregateArgs>): Prisma.PrismaPromise<GetMaterialAggregateType<T>>

    /**
     * Group by Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialGroupByArgs['orderBy'] }
        : { orderBy?: MaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Material model
   */
  readonly fields: MaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Material.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lesson<T extends Material$lessonArgs<ExtArgs> = {}>(args?: Subset<T, Material$lessonArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    media<T extends MediaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MediaDefaultArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploader<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Material model
   */
  interface MaterialFieldRefs {
    readonly id: FieldRef<"Material", 'Int'>
    readonly lessonId: FieldRef<"Material", 'Int'>
    readonly title: FieldRef<"Material", 'String'>
    readonly mediaId: FieldRef<"Material", 'Int'>
    readonly uploadedBy: FieldRef<"Material", 'Int'>
    readonly uploadedAt: FieldRef<"Material", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Material findUnique
   */
  export type MaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findUniqueOrThrow
   */
  export type MaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findFirst
   */
  export type MaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findFirstOrThrow
   */
  export type MaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findMany
   */
  export type MaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material create
   */
  export type MaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a Material.
     */
    data: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
  }

  /**
   * Material createMany
   */
  export type MaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Material createManyAndReturn
   */
  export type MaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Material update
   */
  export type MaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a Material.
     */
    data: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
    /**
     * Choose, which Material to update.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material updateMany
   */
  export type MaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to update.
     */
    limit?: number
  }

  /**
   * Material updateManyAndReturn
   */
  export type MaterialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Material upsert
   */
  export type MaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the Material to update in case it exists.
     */
    where: MaterialWhereUniqueInput
    /**
     * In case the Material found by the `where` argument doesn't exist, create a new Material with this data.
     */
    create: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
    /**
     * In case the Material was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
  }

  /**
   * Material delete
   */
  export type MaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter which Material to delete.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material deleteMany
   */
  export type MaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materials to delete
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to delete.
     */
    limit?: number
  }

  /**
   * Material.lesson
   */
  export type Material$lessonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
  }

  /**
   * Material without action
   */
  export type MaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
  }


  /**
   * Model Exercise
   */

  export type AggregateExercise = {
    _count: ExerciseCountAggregateOutputType | null
    _avg: ExerciseAvgAggregateOutputType | null
    _sum: ExerciseSumAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  export type ExerciseAvgAggregateOutputType = {
    id: number | null
    lessonId: number | null
    attachMediaId: number | null
    createdBy: number | null
  }

  export type ExerciseSumAggregateOutputType = {
    id: number | null
    lessonId: number | null
    attachMediaId: number | null
    createdBy: number | null
  }

  export type ExerciseMinAggregateOutputType = {
    id: number | null
    lessonId: number | null
    title: string | null
    description: string | null
    attachMediaId: number | null
    dueAt: Date | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ExerciseMaxAggregateOutputType = {
    id: number | null
    lessonId: number | null
    title: string | null
    description: string | null
    attachMediaId: number | null
    dueAt: Date | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ExerciseCountAggregateOutputType = {
    id: number
    lessonId: number
    title: number
    description: number
    attachMediaId: number
    dueAt: number
    createdBy: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ExerciseAvgAggregateInputType = {
    id?: true
    lessonId?: true
    attachMediaId?: true
    createdBy?: true
  }

  export type ExerciseSumAggregateInputType = {
    id?: true
    lessonId?: true
    attachMediaId?: true
    createdBy?: true
  }

  export type ExerciseMinAggregateInputType = {
    id?: true
    lessonId?: true
    title?: true
    description?: true
    attachMediaId?: true
    dueAt?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ExerciseMaxAggregateInputType = {
    id?: true
    lessonId?: true
    title?: true
    description?: true
    attachMediaId?: true
    dueAt?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ExerciseCountAggregateInputType = {
    id?: true
    lessonId?: true
    title?: true
    description?: true
    attachMediaId?: true
    dueAt?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ExerciseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exercise to aggregate.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exercises
    **/
    _count?: true | ExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExerciseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExerciseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseMaxAggregateInputType
  }

  export type GetExerciseAggregateType<T extends ExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExercise[P]>
      : GetScalarType<T[P], AggregateExercise[P]>
  }




  export type ExerciseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithAggregationInput | ExerciseOrderByWithAggregationInput[]
    by: ExerciseScalarFieldEnum[] | ExerciseScalarFieldEnum
    having?: ExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseCountAggregateInputType | true
    _avg?: ExerciseAvgAggregateInputType
    _sum?: ExerciseSumAggregateInputType
    _min?: ExerciseMinAggregateInputType
    _max?: ExerciseMaxAggregateInputType
  }

  export type ExerciseGroupByOutputType = {
    id: number
    lessonId: number
    title: string
    description: string | null
    attachMediaId: number | null
    dueAt: Date | null
    createdBy: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ExerciseCountAggregateOutputType | null
    _avg: ExerciseAvgAggregateOutputType | null
    _sum: ExerciseSumAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  type GetExerciseGroupByPayload<T extends ExerciseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
        }
      >
    >


  export type ExerciseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    title?: boolean
    description?: boolean
    attachMediaId?: boolean
    dueAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    lesson?: boolean | Exercise$lessonArgs<ExtArgs>
    attachMedia?: boolean | Exercise$attachMediaArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    submissions?: boolean | Exercise$submissionsArgs<ExtArgs>
    _count?: boolean | ExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    title?: boolean
    description?: boolean
    attachMediaId?: boolean
    dueAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    lesson?: boolean | Exercise$lessonArgs<ExtArgs>
    attachMedia?: boolean | Exercise$attachMediaArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    title?: boolean
    description?: boolean
    attachMediaId?: boolean
    dueAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    lesson?: boolean | Exercise$lessonArgs<ExtArgs>
    attachMedia?: boolean | Exercise$attachMediaArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectScalar = {
    id?: boolean
    lessonId?: boolean
    title?: boolean
    description?: boolean
    attachMediaId?: boolean
    dueAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ExerciseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lessonId" | "title" | "description" | "attachMediaId" | "dueAt" | "createdBy" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["exercise"]>
  export type ExerciseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | Exercise$lessonArgs<ExtArgs>
    attachMedia?: boolean | Exercise$attachMediaArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    submissions?: boolean | Exercise$submissionsArgs<ExtArgs>
    _count?: boolean | ExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExerciseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | Exercise$lessonArgs<ExtArgs>
    attachMedia?: boolean | Exercise$attachMediaArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ExerciseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | Exercise$lessonArgs<ExtArgs>
    attachMedia?: boolean | Exercise$attachMediaArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ExercisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exercise"
    objects: {
      lesson: Prisma.$LessonPayload<ExtArgs> | null
      attachMedia: Prisma.$MediaPayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs>
      submissions: Prisma.$ExerciseSubmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      lessonId: number
      title: string
      description: string | null
      attachMediaId: number | null
      dueAt: Date | null
      createdBy: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["exercise"]>
    composites: {}
  }

  type ExerciseGetPayload<S extends boolean | null | undefined | ExerciseDefaultArgs> = $Result.GetResult<Prisma.$ExercisePayload, S>

  type ExerciseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExerciseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExerciseCountAggregateInputType | true
    }

  export interface ExerciseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exercise'], meta: { name: 'Exercise' } }
    /**
     * Find zero or one Exercise that matches the filter.
     * @param {ExerciseFindUniqueArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExerciseFindUniqueArgs>(args: SelectSubset<T, ExerciseFindUniqueArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Exercise that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExerciseFindUniqueOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExerciseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExerciseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExerciseFindFirstArgs>(args?: SelectSubset<T, ExerciseFindFirstArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exercise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExerciseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExerciseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exercises
     * const exercises = await prisma.exercise.findMany()
     * 
     * // Get first 10 Exercises
     * const exercises = await prisma.exercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseWithIdOnly = await prisma.exercise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExerciseFindManyArgs>(args?: SelectSubset<T, ExerciseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Exercise.
     * @param {ExerciseCreateArgs} args - Arguments to create a Exercise.
     * @example
     * // Create one Exercise
     * const Exercise = await prisma.exercise.create({
     *   data: {
     *     // ... data to create a Exercise
     *   }
     * })
     * 
     */
    create<T extends ExerciseCreateArgs>(args: SelectSubset<T, ExerciseCreateArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Exercises.
     * @param {ExerciseCreateManyArgs} args - Arguments to create many Exercises.
     * @example
     * // Create many Exercises
     * const exercise = await prisma.exercise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExerciseCreateManyArgs>(args?: SelectSubset<T, ExerciseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exercises and returns the data saved in the database.
     * @param {ExerciseCreateManyAndReturnArgs} args - Arguments to create many Exercises.
     * @example
     * // Create many Exercises
     * const exercise = await prisma.exercise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exercises and only return the `id`
     * const exerciseWithIdOnly = await prisma.exercise.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExerciseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExerciseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Exercise.
     * @param {ExerciseDeleteArgs} args - Arguments to delete one Exercise.
     * @example
     * // Delete one Exercise
     * const Exercise = await prisma.exercise.delete({
     *   where: {
     *     // ... filter to delete one Exercise
     *   }
     * })
     * 
     */
    delete<T extends ExerciseDeleteArgs>(args: SelectSubset<T, ExerciseDeleteArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Exercise.
     * @param {ExerciseUpdateArgs} args - Arguments to update one Exercise.
     * @example
     * // Update one Exercise
     * const exercise = await prisma.exercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExerciseUpdateArgs>(args: SelectSubset<T, ExerciseUpdateArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Exercises.
     * @param {ExerciseDeleteManyArgs} args - Arguments to filter Exercises to delete.
     * @example
     * // Delete a few Exercises
     * const { count } = await prisma.exercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExerciseDeleteManyArgs>(args?: SelectSubset<T, ExerciseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exercises
     * const exercise = await prisma.exercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExerciseUpdateManyArgs>(args: SelectSubset<T, ExerciseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exercises and returns the data updated in the database.
     * @param {ExerciseUpdateManyAndReturnArgs} args - Arguments to update many Exercises.
     * @example
     * // Update many Exercises
     * const exercise = await prisma.exercise.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Exercises and only return the `id`
     * const exerciseWithIdOnly = await prisma.exercise.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExerciseUpdateManyAndReturnArgs>(args: SelectSubset<T, ExerciseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Exercise.
     * @param {ExerciseUpsertArgs} args - Arguments to update or create a Exercise.
     * @example
     * // Update or create a Exercise
     * const exercise = await prisma.exercise.upsert({
     *   create: {
     *     // ... data to create a Exercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exercise we want to update
     *   }
     * })
     */
    upsert<T extends ExerciseUpsertArgs>(args: SelectSubset<T, ExerciseUpsertArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseCountArgs} args - Arguments to filter Exercises to count.
     * @example
     * // Count the number of Exercises
     * const count = await prisma.exercise.count({
     *   where: {
     *     // ... the filter for the Exercises we want to count
     *   }
     * })
    **/
    count<T extends ExerciseCountArgs>(
      args?: Subset<T, ExerciseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseAggregateArgs>(args: Subset<T, ExerciseAggregateArgs>): Prisma.PrismaPromise<GetExerciseAggregateType<T>>

    /**
     * Group by Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciseGroupByArgs['orderBy'] }
        : { orderBy?: ExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exercise model
   */
  readonly fields: ExerciseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExerciseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lesson<T extends Exercise$lessonArgs<ExtArgs> = {}>(args?: Subset<T, Exercise$lessonArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    attachMedia<T extends Exercise$attachMediaArgs<ExtArgs> = {}>(args?: Subset<T, Exercise$attachMediaArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    submissions<T extends Exercise$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, Exercise$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exercise model
   */
  interface ExerciseFieldRefs {
    readonly id: FieldRef<"Exercise", 'Int'>
    readonly lessonId: FieldRef<"Exercise", 'Int'>
    readonly title: FieldRef<"Exercise", 'String'>
    readonly description: FieldRef<"Exercise", 'String'>
    readonly attachMediaId: FieldRef<"Exercise", 'Int'>
    readonly dueAt: FieldRef<"Exercise", 'DateTime'>
    readonly createdBy: FieldRef<"Exercise", 'Int'>
    readonly createdAt: FieldRef<"Exercise", 'DateTime'>
    readonly updatedAt: FieldRef<"Exercise", 'DateTime'>
    readonly deletedAt: FieldRef<"Exercise", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Exercise findUnique
   */
  export type ExerciseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise findUniqueOrThrow
   */
  export type ExerciseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise findFirst
   */
  export type ExerciseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise findFirstOrThrow
   */
  export type ExerciseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise findMany
   */
  export type ExerciseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercises to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise create
   */
  export type ExerciseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The data needed to create a Exercise.
     */
    data: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
  }

  /**
   * Exercise createMany
   */
  export type ExerciseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exercises.
     */
    data: ExerciseCreateManyInput | ExerciseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exercise createManyAndReturn
   */
  export type ExerciseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * The data used to create many Exercises.
     */
    data: ExerciseCreateManyInput | ExerciseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exercise update
   */
  export type ExerciseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The data needed to update a Exercise.
     */
    data: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
    /**
     * Choose, which Exercise to update.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise updateMany
   */
  export type ExerciseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exercises.
     */
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyInput>
    /**
     * Filter which Exercises to update
     */
    where?: ExerciseWhereInput
    /**
     * Limit how many Exercises to update.
     */
    limit?: number
  }

  /**
   * Exercise updateManyAndReturn
   */
  export type ExerciseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * The data used to update Exercises.
     */
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyInput>
    /**
     * Filter which Exercises to update
     */
    where?: ExerciseWhereInput
    /**
     * Limit how many Exercises to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exercise upsert
   */
  export type ExerciseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The filter to search for the Exercise to update in case it exists.
     */
    where: ExerciseWhereUniqueInput
    /**
     * In case the Exercise found by the `where` argument doesn't exist, create a new Exercise with this data.
     */
    create: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
    /**
     * In case the Exercise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
  }

  /**
   * Exercise delete
   */
  export type ExerciseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter which Exercise to delete.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise deleteMany
   */
  export type ExerciseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exercises to delete
     */
    where?: ExerciseWhereInput
    /**
     * Limit how many Exercises to delete.
     */
    limit?: number
  }

  /**
   * Exercise.lesson
   */
  export type Exercise$lessonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
  }

  /**
   * Exercise.attachMedia
   */
  export type Exercise$attachMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Exercise.submissions
   */
  export type Exercise$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionInclude<ExtArgs> | null
    where?: ExerciseSubmissionWhereInput
    orderBy?: ExerciseSubmissionOrderByWithRelationInput | ExerciseSubmissionOrderByWithRelationInput[]
    cursor?: ExerciseSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseSubmissionScalarFieldEnum | ExerciseSubmissionScalarFieldEnum[]
  }

  /**
   * Exercise without action
   */
  export type ExerciseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exercise
     */
    omit?: ExerciseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
  }


  /**
   * Model ExerciseSubmission
   */

  export type AggregateExerciseSubmission = {
    _count: ExerciseSubmissionCountAggregateOutputType | null
    _avg: ExerciseSubmissionAvgAggregateOutputType | null
    _sum: ExerciseSubmissionSumAggregateOutputType | null
    _min: ExerciseSubmissionMinAggregateOutputType | null
    _max: ExerciseSubmissionMaxAggregateOutputType | null
  }

  export type ExerciseSubmissionAvgAggregateOutputType = {
    id: number | null
    exerciseId: number | null
    studentId: number | null
    mediaId: number | null
    score: Decimal | null
  }

  export type ExerciseSubmissionSumAggregateOutputType = {
    id: number | null
    exerciseId: number | null
    studentId: number | null
    mediaId: number | null
    score: Decimal | null
  }

  export type ExerciseSubmissionMinAggregateOutputType = {
    id: number | null
    exerciseId: number | null
    studentId: number | null
    mediaId: number | null
    submittedAt: Date | null
    score: Decimal | null
    comment: string | null
    gradedAt: Date | null
  }

  export type ExerciseSubmissionMaxAggregateOutputType = {
    id: number | null
    exerciseId: number | null
    studentId: number | null
    mediaId: number | null
    submittedAt: Date | null
    score: Decimal | null
    comment: string | null
    gradedAt: Date | null
  }

  export type ExerciseSubmissionCountAggregateOutputType = {
    id: number
    exerciseId: number
    studentId: number
    mediaId: number
    submittedAt: number
    score: number
    comment: number
    gradedAt: number
    _all: number
  }


  export type ExerciseSubmissionAvgAggregateInputType = {
    id?: true
    exerciseId?: true
    studentId?: true
    mediaId?: true
    score?: true
  }

  export type ExerciseSubmissionSumAggregateInputType = {
    id?: true
    exerciseId?: true
    studentId?: true
    mediaId?: true
    score?: true
  }

  export type ExerciseSubmissionMinAggregateInputType = {
    id?: true
    exerciseId?: true
    studentId?: true
    mediaId?: true
    submittedAt?: true
    score?: true
    comment?: true
    gradedAt?: true
  }

  export type ExerciseSubmissionMaxAggregateInputType = {
    id?: true
    exerciseId?: true
    studentId?: true
    mediaId?: true
    submittedAt?: true
    score?: true
    comment?: true
    gradedAt?: true
  }

  export type ExerciseSubmissionCountAggregateInputType = {
    id?: true
    exerciseId?: true
    studentId?: true
    mediaId?: true
    submittedAt?: true
    score?: true
    comment?: true
    gradedAt?: true
    _all?: true
  }

  export type ExerciseSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExerciseSubmission to aggregate.
     */
    where?: ExerciseSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseSubmissions to fetch.
     */
    orderBy?: ExerciseSubmissionOrderByWithRelationInput | ExerciseSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExerciseSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExerciseSubmissions
    **/
    _count?: true | ExerciseSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExerciseSubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExerciseSubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseSubmissionMaxAggregateInputType
  }

  export type GetExerciseSubmissionAggregateType<T extends ExerciseSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateExerciseSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExerciseSubmission[P]>
      : GetScalarType<T[P], AggregateExerciseSubmission[P]>
  }




  export type ExerciseSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseSubmissionWhereInput
    orderBy?: ExerciseSubmissionOrderByWithAggregationInput | ExerciseSubmissionOrderByWithAggregationInput[]
    by: ExerciseSubmissionScalarFieldEnum[] | ExerciseSubmissionScalarFieldEnum
    having?: ExerciseSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseSubmissionCountAggregateInputType | true
    _avg?: ExerciseSubmissionAvgAggregateInputType
    _sum?: ExerciseSubmissionSumAggregateInputType
    _min?: ExerciseSubmissionMinAggregateInputType
    _max?: ExerciseSubmissionMaxAggregateInputType
  }

  export type ExerciseSubmissionGroupByOutputType = {
    id: number
    exerciseId: number
    studentId: number
    mediaId: number
    submittedAt: Date
    score: Decimal | null
    comment: string | null
    gradedAt: Date | null
    _count: ExerciseSubmissionCountAggregateOutputType | null
    _avg: ExerciseSubmissionAvgAggregateOutputType | null
    _sum: ExerciseSubmissionSumAggregateOutputType | null
    _min: ExerciseSubmissionMinAggregateOutputType | null
    _max: ExerciseSubmissionMaxAggregateOutputType | null
  }

  type GetExerciseSubmissionGroupByPayload<T extends ExerciseSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExerciseSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type ExerciseSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exerciseId?: boolean
    studentId?: boolean
    mediaId?: boolean
    submittedAt?: boolean
    score?: boolean
    comment?: boolean
    gradedAt?: boolean
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseSubmission"]>

  export type ExerciseSubmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exerciseId?: boolean
    studentId?: boolean
    mediaId?: boolean
    submittedAt?: boolean
    score?: boolean
    comment?: boolean
    gradedAt?: boolean
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseSubmission"]>

  export type ExerciseSubmissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exerciseId?: boolean
    studentId?: boolean
    mediaId?: boolean
    submittedAt?: boolean
    score?: boolean
    comment?: boolean
    gradedAt?: boolean
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exerciseSubmission"]>

  export type ExerciseSubmissionSelectScalar = {
    id?: boolean
    exerciseId?: boolean
    studentId?: boolean
    mediaId?: boolean
    submittedAt?: boolean
    score?: boolean
    comment?: boolean
    gradedAt?: boolean
  }

  export type ExerciseSubmissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "exerciseId" | "studentId" | "mediaId" | "submittedAt" | "score" | "comment" | "gradedAt", ExtArgs["result"]["exerciseSubmission"]>
  export type ExerciseSubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }
  export type ExerciseSubmissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }
  export type ExerciseSubmissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }

  export type $ExerciseSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExerciseSubmission"
    objects: {
      exercise: Prisma.$ExercisePayload<ExtArgs>
      student: Prisma.$UserPayload<ExtArgs>
      media: Prisma.$MediaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      exerciseId: number
      studentId: number
      mediaId: number
      submittedAt: Date
      score: Prisma.Decimal | null
      comment: string | null
      gradedAt: Date | null
    }, ExtArgs["result"]["exerciseSubmission"]>
    composites: {}
  }

  type ExerciseSubmissionGetPayload<S extends boolean | null | undefined | ExerciseSubmissionDefaultArgs> = $Result.GetResult<Prisma.$ExerciseSubmissionPayload, S>

  type ExerciseSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExerciseSubmissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExerciseSubmissionCountAggregateInputType | true
    }

  export interface ExerciseSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExerciseSubmission'], meta: { name: 'ExerciseSubmission' } }
    /**
     * Find zero or one ExerciseSubmission that matches the filter.
     * @param {ExerciseSubmissionFindUniqueArgs} args - Arguments to find a ExerciseSubmission
     * @example
     * // Get one ExerciseSubmission
     * const exerciseSubmission = await prisma.exerciseSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExerciseSubmissionFindUniqueArgs>(args: SelectSubset<T, ExerciseSubmissionFindUniqueArgs<ExtArgs>>): Prisma__ExerciseSubmissionClient<$Result.GetResult<Prisma.$ExerciseSubmissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExerciseSubmission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExerciseSubmissionFindUniqueOrThrowArgs} args - Arguments to find a ExerciseSubmission
     * @example
     * // Get one ExerciseSubmission
     * const exerciseSubmission = await prisma.exerciseSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExerciseSubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, ExerciseSubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExerciseSubmissionClient<$Result.GetResult<Prisma.$ExerciseSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExerciseSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseSubmissionFindFirstArgs} args - Arguments to find a ExerciseSubmission
     * @example
     * // Get one ExerciseSubmission
     * const exerciseSubmission = await prisma.exerciseSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExerciseSubmissionFindFirstArgs>(args?: SelectSubset<T, ExerciseSubmissionFindFirstArgs<ExtArgs>>): Prisma__ExerciseSubmissionClient<$Result.GetResult<Prisma.$ExerciseSubmissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExerciseSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseSubmissionFindFirstOrThrowArgs} args - Arguments to find a ExerciseSubmission
     * @example
     * // Get one ExerciseSubmission
     * const exerciseSubmission = await prisma.exerciseSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExerciseSubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, ExerciseSubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExerciseSubmissionClient<$Result.GetResult<Prisma.$ExerciseSubmissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExerciseSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExerciseSubmissions
     * const exerciseSubmissions = await prisma.exerciseSubmission.findMany()
     * 
     * // Get first 10 ExerciseSubmissions
     * const exerciseSubmissions = await prisma.exerciseSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseSubmissionWithIdOnly = await prisma.exerciseSubmission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExerciseSubmissionFindManyArgs>(args?: SelectSubset<T, ExerciseSubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExerciseSubmission.
     * @param {ExerciseSubmissionCreateArgs} args - Arguments to create a ExerciseSubmission.
     * @example
     * // Create one ExerciseSubmission
     * const ExerciseSubmission = await prisma.exerciseSubmission.create({
     *   data: {
     *     // ... data to create a ExerciseSubmission
     *   }
     * })
     * 
     */
    create<T extends ExerciseSubmissionCreateArgs>(args: SelectSubset<T, ExerciseSubmissionCreateArgs<ExtArgs>>): Prisma__ExerciseSubmissionClient<$Result.GetResult<Prisma.$ExerciseSubmissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExerciseSubmissions.
     * @param {ExerciseSubmissionCreateManyArgs} args - Arguments to create many ExerciseSubmissions.
     * @example
     * // Create many ExerciseSubmissions
     * const exerciseSubmission = await prisma.exerciseSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExerciseSubmissionCreateManyArgs>(args?: SelectSubset<T, ExerciseSubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExerciseSubmissions and returns the data saved in the database.
     * @param {ExerciseSubmissionCreateManyAndReturnArgs} args - Arguments to create many ExerciseSubmissions.
     * @example
     * // Create many ExerciseSubmissions
     * const exerciseSubmission = await prisma.exerciseSubmission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExerciseSubmissions and only return the `id`
     * const exerciseSubmissionWithIdOnly = await prisma.exerciseSubmission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExerciseSubmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, ExerciseSubmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseSubmissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExerciseSubmission.
     * @param {ExerciseSubmissionDeleteArgs} args - Arguments to delete one ExerciseSubmission.
     * @example
     * // Delete one ExerciseSubmission
     * const ExerciseSubmission = await prisma.exerciseSubmission.delete({
     *   where: {
     *     // ... filter to delete one ExerciseSubmission
     *   }
     * })
     * 
     */
    delete<T extends ExerciseSubmissionDeleteArgs>(args: SelectSubset<T, ExerciseSubmissionDeleteArgs<ExtArgs>>): Prisma__ExerciseSubmissionClient<$Result.GetResult<Prisma.$ExerciseSubmissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExerciseSubmission.
     * @param {ExerciseSubmissionUpdateArgs} args - Arguments to update one ExerciseSubmission.
     * @example
     * // Update one ExerciseSubmission
     * const exerciseSubmission = await prisma.exerciseSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExerciseSubmissionUpdateArgs>(args: SelectSubset<T, ExerciseSubmissionUpdateArgs<ExtArgs>>): Prisma__ExerciseSubmissionClient<$Result.GetResult<Prisma.$ExerciseSubmissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExerciseSubmissions.
     * @param {ExerciseSubmissionDeleteManyArgs} args - Arguments to filter ExerciseSubmissions to delete.
     * @example
     * // Delete a few ExerciseSubmissions
     * const { count } = await prisma.exerciseSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExerciseSubmissionDeleteManyArgs>(args?: SelectSubset<T, ExerciseSubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExerciseSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExerciseSubmissions
     * const exerciseSubmission = await prisma.exerciseSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExerciseSubmissionUpdateManyArgs>(args: SelectSubset<T, ExerciseSubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExerciseSubmissions and returns the data updated in the database.
     * @param {ExerciseSubmissionUpdateManyAndReturnArgs} args - Arguments to update many ExerciseSubmissions.
     * @example
     * // Update many ExerciseSubmissions
     * const exerciseSubmission = await prisma.exerciseSubmission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExerciseSubmissions and only return the `id`
     * const exerciseSubmissionWithIdOnly = await prisma.exerciseSubmission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExerciseSubmissionUpdateManyAndReturnArgs>(args: SelectSubset<T, ExerciseSubmissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciseSubmissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExerciseSubmission.
     * @param {ExerciseSubmissionUpsertArgs} args - Arguments to update or create a ExerciseSubmission.
     * @example
     * // Update or create a ExerciseSubmission
     * const exerciseSubmission = await prisma.exerciseSubmission.upsert({
     *   create: {
     *     // ... data to create a ExerciseSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExerciseSubmission we want to update
     *   }
     * })
     */
    upsert<T extends ExerciseSubmissionUpsertArgs>(args: SelectSubset<T, ExerciseSubmissionUpsertArgs<ExtArgs>>): Prisma__ExerciseSubmissionClient<$Result.GetResult<Prisma.$ExerciseSubmissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExerciseSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseSubmissionCountArgs} args - Arguments to filter ExerciseSubmissions to count.
     * @example
     * // Count the number of ExerciseSubmissions
     * const count = await prisma.exerciseSubmission.count({
     *   where: {
     *     // ... the filter for the ExerciseSubmissions we want to count
     *   }
     * })
    **/
    count<T extends ExerciseSubmissionCountArgs>(
      args?: Subset<T, ExerciseSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExerciseSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseSubmissionAggregateArgs>(args: Subset<T, ExerciseSubmissionAggregateArgs>): Prisma.PrismaPromise<GetExerciseSubmissionAggregateType<T>>

    /**
     * Group by ExerciseSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciseSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciseSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: ExerciseSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciseSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExerciseSubmission model
   */
  readonly fields: ExerciseSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExerciseSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExerciseSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exercise<T extends ExerciseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExerciseDefaultArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    media<T extends MediaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MediaDefaultArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExerciseSubmission model
   */
  interface ExerciseSubmissionFieldRefs {
    readonly id: FieldRef<"ExerciseSubmission", 'Int'>
    readonly exerciseId: FieldRef<"ExerciseSubmission", 'Int'>
    readonly studentId: FieldRef<"ExerciseSubmission", 'Int'>
    readonly mediaId: FieldRef<"ExerciseSubmission", 'Int'>
    readonly submittedAt: FieldRef<"ExerciseSubmission", 'DateTime'>
    readonly score: FieldRef<"ExerciseSubmission", 'Decimal'>
    readonly comment: FieldRef<"ExerciseSubmission", 'String'>
    readonly gradedAt: FieldRef<"ExerciseSubmission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExerciseSubmission findUnique
   */
  export type ExerciseSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseSubmission to fetch.
     */
    where: ExerciseSubmissionWhereUniqueInput
  }

  /**
   * ExerciseSubmission findUniqueOrThrow
   */
  export type ExerciseSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseSubmission to fetch.
     */
    where: ExerciseSubmissionWhereUniqueInput
  }

  /**
   * ExerciseSubmission findFirst
   */
  export type ExerciseSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseSubmission to fetch.
     */
    where?: ExerciseSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseSubmissions to fetch.
     */
    orderBy?: ExerciseSubmissionOrderByWithRelationInput | ExerciseSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExerciseSubmissions.
     */
    cursor?: ExerciseSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExerciseSubmissions.
     */
    distinct?: ExerciseSubmissionScalarFieldEnum | ExerciseSubmissionScalarFieldEnum[]
  }

  /**
   * ExerciseSubmission findFirstOrThrow
   */
  export type ExerciseSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseSubmission to fetch.
     */
    where?: ExerciseSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseSubmissions to fetch.
     */
    orderBy?: ExerciseSubmissionOrderByWithRelationInput | ExerciseSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExerciseSubmissions.
     */
    cursor?: ExerciseSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExerciseSubmissions.
     */
    distinct?: ExerciseSubmissionScalarFieldEnum | ExerciseSubmissionScalarFieldEnum[]
  }

  /**
   * ExerciseSubmission findMany
   */
  export type ExerciseSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which ExerciseSubmissions to fetch.
     */
    where?: ExerciseSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseSubmissions to fetch.
     */
    orderBy?: ExerciseSubmissionOrderByWithRelationInput | ExerciseSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExerciseSubmissions.
     */
    cursor?: ExerciseSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseSubmissions.
     */
    skip?: number
    distinct?: ExerciseSubmissionScalarFieldEnum | ExerciseSubmissionScalarFieldEnum[]
  }

  /**
   * ExerciseSubmission create
   */
  export type ExerciseSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a ExerciseSubmission.
     */
    data: XOR<ExerciseSubmissionCreateInput, ExerciseSubmissionUncheckedCreateInput>
  }

  /**
   * ExerciseSubmission createMany
   */
  export type ExerciseSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExerciseSubmissions.
     */
    data: ExerciseSubmissionCreateManyInput | ExerciseSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExerciseSubmission createManyAndReturn
   */
  export type ExerciseSubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * The data used to create many ExerciseSubmissions.
     */
    data: ExerciseSubmissionCreateManyInput | ExerciseSubmissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExerciseSubmission update
   */
  export type ExerciseSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a ExerciseSubmission.
     */
    data: XOR<ExerciseSubmissionUpdateInput, ExerciseSubmissionUncheckedUpdateInput>
    /**
     * Choose, which ExerciseSubmission to update.
     */
    where: ExerciseSubmissionWhereUniqueInput
  }

  /**
   * ExerciseSubmission updateMany
   */
  export type ExerciseSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExerciseSubmissions.
     */
    data: XOR<ExerciseSubmissionUpdateManyMutationInput, ExerciseSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which ExerciseSubmissions to update
     */
    where?: ExerciseSubmissionWhereInput
    /**
     * Limit how many ExerciseSubmissions to update.
     */
    limit?: number
  }

  /**
   * ExerciseSubmission updateManyAndReturn
   */
  export type ExerciseSubmissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * The data used to update ExerciseSubmissions.
     */
    data: XOR<ExerciseSubmissionUpdateManyMutationInput, ExerciseSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which ExerciseSubmissions to update
     */
    where?: ExerciseSubmissionWhereInput
    /**
     * Limit how many ExerciseSubmissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExerciseSubmission upsert
   */
  export type ExerciseSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the ExerciseSubmission to update in case it exists.
     */
    where: ExerciseSubmissionWhereUniqueInput
    /**
     * In case the ExerciseSubmission found by the `where` argument doesn't exist, create a new ExerciseSubmission with this data.
     */
    create: XOR<ExerciseSubmissionCreateInput, ExerciseSubmissionUncheckedCreateInput>
    /**
     * In case the ExerciseSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExerciseSubmissionUpdateInput, ExerciseSubmissionUncheckedUpdateInput>
  }

  /**
   * ExerciseSubmission delete
   */
  export type ExerciseSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionInclude<ExtArgs> | null
    /**
     * Filter which ExerciseSubmission to delete.
     */
    where: ExerciseSubmissionWhereUniqueInput
  }

  /**
   * ExerciseSubmission deleteMany
   */
  export type ExerciseSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExerciseSubmissions to delete
     */
    where?: ExerciseSubmissionWhereInput
    /**
     * Limit how many ExerciseSubmissions to delete.
     */
    limit?: number
  }

  /**
   * ExerciseSubmission without action
   */
  export type ExerciseSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseSubmission
     */
    select?: ExerciseSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciseSubmission
     */
    omit?: ExerciseSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseSubmissionInclude<ExtArgs> | null
  }


  /**
   * Model Quiz
   */

  export type AggregateQuiz = {
    _count: QuizCountAggregateOutputType | null
    _avg: QuizAvgAggregateOutputType | null
    _sum: QuizSumAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  export type QuizAvgAggregateOutputType = {
    id: number | null
    lessonId: number | null
    timeLimitSec: number | null
    maxAttempts: number | null
    totalPoints: Decimal | null
    createdBy: number | null
  }

  export type QuizSumAggregateOutputType = {
    id: number | null
    lessonId: number | null
    timeLimitSec: number | null
    maxAttempts: number | null
    totalPoints: Decimal | null
    createdBy: number | null
  }

  export type QuizMinAggregateOutputType = {
    id: number | null
    lessonId: number | null
    title: string | null
    description: string | null
    timeLimitSec: number | null
    maxAttempts: number | null
    shuffleQuestions: boolean | null
    shuffleOptions: boolean | null
    gradingMethod: string | null
    showAnswersAfter: string | null
    dueAt: Date | null
    isPublished: boolean | null
    totalPoints: Decimal | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type QuizMaxAggregateOutputType = {
    id: number | null
    lessonId: number | null
    title: string | null
    description: string | null
    timeLimitSec: number | null
    maxAttempts: number | null
    shuffleQuestions: boolean | null
    shuffleOptions: boolean | null
    gradingMethod: string | null
    showAnswersAfter: string | null
    dueAt: Date | null
    isPublished: boolean | null
    totalPoints: Decimal | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type QuizCountAggregateOutputType = {
    id: number
    lessonId: number
    title: number
    description: number
    timeLimitSec: number
    maxAttempts: number
    shuffleQuestions: number
    shuffleOptions: number
    gradingMethod: number
    showAnswersAfter: number
    dueAt: number
    isPublished: number
    totalPoints: number
    createdBy: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type QuizAvgAggregateInputType = {
    id?: true
    lessonId?: true
    timeLimitSec?: true
    maxAttempts?: true
    totalPoints?: true
    createdBy?: true
  }

  export type QuizSumAggregateInputType = {
    id?: true
    lessonId?: true
    timeLimitSec?: true
    maxAttempts?: true
    totalPoints?: true
    createdBy?: true
  }

  export type QuizMinAggregateInputType = {
    id?: true
    lessonId?: true
    title?: true
    description?: true
    timeLimitSec?: true
    maxAttempts?: true
    shuffleQuestions?: true
    shuffleOptions?: true
    gradingMethod?: true
    showAnswersAfter?: true
    dueAt?: true
    isPublished?: true
    totalPoints?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type QuizMaxAggregateInputType = {
    id?: true
    lessonId?: true
    title?: true
    description?: true
    timeLimitSec?: true
    maxAttempts?: true
    shuffleQuestions?: true
    shuffleOptions?: true
    gradingMethod?: true
    showAnswersAfter?: true
    dueAt?: true
    isPublished?: true
    totalPoints?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type QuizCountAggregateInputType = {
    id?: true
    lessonId?: true
    title?: true
    description?: true
    timeLimitSec?: true
    maxAttempts?: true
    shuffleQuestions?: true
    shuffleOptions?: true
    gradingMethod?: true
    showAnswersAfter?: true
    dueAt?: true
    isPublished?: true
    totalPoints?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type QuizAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quiz to aggregate.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quizzes
    **/
    _count?: true | QuizCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizMaxAggregateInputType
  }

  export type GetQuizAggregateType<T extends QuizAggregateArgs> = {
        [P in keyof T & keyof AggregateQuiz]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuiz[P]>
      : GetScalarType<T[P], AggregateQuiz[P]>
  }




  export type QuizGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizWhereInput
    orderBy?: QuizOrderByWithAggregationInput | QuizOrderByWithAggregationInput[]
    by: QuizScalarFieldEnum[] | QuizScalarFieldEnum
    having?: QuizScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizCountAggregateInputType | true
    _avg?: QuizAvgAggregateInputType
    _sum?: QuizSumAggregateInputType
    _min?: QuizMinAggregateInputType
    _max?: QuizMaxAggregateInputType
  }

  export type QuizGroupByOutputType = {
    id: number
    lessonId: number
    title: string
    description: string | null
    timeLimitSec: number | null
    maxAttempts: number
    shuffleQuestions: boolean
    shuffleOptions: boolean
    gradingMethod: string
    showAnswersAfter: string
    dueAt: Date | null
    isPublished: boolean
    totalPoints: Decimal
    createdBy: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: QuizCountAggregateOutputType | null
    _avg: QuizAvgAggregateOutputType | null
    _sum: QuizSumAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  type GetQuizGroupByPayload<T extends QuizGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizGroupByOutputType[P]>
            : GetScalarType<T[P], QuizGroupByOutputType[P]>
        }
      >
    >


  export type QuizSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    title?: boolean
    description?: boolean
    timeLimitSec?: boolean
    maxAttempts?: boolean
    shuffleQuestions?: boolean
    shuffleOptions?: boolean
    gradingMethod?: boolean
    showAnswersAfter?: boolean
    dueAt?: boolean
    isPublished?: boolean
    totalPoints?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    sections?: boolean | Quiz$sectionsArgs<ExtArgs>
    questionGroups?: boolean | Quiz$questionGroupsArgs<ExtArgs>
    questions?: boolean | Quiz$questionsArgs<ExtArgs>
    attempts?: boolean | Quiz$attemptsArgs<ExtArgs>
    _count?: boolean | QuizCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    title?: boolean
    description?: boolean
    timeLimitSec?: boolean
    maxAttempts?: boolean
    shuffleQuestions?: boolean
    shuffleOptions?: boolean
    gradingMethod?: boolean
    showAnswersAfter?: boolean
    dueAt?: boolean
    isPublished?: boolean
    totalPoints?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    title?: boolean
    description?: boolean
    timeLimitSec?: boolean
    maxAttempts?: boolean
    shuffleQuestions?: boolean
    shuffleOptions?: boolean
    gradingMethod?: boolean
    showAnswersAfter?: boolean
    dueAt?: boolean
    isPublished?: boolean
    totalPoints?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectScalar = {
    id?: boolean
    lessonId?: boolean
    title?: boolean
    description?: boolean
    timeLimitSec?: boolean
    maxAttempts?: boolean
    shuffleQuestions?: boolean
    shuffleOptions?: boolean
    gradingMethod?: boolean
    showAnswersAfter?: boolean
    dueAt?: boolean
    isPublished?: boolean
    totalPoints?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type QuizOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lessonId" | "title" | "description" | "timeLimitSec" | "maxAttempts" | "shuffleQuestions" | "shuffleOptions" | "gradingMethod" | "showAnswersAfter" | "dueAt" | "isPublished" | "totalPoints" | "createdBy" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["quiz"]>
  export type QuizInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    sections?: boolean | Quiz$sectionsArgs<ExtArgs>
    questionGroups?: boolean | Quiz$questionGroupsArgs<ExtArgs>
    questions?: boolean | Quiz$questionsArgs<ExtArgs>
    attempts?: boolean | Quiz$attemptsArgs<ExtArgs>
    _count?: boolean | QuizCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QuizIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $QuizPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quiz"
    objects: {
      lesson: Prisma.$LessonPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      sections: Prisma.$QuizSectionPayload<ExtArgs>[]
      questionGroups: Prisma.$QuizQuestionGroupPayload<ExtArgs>[]
      questions: Prisma.$QuizQuestionPayload<ExtArgs>[]
      attempts: Prisma.$QuizAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      lessonId: number
      title: string
      description: string | null
      timeLimitSec: number | null
      maxAttempts: number
      shuffleQuestions: boolean
      shuffleOptions: boolean
      gradingMethod: string
      showAnswersAfter: string
      dueAt: Date | null
      isPublished: boolean
      totalPoints: Prisma.Decimal
      createdBy: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["quiz"]>
    composites: {}
  }

  type QuizGetPayload<S extends boolean | null | undefined | QuizDefaultArgs> = $Result.GetResult<Prisma.$QuizPayload, S>

  type QuizCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizCountAggregateInputType | true
    }

  export interface QuizDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quiz'], meta: { name: 'Quiz' } }
    /**
     * Find zero or one Quiz that matches the filter.
     * @param {QuizFindUniqueArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizFindUniqueArgs>(args: SelectSubset<T, QuizFindUniqueArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quiz that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizFindUniqueOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quiz that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindFirstArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizFindFirstArgs>(args?: SelectSubset<T, QuizFindFirstArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quiz that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindFirstOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quizzes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quizzes
     * const quizzes = await prisma.quiz.findMany()
     * 
     * // Get first 10 Quizzes
     * const quizzes = await prisma.quiz.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizWithIdOnly = await prisma.quiz.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizFindManyArgs>(args?: SelectSubset<T, QuizFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quiz.
     * @param {QuizCreateArgs} args - Arguments to create a Quiz.
     * @example
     * // Create one Quiz
     * const Quiz = await prisma.quiz.create({
     *   data: {
     *     // ... data to create a Quiz
     *   }
     * })
     * 
     */
    create<T extends QuizCreateArgs>(args: SelectSubset<T, QuizCreateArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quizzes.
     * @param {QuizCreateManyArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quiz = await prisma.quiz.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizCreateManyArgs>(args?: SelectSubset<T, QuizCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quizzes and returns the data saved in the database.
     * @param {QuizCreateManyAndReturnArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quiz = await prisma.quiz.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quizzes and only return the `id`
     * const quizWithIdOnly = await prisma.quiz.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quiz.
     * @param {QuizDeleteArgs} args - Arguments to delete one Quiz.
     * @example
     * // Delete one Quiz
     * const Quiz = await prisma.quiz.delete({
     *   where: {
     *     // ... filter to delete one Quiz
     *   }
     * })
     * 
     */
    delete<T extends QuizDeleteArgs>(args: SelectSubset<T, QuizDeleteArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quiz.
     * @param {QuizUpdateArgs} args - Arguments to update one Quiz.
     * @example
     * // Update one Quiz
     * const quiz = await prisma.quiz.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizUpdateArgs>(args: SelectSubset<T, QuizUpdateArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quizzes.
     * @param {QuizDeleteManyArgs} args - Arguments to filter Quizzes to delete.
     * @example
     * // Delete a few Quizzes
     * const { count } = await prisma.quiz.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizDeleteManyArgs>(args?: SelectSubset<T, QuizDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quizzes
     * const quiz = await prisma.quiz.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizUpdateManyArgs>(args: SelectSubset<T, QuizUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes and returns the data updated in the database.
     * @param {QuizUpdateManyAndReturnArgs} args - Arguments to update many Quizzes.
     * @example
     * // Update many Quizzes
     * const quiz = await prisma.quiz.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quizzes and only return the `id`
     * const quizWithIdOnly = await prisma.quiz.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quiz.
     * @param {QuizUpsertArgs} args - Arguments to update or create a Quiz.
     * @example
     * // Update or create a Quiz
     * const quiz = await prisma.quiz.upsert({
     *   create: {
     *     // ... data to create a Quiz
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quiz we want to update
     *   }
     * })
     */
    upsert<T extends QuizUpsertArgs>(args: SelectSubset<T, QuizUpsertArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCountArgs} args - Arguments to filter Quizzes to count.
     * @example
     * // Count the number of Quizzes
     * const count = await prisma.quiz.count({
     *   where: {
     *     // ... the filter for the Quizzes we want to count
     *   }
     * })
    **/
    count<T extends QuizCountArgs>(
      args?: Subset<T, QuizCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAggregateArgs>(args: Subset<T, QuizAggregateArgs>): Prisma.PrismaPromise<GetQuizAggregateType<T>>

    /**
     * Group by Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizGroupByArgs['orderBy'] }
        : { orderBy?: QuizGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quiz model
   */
  readonly fields: QuizFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quiz.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sections<T extends Quiz$sectionsArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    questionGroups<T extends Quiz$questionGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$questionGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    questions<T extends Quiz$questionsArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attempts<T extends Quiz$attemptsArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$attemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quiz model
   */
  interface QuizFieldRefs {
    readonly id: FieldRef<"Quiz", 'Int'>
    readonly lessonId: FieldRef<"Quiz", 'Int'>
    readonly title: FieldRef<"Quiz", 'String'>
    readonly description: FieldRef<"Quiz", 'String'>
    readonly timeLimitSec: FieldRef<"Quiz", 'Int'>
    readonly maxAttempts: FieldRef<"Quiz", 'Int'>
    readonly shuffleQuestions: FieldRef<"Quiz", 'Boolean'>
    readonly shuffleOptions: FieldRef<"Quiz", 'Boolean'>
    readonly gradingMethod: FieldRef<"Quiz", 'String'>
    readonly showAnswersAfter: FieldRef<"Quiz", 'String'>
    readonly dueAt: FieldRef<"Quiz", 'DateTime'>
    readonly isPublished: FieldRef<"Quiz", 'Boolean'>
    readonly totalPoints: FieldRef<"Quiz", 'Decimal'>
    readonly createdBy: FieldRef<"Quiz", 'Int'>
    readonly createdAt: FieldRef<"Quiz", 'DateTime'>
    readonly updatedAt: FieldRef<"Quiz", 'DateTime'>
    readonly deletedAt: FieldRef<"Quiz", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Quiz findUnique
   */
  export type QuizFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz findUniqueOrThrow
   */
  export type QuizFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz findFirst
   */
  export type QuizFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz findFirstOrThrow
   */
  export type QuizFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz findMany
   */
  export type QuizFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quizzes to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz create
   */
  export type QuizCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The data needed to create a Quiz.
     */
    data: XOR<QuizCreateInput, QuizUncheckedCreateInput>
  }

  /**
   * Quiz createMany
   */
  export type QuizCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quizzes.
     */
    data: QuizCreateManyInput | QuizCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quiz createManyAndReturn
   */
  export type QuizCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * The data used to create many Quizzes.
     */
    data: QuizCreateManyInput | QuizCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quiz update
   */
  export type QuizUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The data needed to update a Quiz.
     */
    data: XOR<QuizUpdateInput, QuizUncheckedUpdateInput>
    /**
     * Choose, which Quiz to update.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz updateMany
   */
  export type QuizUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quizzes.
     */
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyInput>
    /**
     * Filter which Quizzes to update
     */
    where?: QuizWhereInput
    /**
     * Limit how many Quizzes to update.
     */
    limit?: number
  }

  /**
   * Quiz updateManyAndReturn
   */
  export type QuizUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * The data used to update Quizzes.
     */
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyInput>
    /**
     * Filter which Quizzes to update
     */
    where?: QuizWhereInput
    /**
     * Limit how many Quizzes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quiz upsert
   */
  export type QuizUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The filter to search for the Quiz to update in case it exists.
     */
    where: QuizWhereUniqueInput
    /**
     * In case the Quiz found by the `where` argument doesn't exist, create a new Quiz with this data.
     */
    create: XOR<QuizCreateInput, QuizUncheckedCreateInput>
    /**
     * In case the Quiz was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizUpdateInput, QuizUncheckedUpdateInput>
  }

  /**
   * Quiz delete
   */
  export type QuizDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter which Quiz to delete.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz deleteMany
   */
  export type QuizDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quizzes to delete
     */
    where?: QuizWhereInput
    /**
     * Limit how many Quizzes to delete.
     */
    limit?: number
  }

  /**
   * Quiz.sections
   */
  export type Quiz$sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSection
     */
    select?: QuizSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSection
     */
    omit?: QuizSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSectionInclude<ExtArgs> | null
    where?: QuizSectionWhereInput
    orderBy?: QuizSectionOrderByWithRelationInput | QuizSectionOrderByWithRelationInput[]
    cursor?: QuizSectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizSectionScalarFieldEnum | QuizSectionScalarFieldEnum[]
  }

  /**
   * Quiz.questionGroups
   */
  export type Quiz$questionGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroup
     */
    select?: QuizQuestionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroup
     */
    omit?: QuizQuestionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupInclude<ExtArgs> | null
    where?: QuizQuestionGroupWhereInput
    orderBy?: QuizQuestionGroupOrderByWithRelationInput | QuizQuestionGroupOrderByWithRelationInput[]
    cursor?: QuizQuestionGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizQuestionGroupScalarFieldEnum | QuizQuestionGroupScalarFieldEnum[]
  }

  /**
   * Quiz.questions
   */
  export type Quiz$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    where?: QuizQuestionWhereInput
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    cursor?: QuizQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * Quiz.attempts
   */
  export type Quiz$attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    where?: QuizAttemptWhereInput
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    cursor?: QuizAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * Quiz without action
   */
  export type QuizDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
  }


  /**
   * Model QuizSection
   */

  export type AggregateQuizSection = {
    _count: QuizSectionCountAggregateOutputType | null
    _avg: QuizSectionAvgAggregateOutputType | null
    _sum: QuizSectionSumAggregateOutputType | null
    _min: QuizSectionMinAggregateOutputType | null
    _max: QuizSectionMaxAggregateOutputType | null
  }

  export type QuizSectionAvgAggregateOutputType = {
    id: number | null
    quizId: number | null
    orderIndex: number | null
  }

  export type QuizSectionSumAggregateOutputType = {
    id: number | null
    quizId: number | null
    orderIndex: number | null
  }

  export type QuizSectionMinAggregateOutputType = {
    id: number | null
    quizId: number | null
    title: string | null
    description: string | null
    orderIndex: number | null
  }

  export type QuizSectionMaxAggregateOutputType = {
    id: number | null
    quizId: number | null
    title: string | null
    description: string | null
    orderIndex: number | null
  }

  export type QuizSectionCountAggregateOutputType = {
    id: number
    quizId: number
    title: number
    description: number
    orderIndex: number
    _all: number
  }


  export type QuizSectionAvgAggregateInputType = {
    id?: true
    quizId?: true
    orderIndex?: true
  }

  export type QuizSectionSumAggregateInputType = {
    id?: true
    quizId?: true
    orderIndex?: true
  }

  export type QuizSectionMinAggregateInputType = {
    id?: true
    quizId?: true
    title?: true
    description?: true
    orderIndex?: true
  }

  export type QuizSectionMaxAggregateInputType = {
    id?: true
    quizId?: true
    title?: true
    description?: true
    orderIndex?: true
  }

  export type QuizSectionCountAggregateInputType = {
    id?: true
    quizId?: true
    title?: true
    description?: true
    orderIndex?: true
    _all?: true
  }

  export type QuizSectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizSection to aggregate.
     */
    where?: QuizSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizSections to fetch.
     */
    orderBy?: QuizSectionOrderByWithRelationInput | QuizSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizSections
    **/
    _count?: true | QuizSectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizSectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizSectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizSectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizSectionMaxAggregateInputType
  }

  export type GetQuizSectionAggregateType<T extends QuizSectionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizSection[P]>
      : GetScalarType<T[P], AggregateQuizSection[P]>
  }




  export type QuizSectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizSectionWhereInput
    orderBy?: QuizSectionOrderByWithAggregationInput | QuizSectionOrderByWithAggregationInput[]
    by: QuizSectionScalarFieldEnum[] | QuizSectionScalarFieldEnum
    having?: QuizSectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizSectionCountAggregateInputType | true
    _avg?: QuizSectionAvgAggregateInputType
    _sum?: QuizSectionSumAggregateInputType
    _min?: QuizSectionMinAggregateInputType
    _max?: QuizSectionMaxAggregateInputType
  }

  export type QuizSectionGroupByOutputType = {
    id: number
    quizId: number
    title: string
    description: string | null
    orderIndex: number
    _count: QuizSectionCountAggregateOutputType | null
    _avg: QuizSectionAvgAggregateOutputType | null
    _sum: QuizSectionSumAggregateOutputType | null
    _min: QuizSectionMinAggregateOutputType | null
    _max: QuizSectionMaxAggregateOutputType | null
  }

  type GetQuizSectionGroupByPayload<T extends QuizSectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizSectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizSectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizSectionGroupByOutputType[P]>
            : GetScalarType<T[P], QuizSectionGroupByOutputType[P]>
        }
      >
    >


  export type QuizSectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    title?: boolean
    description?: boolean
    orderIndex?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    questionGroups?: boolean | QuizSection$questionGroupsArgs<ExtArgs>
    questions?: boolean | QuizSection$questionsArgs<ExtArgs>
    _count?: boolean | QuizSectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizSection"]>

  export type QuizSectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    title?: boolean
    description?: boolean
    orderIndex?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizSection"]>

  export type QuizSectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    title?: boolean
    description?: boolean
    orderIndex?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizSection"]>

  export type QuizSectionSelectScalar = {
    id?: boolean
    quizId?: boolean
    title?: boolean
    description?: boolean
    orderIndex?: boolean
  }

  export type QuizSectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quizId" | "title" | "description" | "orderIndex", ExtArgs["result"]["quizSection"]>
  export type QuizSectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    questionGroups?: boolean | QuizSection$questionGroupsArgs<ExtArgs>
    questions?: boolean | QuizSection$questionsArgs<ExtArgs>
    _count?: boolean | QuizSectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizSectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }
  export type QuizSectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }

  export type $QuizSectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizSection"
    objects: {
      quiz: Prisma.$QuizPayload<ExtArgs>
      questionGroups: Prisma.$QuizQuestionGroupPayload<ExtArgs>[]
      questions: Prisma.$QuizQuestionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      quizId: number
      title: string
      description: string | null
      orderIndex: number
    }, ExtArgs["result"]["quizSection"]>
    composites: {}
  }

  type QuizSectionGetPayload<S extends boolean | null | undefined | QuizSectionDefaultArgs> = $Result.GetResult<Prisma.$QuizSectionPayload, S>

  type QuizSectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizSectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizSectionCountAggregateInputType | true
    }

  export interface QuizSectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizSection'], meta: { name: 'QuizSection' } }
    /**
     * Find zero or one QuizSection that matches the filter.
     * @param {QuizSectionFindUniqueArgs} args - Arguments to find a QuizSection
     * @example
     * // Get one QuizSection
     * const quizSection = await prisma.quizSection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizSectionFindUniqueArgs>(args: SelectSubset<T, QuizSectionFindUniqueArgs<ExtArgs>>): Prisma__QuizSectionClient<$Result.GetResult<Prisma.$QuizSectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizSection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizSectionFindUniqueOrThrowArgs} args - Arguments to find a QuizSection
     * @example
     * // Get one QuizSection
     * const quizSection = await prisma.quizSection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizSectionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizSectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizSectionClient<$Result.GetResult<Prisma.$QuizSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizSection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSectionFindFirstArgs} args - Arguments to find a QuizSection
     * @example
     * // Get one QuizSection
     * const quizSection = await prisma.quizSection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizSectionFindFirstArgs>(args?: SelectSubset<T, QuizSectionFindFirstArgs<ExtArgs>>): Prisma__QuizSectionClient<$Result.GetResult<Prisma.$QuizSectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizSection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSectionFindFirstOrThrowArgs} args - Arguments to find a QuizSection
     * @example
     * // Get one QuizSection
     * const quizSection = await prisma.quizSection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizSectionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizSectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizSectionClient<$Result.GetResult<Prisma.$QuizSectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizSections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizSections
     * const quizSections = await prisma.quizSection.findMany()
     * 
     * // Get first 10 QuizSections
     * const quizSections = await prisma.quizSection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizSectionWithIdOnly = await prisma.quizSection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizSectionFindManyArgs>(args?: SelectSubset<T, QuizSectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizSection.
     * @param {QuizSectionCreateArgs} args - Arguments to create a QuizSection.
     * @example
     * // Create one QuizSection
     * const QuizSection = await prisma.quizSection.create({
     *   data: {
     *     // ... data to create a QuizSection
     *   }
     * })
     * 
     */
    create<T extends QuizSectionCreateArgs>(args: SelectSubset<T, QuizSectionCreateArgs<ExtArgs>>): Prisma__QuizSectionClient<$Result.GetResult<Prisma.$QuizSectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizSections.
     * @param {QuizSectionCreateManyArgs} args - Arguments to create many QuizSections.
     * @example
     * // Create many QuizSections
     * const quizSection = await prisma.quizSection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizSectionCreateManyArgs>(args?: SelectSubset<T, QuizSectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizSections and returns the data saved in the database.
     * @param {QuizSectionCreateManyAndReturnArgs} args - Arguments to create many QuizSections.
     * @example
     * // Create many QuizSections
     * const quizSection = await prisma.quizSection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizSections and only return the `id`
     * const quizSectionWithIdOnly = await prisma.quizSection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizSectionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizSectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizSectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizSection.
     * @param {QuizSectionDeleteArgs} args - Arguments to delete one QuizSection.
     * @example
     * // Delete one QuizSection
     * const QuizSection = await prisma.quizSection.delete({
     *   where: {
     *     // ... filter to delete one QuizSection
     *   }
     * })
     * 
     */
    delete<T extends QuizSectionDeleteArgs>(args: SelectSubset<T, QuizSectionDeleteArgs<ExtArgs>>): Prisma__QuizSectionClient<$Result.GetResult<Prisma.$QuizSectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizSection.
     * @param {QuizSectionUpdateArgs} args - Arguments to update one QuizSection.
     * @example
     * // Update one QuizSection
     * const quizSection = await prisma.quizSection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizSectionUpdateArgs>(args: SelectSubset<T, QuizSectionUpdateArgs<ExtArgs>>): Prisma__QuizSectionClient<$Result.GetResult<Prisma.$QuizSectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizSections.
     * @param {QuizSectionDeleteManyArgs} args - Arguments to filter QuizSections to delete.
     * @example
     * // Delete a few QuizSections
     * const { count } = await prisma.quizSection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizSectionDeleteManyArgs>(args?: SelectSubset<T, QuizSectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizSections
     * const quizSection = await prisma.quizSection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizSectionUpdateManyArgs>(args: SelectSubset<T, QuizSectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizSections and returns the data updated in the database.
     * @param {QuizSectionUpdateManyAndReturnArgs} args - Arguments to update many QuizSections.
     * @example
     * // Update many QuizSections
     * const quizSection = await prisma.quizSection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizSections and only return the `id`
     * const quizSectionWithIdOnly = await prisma.quizSection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizSectionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizSectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizSectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizSection.
     * @param {QuizSectionUpsertArgs} args - Arguments to update or create a QuizSection.
     * @example
     * // Update or create a QuizSection
     * const quizSection = await prisma.quizSection.upsert({
     *   create: {
     *     // ... data to create a QuizSection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizSection we want to update
     *   }
     * })
     */
    upsert<T extends QuizSectionUpsertArgs>(args: SelectSubset<T, QuizSectionUpsertArgs<ExtArgs>>): Prisma__QuizSectionClient<$Result.GetResult<Prisma.$QuizSectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSectionCountArgs} args - Arguments to filter QuizSections to count.
     * @example
     * // Count the number of QuizSections
     * const count = await prisma.quizSection.count({
     *   where: {
     *     // ... the filter for the QuizSections we want to count
     *   }
     * })
    **/
    count<T extends QuizSectionCountArgs>(
      args?: Subset<T, QuizSectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizSectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizSectionAggregateArgs>(args: Subset<T, QuizSectionAggregateArgs>): Prisma.PrismaPromise<GetQuizSectionAggregateType<T>>

    /**
     * Group by QuizSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizSectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizSectionGroupByArgs['orderBy'] }
        : { orderBy?: QuizSectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizSectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizSection model
   */
  readonly fields: QuizSectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizSection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizSectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quiz<T extends QuizDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizDefaultArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    questionGroups<T extends QuizSection$questionGroupsArgs<ExtArgs> = {}>(args?: Subset<T, QuizSection$questionGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    questions<T extends QuizSection$questionsArgs<ExtArgs> = {}>(args?: Subset<T, QuizSection$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizSection model
   */
  interface QuizSectionFieldRefs {
    readonly id: FieldRef<"QuizSection", 'Int'>
    readonly quizId: FieldRef<"QuizSection", 'Int'>
    readonly title: FieldRef<"QuizSection", 'String'>
    readonly description: FieldRef<"QuizSection", 'String'>
    readonly orderIndex: FieldRef<"QuizSection", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * QuizSection findUnique
   */
  export type QuizSectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSection
     */
    select?: QuizSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSection
     */
    omit?: QuizSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSectionInclude<ExtArgs> | null
    /**
     * Filter, which QuizSection to fetch.
     */
    where: QuizSectionWhereUniqueInput
  }

  /**
   * QuizSection findUniqueOrThrow
   */
  export type QuizSectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSection
     */
    select?: QuizSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSection
     */
    omit?: QuizSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSectionInclude<ExtArgs> | null
    /**
     * Filter, which QuizSection to fetch.
     */
    where: QuizSectionWhereUniqueInput
  }

  /**
   * QuizSection findFirst
   */
  export type QuizSectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSection
     */
    select?: QuizSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSection
     */
    omit?: QuizSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSectionInclude<ExtArgs> | null
    /**
     * Filter, which QuizSection to fetch.
     */
    where?: QuizSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizSections to fetch.
     */
    orderBy?: QuizSectionOrderByWithRelationInput | QuizSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizSections.
     */
    cursor?: QuizSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizSections.
     */
    distinct?: QuizSectionScalarFieldEnum | QuizSectionScalarFieldEnum[]
  }

  /**
   * QuizSection findFirstOrThrow
   */
  export type QuizSectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSection
     */
    select?: QuizSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSection
     */
    omit?: QuizSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSectionInclude<ExtArgs> | null
    /**
     * Filter, which QuizSection to fetch.
     */
    where?: QuizSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizSections to fetch.
     */
    orderBy?: QuizSectionOrderByWithRelationInput | QuizSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizSections.
     */
    cursor?: QuizSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizSections.
     */
    distinct?: QuizSectionScalarFieldEnum | QuizSectionScalarFieldEnum[]
  }

  /**
   * QuizSection findMany
   */
  export type QuizSectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSection
     */
    select?: QuizSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSection
     */
    omit?: QuizSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSectionInclude<ExtArgs> | null
    /**
     * Filter, which QuizSections to fetch.
     */
    where?: QuizSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizSections to fetch.
     */
    orderBy?: QuizSectionOrderByWithRelationInput | QuizSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizSections.
     */
    cursor?: QuizSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizSections.
     */
    skip?: number
    distinct?: QuizSectionScalarFieldEnum | QuizSectionScalarFieldEnum[]
  }

  /**
   * QuizSection create
   */
  export type QuizSectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSection
     */
    select?: QuizSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSection
     */
    omit?: QuizSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSectionInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizSection.
     */
    data: XOR<QuizSectionCreateInput, QuizSectionUncheckedCreateInput>
  }

  /**
   * QuizSection createMany
   */
  export type QuizSectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizSections.
     */
    data: QuizSectionCreateManyInput | QuizSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizSection createManyAndReturn
   */
  export type QuizSectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSection
     */
    select?: QuizSectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSection
     */
    omit?: QuizSectionOmit<ExtArgs> | null
    /**
     * The data used to create many QuizSections.
     */
    data: QuizSectionCreateManyInput | QuizSectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizSection update
   */
  export type QuizSectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSection
     */
    select?: QuizSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSection
     */
    omit?: QuizSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSectionInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizSection.
     */
    data: XOR<QuizSectionUpdateInput, QuizSectionUncheckedUpdateInput>
    /**
     * Choose, which QuizSection to update.
     */
    where: QuizSectionWhereUniqueInput
  }

  /**
   * QuizSection updateMany
   */
  export type QuizSectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizSections.
     */
    data: XOR<QuizSectionUpdateManyMutationInput, QuizSectionUncheckedUpdateManyInput>
    /**
     * Filter which QuizSections to update
     */
    where?: QuizSectionWhereInput
    /**
     * Limit how many QuizSections to update.
     */
    limit?: number
  }

  /**
   * QuizSection updateManyAndReturn
   */
  export type QuizSectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSection
     */
    select?: QuizSectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSection
     */
    omit?: QuizSectionOmit<ExtArgs> | null
    /**
     * The data used to update QuizSections.
     */
    data: XOR<QuizSectionUpdateManyMutationInput, QuizSectionUncheckedUpdateManyInput>
    /**
     * Filter which QuizSections to update
     */
    where?: QuizSectionWhereInput
    /**
     * Limit how many QuizSections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizSection upsert
   */
  export type QuizSectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSection
     */
    select?: QuizSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSection
     */
    omit?: QuizSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSectionInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizSection to update in case it exists.
     */
    where: QuizSectionWhereUniqueInput
    /**
     * In case the QuizSection found by the `where` argument doesn't exist, create a new QuizSection with this data.
     */
    create: XOR<QuizSectionCreateInput, QuizSectionUncheckedCreateInput>
    /**
     * In case the QuizSection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizSectionUpdateInput, QuizSectionUncheckedUpdateInput>
  }

  /**
   * QuizSection delete
   */
  export type QuizSectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSection
     */
    select?: QuizSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSection
     */
    omit?: QuizSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSectionInclude<ExtArgs> | null
    /**
     * Filter which QuizSection to delete.
     */
    where: QuizSectionWhereUniqueInput
  }

  /**
   * QuizSection deleteMany
   */
  export type QuizSectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizSections to delete
     */
    where?: QuizSectionWhereInput
    /**
     * Limit how many QuizSections to delete.
     */
    limit?: number
  }

  /**
   * QuizSection.questionGroups
   */
  export type QuizSection$questionGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroup
     */
    select?: QuizQuestionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroup
     */
    omit?: QuizQuestionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupInclude<ExtArgs> | null
    where?: QuizQuestionGroupWhereInput
    orderBy?: QuizQuestionGroupOrderByWithRelationInput | QuizQuestionGroupOrderByWithRelationInput[]
    cursor?: QuizQuestionGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizQuestionGroupScalarFieldEnum | QuizQuestionGroupScalarFieldEnum[]
  }

  /**
   * QuizSection.questions
   */
  export type QuizSection$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    where?: QuizQuestionWhereInput
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    cursor?: QuizQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizSection without action
   */
  export type QuizSectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSection
     */
    select?: QuizSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSection
     */
    omit?: QuizSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSectionInclude<ExtArgs> | null
  }


  /**
   * Model QuizQuestionGroup
   */

  export type AggregateQuizQuestionGroup = {
    _count: QuizQuestionGroupCountAggregateOutputType | null
    _avg: QuizQuestionGroupAvgAggregateOutputType | null
    _sum: QuizQuestionGroupSumAggregateOutputType | null
    _min: QuizQuestionGroupMinAggregateOutputType | null
    _max: QuizQuestionGroupMaxAggregateOutputType | null
  }

  export type QuizQuestionGroupAvgAggregateOutputType = {
    id: number | null
    quizId: number | null
    sectionId: number | null
    orderIndex: number | null
  }

  export type QuizQuestionGroupSumAggregateOutputType = {
    id: number | null
    quizId: number | null
    sectionId: number | null
    orderIndex: number | null
  }

  export type QuizQuestionGroupMinAggregateOutputType = {
    id: number | null
    quizId: number | null
    sectionId: number | null
    title: string | null
    introText: string | null
    orderIndex: number | null
    shuffleInside: boolean | null
    pointsPolicy: string | null
    createdAt: Date | null
  }

  export type QuizQuestionGroupMaxAggregateOutputType = {
    id: number | null
    quizId: number | null
    sectionId: number | null
    title: string | null
    introText: string | null
    orderIndex: number | null
    shuffleInside: boolean | null
    pointsPolicy: string | null
    createdAt: Date | null
  }

  export type QuizQuestionGroupCountAggregateOutputType = {
    id: number
    quizId: number
    sectionId: number
    title: number
    introText: number
    orderIndex: number
    shuffleInside: number
    pointsPolicy: number
    createdAt: number
    _all: number
  }


  export type QuizQuestionGroupAvgAggregateInputType = {
    id?: true
    quizId?: true
    sectionId?: true
    orderIndex?: true
  }

  export type QuizQuestionGroupSumAggregateInputType = {
    id?: true
    quizId?: true
    sectionId?: true
    orderIndex?: true
  }

  export type QuizQuestionGroupMinAggregateInputType = {
    id?: true
    quizId?: true
    sectionId?: true
    title?: true
    introText?: true
    orderIndex?: true
    shuffleInside?: true
    pointsPolicy?: true
    createdAt?: true
  }

  export type QuizQuestionGroupMaxAggregateInputType = {
    id?: true
    quizId?: true
    sectionId?: true
    title?: true
    introText?: true
    orderIndex?: true
    shuffleInside?: true
    pointsPolicy?: true
    createdAt?: true
  }

  export type QuizQuestionGroupCountAggregateInputType = {
    id?: true
    quizId?: true
    sectionId?: true
    title?: true
    introText?: true
    orderIndex?: true
    shuffleInside?: true
    pointsPolicy?: true
    createdAt?: true
    _all?: true
  }

  export type QuizQuestionGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestionGroup to aggregate.
     */
    where?: QuizQuestionGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestionGroups to fetch.
     */
    orderBy?: QuizQuestionGroupOrderByWithRelationInput | QuizQuestionGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizQuestionGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestionGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestionGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizQuestionGroups
    **/
    _count?: true | QuizQuestionGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizQuestionGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizQuestionGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizQuestionGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizQuestionGroupMaxAggregateInputType
  }

  export type GetQuizQuestionGroupAggregateType<T extends QuizQuestionGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizQuestionGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizQuestionGroup[P]>
      : GetScalarType<T[P], AggregateQuizQuestionGroup[P]>
  }




  export type QuizQuestionGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionGroupWhereInput
    orderBy?: QuizQuestionGroupOrderByWithAggregationInput | QuizQuestionGroupOrderByWithAggregationInput[]
    by: QuizQuestionGroupScalarFieldEnum[] | QuizQuestionGroupScalarFieldEnum
    having?: QuizQuestionGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizQuestionGroupCountAggregateInputType | true
    _avg?: QuizQuestionGroupAvgAggregateInputType
    _sum?: QuizQuestionGroupSumAggregateInputType
    _min?: QuizQuestionGroupMinAggregateInputType
    _max?: QuizQuestionGroupMaxAggregateInputType
  }

  export type QuizQuestionGroupGroupByOutputType = {
    id: number
    quizId: number
    sectionId: number | null
    title: string | null
    introText: string | null
    orderIndex: number
    shuffleInside: boolean
    pointsPolicy: string
    createdAt: Date
    _count: QuizQuestionGroupCountAggregateOutputType | null
    _avg: QuizQuestionGroupAvgAggregateOutputType | null
    _sum: QuizQuestionGroupSumAggregateOutputType | null
    _min: QuizQuestionGroupMinAggregateOutputType | null
    _max: QuizQuestionGroupMaxAggregateOutputType | null
  }

  type GetQuizQuestionGroupGroupByPayload<T extends QuizQuestionGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizQuestionGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizQuestionGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizQuestionGroupGroupByOutputType[P]>
            : GetScalarType<T[P], QuizQuestionGroupGroupByOutputType[P]>
        }
      >
    >


  export type QuizQuestionGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    sectionId?: boolean
    title?: boolean
    introText?: boolean
    orderIndex?: boolean
    shuffleInside?: boolean
    pointsPolicy?: boolean
    createdAt?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    section?: boolean | QuizQuestionGroup$sectionArgs<ExtArgs>
    questions?: boolean | QuizQuestionGroup$questionsArgs<ExtArgs>
    medias?: boolean | QuizQuestionGroup$mediasArgs<ExtArgs>
    _count?: boolean | QuizQuestionGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestionGroup"]>

  export type QuizQuestionGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    sectionId?: boolean
    title?: boolean
    introText?: boolean
    orderIndex?: boolean
    shuffleInside?: boolean
    pointsPolicy?: boolean
    createdAt?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    section?: boolean | QuizQuestionGroup$sectionArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestionGroup"]>

  export type QuizQuestionGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    sectionId?: boolean
    title?: boolean
    introText?: boolean
    orderIndex?: boolean
    shuffleInside?: boolean
    pointsPolicy?: boolean
    createdAt?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    section?: boolean | QuizQuestionGroup$sectionArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestionGroup"]>

  export type QuizQuestionGroupSelectScalar = {
    id?: boolean
    quizId?: boolean
    sectionId?: boolean
    title?: boolean
    introText?: boolean
    orderIndex?: boolean
    shuffleInside?: boolean
    pointsPolicy?: boolean
    createdAt?: boolean
  }

  export type QuizQuestionGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quizId" | "sectionId" | "title" | "introText" | "orderIndex" | "shuffleInside" | "pointsPolicy" | "createdAt", ExtArgs["result"]["quizQuestionGroup"]>
  export type QuizQuestionGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    section?: boolean | QuizQuestionGroup$sectionArgs<ExtArgs>
    questions?: boolean | QuizQuestionGroup$questionsArgs<ExtArgs>
    medias?: boolean | QuizQuestionGroup$mediasArgs<ExtArgs>
    _count?: boolean | QuizQuestionGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizQuestionGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    section?: boolean | QuizQuestionGroup$sectionArgs<ExtArgs>
  }
  export type QuizQuestionGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    section?: boolean | QuizQuestionGroup$sectionArgs<ExtArgs>
  }

  export type $QuizQuestionGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizQuestionGroup"
    objects: {
      quiz: Prisma.$QuizPayload<ExtArgs>
      section: Prisma.$QuizSectionPayload<ExtArgs> | null
      questions: Prisma.$QuizQuestionPayload<ExtArgs>[]
      medias: Prisma.$QuizQuestionGroupMediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      quizId: number
      sectionId: number | null
      title: string | null
      introText: string | null
      orderIndex: number
      shuffleInside: boolean
      pointsPolicy: string
      createdAt: Date
    }, ExtArgs["result"]["quizQuestionGroup"]>
    composites: {}
  }

  type QuizQuestionGroupGetPayload<S extends boolean | null | undefined | QuizQuestionGroupDefaultArgs> = $Result.GetResult<Prisma.$QuizQuestionGroupPayload, S>

  type QuizQuestionGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizQuestionGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizQuestionGroupCountAggregateInputType | true
    }

  export interface QuizQuestionGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizQuestionGroup'], meta: { name: 'QuizQuestionGroup' } }
    /**
     * Find zero or one QuizQuestionGroup that matches the filter.
     * @param {QuizQuestionGroupFindUniqueArgs} args - Arguments to find a QuizQuestionGroup
     * @example
     * // Get one QuizQuestionGroup
     * const quizQuestionGroup = await prisma.quizQuestionGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizQuestionGroupFindUniqueArgs>(args: SelectSubset<T, QuizQuestionGroupFindUniqueArgs<ExtArgs>>): Prisma__QuizQuestionGroupClient<$Result.GetResult<Prisma.$QuizQuestionGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizQuestionGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizQuestionGroupFindUniqueOrThrowArgs} args - Arguments to find a QuizQuestionGroup
     * @example
     * // Get one QuizQuestionGroup
     * const quizQuestionGroup = await prisma.quizQuestionGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizQuestionGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizQuestionGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionGroupClient<$Result.GetResult<Prisma.$QuizQuestionGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizQuestionGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionGroupFindFirstArgs} args - Arguments to find a QuizQuestionGroup
     * @example
     * // Get one QuizQuestionGroup
     * const quizQuestionGroup = await prisma.quizQuestionGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizQuestionGroupFindFirstArgs>(args?: SelectSubset<T, QuizQuestionGroupFindFirstArgs<ExtArgs>>): Prisma__QuizQuestionGroupClient<$Result.GetResult<Prisma.$QuizQuestionGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizQuestionGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionGroupFindFirstOrThrowArgs} args - Arguments to find a QuizQuestionGroup
     * @example
     * // Get one QuizQuestionGroup
     * const quizQuestionGroup = await prisma.quizQuestionGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizQuestionGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizQuestionGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionGroupClient<$Result.GetResult<Prisma.$QuizQuestionGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizQuestionGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizQuestionGroups
     * const quizQuestionGroups = await prisma.quizQuestionGroup.findMany()
     * 
     * // Get first 10 QuizQuestionGroups
     * const quizQuestionGroups = await prisma.quizQuestionGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizQuestionGroupWithIdOnly = await prisma.quizQuestionGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizQuestionGroupFindManyArgs>(args?: SelectSubset<T, QuizQuestionGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizQuestionGroup.
     * @param {QuizQuestionGroupCreateArgs} args - Arguments to create a QuizQuestionGroup.
     * @example
     * // Create one QuizQuestionGroup
     * const QuizQuestionGroup = await prisma.quizQuestionGroup.create({
     *   data: {
     *     // ... data to create a QuizQuestionGroup
     *   }
     * })
     * 
     */
    create<T extends QuizQuestionGroupCreateArgs>(args: SelectSubset<T, QuizQuestionGroupCreateArgs<ExtArgs>>): Prisma__QuizQuestionGroupClient<$Result.GetResult<Prisma.$QuizQuestionGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizQuestionGroups.
     * @param {QuizQuestionGroupCreateManyArgs} args - Arguments to create many QuizQuestionGroups.
     * @example
     * // Create many QuizQuestionGroups
     * const quizQuestionGroup = await prisma.quizQuestionGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizQuestionGroupCreateManyArgs>(args?: SelectSubset<T, QuizQuestionGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizQuestionGroups and returns the data saved in the database.
     * @param {QuizQuestionGroupCreateManyAndReturnArgs} args - Arguments to create many QuizQuestionGroups.
     * @example
     * // Create many QuizQuestionGroups
     * const quizQuestionGroup = await prisma.quizQuestionGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizQuestionGroups and only return the `id`
     * const quizQuestionGroupWithIdOnly = await prisma.quizQuestionGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizQuestionGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizQuestionGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizQuestionGroup.
     * @param {QuizQuestionGroupDeleteArgs} args - Arguments to delete one QuizQuestionGroup.
     * @example
     * // Delete one QuizQuestionGroup
     * const QuizQuestionGroup = await prisma.quizQuestionGroup.delete({
     *   where: {
     *     // ... filter to delete one QuizQuestionGroup
     *   }
     * })
     * 
     */
    delete<T extends QuizQuestionGroupDeleteArgs>(args: SelectSubset<T, QuizQuestionGroupDeleteArgs<ExtArgs>>): Prisma__QuizQuestionGroupClient<$Result.GetResult<Prisma.$QuizQuestionGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizQuestionGroup.
     * @param {QuizQuestionGroupUpdateArgs} args - Arguments to update one QuizQuestionGroup.
     * @example
     * // Update one QuizQuestionGroup
     * const quizQuestionGroup = await prisma.quizQuestionGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizQuestionGroupUpdateArgs>(args: SelectSubset<T, QuizQuestionGroupUpdateArgs<ExtArgs>>): Prisma__QuizQuestionGroupClient<$Result.GetResult<Prisma.$QuizQuestionGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizQuestionGroups.
     * @param {QuizQuestionGroupDeleteManyArgs} args - Arguments to filter QuizQuestionGroups to delete.
     * @example
     * // Delete a few QuizQuestionGroups
     * const { count } = await prisma.quizQuestionGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizQuestionGroupDeleteManyArgs>(args?: SelectSubset<T, QuizQuestionGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestionGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizQuestionGroups
     * const quizQuestionGroup = await prisma.quizQuestionGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizQuestionGroupUpdateManyArgs>(args: SelectSubset<T, QuizQuestionGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestionGroups and returns the data updated in the database.
     * @param {QuizQuestionGroupUpdateManyAndReturnArgs} args - Arguments to update many QuizQuestionGroups.
     * @example
     * // Update many QuizQuestionGroups
     * const quizQuestionGroup = await prisma.quizQuestionGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizQuestionGroups and only return the `id`
     * const quizQuestionGroupWithIdOnly = await prisma.quizQuestionGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizQuestionGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizQuestionGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizQuestionGroup.
     * @param {QuizQuestionGroupUpsertArgs} args - Arguments to update or create a QuizQuestionGroup.
     * @example
     * // Update or create a QuizQuestionGroup
     * const quizQuestionGroup = await prisma.quizQuestionGroup.upsert({
     *   create: {
     *     // ... data to create a QuizQuestionGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizQuestionGroup we want to update
     *   }
     * })
     */
    upsert<T extends QuizQuestionGroupUpsertArgs>(args: SelectSubset<T, QuizQuestionGroupUpsertArgs<ExtArgs>>): Prisma__QuizQuestionGroupClient<$Result.GetResult<Prisma.$QuizQuestionGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizQuestionGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionGroupCountArgs} args - Arguments to filter QuizQuestionGroups to count.
     * @example
     * // Count the number of QuizQuestionGroups
     * const count = await prisma.quizQuestionGroup.count({
     *   where: {
     *     // ... the filter for the QuizQuestionGroups we want to count
     *   }
     * })
    **/
    count<T extends QuizQuestionGroupCountArgs>(
      args?: Subset<T, QuizQuestionGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizQuestionGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizQuestionGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizQuestionGroupAggregateArgs>(args: Subset<T, QuizQuestionGroupAggregateArgs>): Prisma.PrismaPromise<GetQuizQuestionGroupAggregateType<T>>

    /**
     * Group by QuizQuestionGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizQuestionGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizQuestionGroupGroupByArgs['orderBy'] }
        : { orderBy?: QuizQuestionGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizQuestionGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizQuestionGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizQuestionGroup model
   */
  readonly fields: QuizQuestionGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizQuestionGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizQuestionGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quiz<T extends QuizDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizDefaultArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    section<T extends QuizQuestionGroup$sectionArgs<ExtArgs> = {}>(args?: Subset<T, QuizQuestionGroup$sectionArgs<ExtArgs>>): Prisma__QuizSectionClient<$Result.GetResult<Prisma.$QuizSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    questions<T extends QuizQuestionGroup$questionsArgs<ExtArgs> = {}>(args?: Subset<T, QuizQuestionGroup$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medias<T extends QuizQuestionGroup$mediasArgs<ExtArgs> = {}>(args?: Subset<T, QuizQuestionGroup$mediasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionGroupMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizQuestionGroup model
   */
  interface QuizQuestionGroupFieldRefs {
    readonly id: FieldRef<"QuizQuestionGroup", 'Int'>
    readonly quizId: FieldRef<"QuizQuestionGroup", 'Int'>
    readonly sectionId: FieldRef<"QuizQuestionGroup", 'Int'>
    readonly title: FieldRef<"QuizQuestionGroup", 'String'>
    readonly introText: FieldRef<"QuizQuestionGroup", 'String'>
    readonly orderIndex: FieldRef<"QuizQuestionGroup", 'Int'>
    readonly shuffleInside: FieldRef<"QuizQuestionGroup", 'Boolean'>
    readonly pointsPolicy: FieldRef<"QuizQuestionGroup", 'String'>
    readonly createdAt: FieldRef<"QuizQuestionGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizQuestionGroup findUnique
   */
  export type QuizQuestionGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroup
     */
    select?: QuizQuestionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroup
     */
    omit?: QuizQuestionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestionGroup to fetch.
     */
    where: QuizQuestionGroupWhereUniqueInput
  }

  /**
   * QuizQuestionGroup findUniqueOrThrow
   */
  export type QuizQuestionGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroup
     */
    select?: QuizQuestionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroup
     */
    omit?: QuizQuestionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestionGroup to fetch.
     */
    where: QuizQuestionGroupWhereUniqueInput
  }

  /**
   * QuizQuestionGroup findFirst
   */
  export type QuizQuestionGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroup
     */
    select?: QuizQuestionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroup
     */
    omit?: QuizQuestionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestionGroup to fetch.
     */
    where?: QuizQuestionGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestionGroups to fetch.
     */
    orderBy?: QuizQuestionGroupOrderByWithRelationInput | QuizQuestionGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestionGroups.
     */
    cursor?: QuizQuestionGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestionGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestionGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestionGroups.
     */
    distinct?: QuizQuestionGroupScalarFieldEnum | QuizQuestionGroupScalarFieldEnum[]
  }

  /**
   * QuizQuestionGroup findFirstOrThrow
   */
  export type QuizQuestionGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroup
     */
    select?: QuizQuestionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroup
     */
    omit?: QuizQuestionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestionGroup to fetch.
     */
    where?: QuizQuestionGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestionGroups to fetch.
     */
    orderBy?: QuizQuestionGroupOrderByWithRelationInput | QuizQuestionGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestionGroups.
     */
    cursor?: QuizQuestionGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestionGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestionGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestionGroups.
     */
    distinct?: QuizQuestionGroupScalarFieldEnum | QuizQuestionGroupScalarFieldEnum[]
  }

  /**
   * QuizQuestionGroup findMany
   */
  export type QuizQuestionGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroup
     */
    select?: QuizQuestionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroup
     */
    omit?: QuizQuestionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestionGroups to fetch.
     */
    where?: QuizQuestionGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestionGroups to fetch.
     */
    orderBy?: QuizQuestionGroupOrderByWithRelationInput | QuizQuestionGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizQuestionGroups.
     */
    cursor?: QuizQuestionGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestionGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestionGroups.
     */
    skip?: number
    distinct?: QuizQuestionGroupScalarFieldEnum | QuizQuestionGroupScalarFieldEnum[]
  }

  /**
   * QuizQuestionGroup create
   */
  export type QuizQuestionGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroup
     */
    select?: QuizQuestionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroup
     */
    omit?: QuizQuestionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizQuestionGroup.
     */
    data: XOR<QuizQuestionGroupCreateInput, QuizQuestionGroupUncheckedCreateInput>
  }

  /**
   * QuizQuestionGroup createMany
   */
  export type QuizQuestionGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizQuestionGroups.
     */
    data: QuizQuestionGroupCreateManyInput | QuizQuestionGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizQuestionGroup createManyAndReturn
   */
  export type QuizQuestionGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroup
     */
    select?: QuizQuestionGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroup
     */
    omit?: QuizQuestionGroupOmit<ExtArgs> | null
    /**
     * The data used to create many QuizQuestionGroups.
     */
    data: QuizQuestionGroupCreateManyInput | QuizQuestionGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizQuestionGroup update
   */
  export type QuizQuestionGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroup
     */
    select?: QuizQuestionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroup
     */
    omit?: QuizQuestionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizQuestionGroup.
     */
    data: XOR<QuizQuestionGroupUpdateInput, QuizQuestionGroupUncheckedUpdateInput>
    /**
     * Choose, which QuizQuestionGroup to update.
     */
    where: QuizQuestionGroupWhereUniqueInput
  }

  /**
   * QuizQuestionGroup updateMany
   */
  export type QuizQuestionGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizQuestionGroups.
     */
    data: XOR<QuizQuestionGroupUpdateManyMutationInput, QuizQuestionGroupUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestionGroups to update
     */
    where?: QuizQuestionGroupWhereInput
    /**
     * Limit how many QuizQuestionGroups to update.
     */
    limit?: number
  }

  /**
   * QuizQuestionGroup updateManyAndReturn
   */
  export type QuizQuestionGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroup
     */
    select?: QuizQuestionGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroup
     */
    omit?: QuizQuestionGroupOmit<ExtArgs> | null
    /**
     * The data used to update QuizQuestionGroups.
     */
    data: XOR<QuizQuestionGroupUpdateManyMutationInput, QuizQuestionGroupUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestionGroups to update
     */
    where?: QuizQuestionGroupWhereInput
    /**
     * Limit how many QuizQuestionGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizQuestionGroup upsert
   */
  export type QuizQuestionGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroup
     */
    select?: QuizQuestionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroup
     */
    omit?: QuizQuestionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizQuestionGroup to update in case it exists.
     */
    where: QuizQuestionGroupWhereUniqueInput
    /**
     * In case the QuizQuestionGroup found by the `where` argument doesn't exist, create a new QuizQuestionGroup with this data.
     */
    create: XOR<QuizQuestionGroupCreateInput, QuizQuestionGroupUncheckedCreateInput>
    /**
     * In case the QuizQuestionGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizQuestionGroupUpdateInput, QuizQuestionGroupUncheckedUpdateInput>
  }

  /**
   * QuizQuestionGroup delete
   */
  export type QuizQuestionGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroup
     */
    select?: QuizQuestionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroup
     */
    omit?: QuizQuestionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupInclude<ExtArgs> | null
    /**
     * Filter which QuizQuestionGroup to delete.
     */
    where: QuizQuestionGroupWhereUniqueInput
  }

  /**
   * QuizQuestionGroup deleteMany
   */
  export type QuizQuestionGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestionGroups to delete
     */
    where?: QuizQuestionGroupWhereInput
    /**
     * Limit how many QuizQuestionGroups to delete.
     */
    limit?: number
  }

  /**
   * QuizQuestionGroup.section
   */
  export type QuizQuestionGroup$sectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSection
     */
    select?: QuizSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSection
     */
    omit?: QuizSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSectionInclude<ExtArgs> | null
    where?: QuizSectionWhereInput
  }

  /**
   * QuizQuestionGroup.questions
   */
  export type QuizQuestionGroup$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    where?: QuizQuestionWhereInput
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    cursor?: QuizQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestionGroup.medias
   */
  export type QuizQuestionGroup$mediasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroupMedia
     */
    select?: QuizQuestionGroupMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroupMedia
     */
    omit?: QuizQuestionGroupMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupMediaInclude<ExtArgs> | null
    where?: QuizQuestionGroupMediaWhereInput
    orderBy?: QuizQuestionGroupMediaOrderByWithRelationInput | QuizQuestionGroupMediaOrderByWithRelationInput[]
    cursor?: QuizQuestionGroupMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizQuestionGroupMediaScalarFieldEnum | QuizQuestionGroupMediaScalarFieldEnum[]
  }

  /**
   * QuizQuestionGroup without action
   */
  export type QuizQuestionGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroup
     */
    select?: QuizQuestionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroup
     */
    omit?: QuizQuestionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupInclude<ExtArgs> | null
  }


  /**
   * Model QuizQuestion
   */

  export type AggregateQuizQuestion = {
    _count: QuizQuestionCountAggregateOutputType | null
    _avg: QuizQuestionAvgAggregateOutputType | null
    _sum: QuizQuestionSumAggregateOutputType | null
    _min: QuizQuestionMinAggregateOutputType | null
    _max: QuizQuestionMaxAggregateOutputType | null
  }

  export type QuizQuestionAvgAggregateOutputType = {
    id: number | null
    quizId: number | null
    sectionId: number | null
    groupId: number | null
    points: Decimal | null
    orderIndex: number | null
  }

  export type QuizQuestionSumAggregateOutputType = {
    id: number | null
    quizId: number | null
    sectionId: number | null
    groupId: number | null
    points: Decimal | null
    orderIndex: number | null
  }

  export type QuizQuestionMinAggregateOutputType = {
    id: number | null
    quizId: number | null
    sectionId: number | null
    groupId: number | null
    content: string | null
    explanation: string | null
    questionType: string | null
    points: Decimal | null
    orderIndex: number | null
  }

  export type QuizQuestionMaxAggregateOutputType = {
    id: number | null
    quizId: number | null
    sectionId: number | null
    groupId: number | null
    content: string | null
    explanation: string | null
    questionType: string | null
    points: Decimal | null
    orderIndex: number | null
  }

  export type QuizQuestionCountAggregateOutputType = {
    id: number
    quizId: number
    sectionId: number
    groupId: number
    content: number
    explanation: number
    questionType: number
    points: number
    orderIndex: number
    _all: number
  }


  export type QuizQuestionAvgAggregateInputType = {
    id?: true
    quizId?: true
    sectionId?: true
    groupId?: true
    points?: true
    orderIndex?: true
  }

  export type QuizQuestionSumAggregateInputType = {
    id?: true
    quizId?: true
    sectionId?: true
    groupId?: true
    points?: true
    orderIndex?: true
  }

  export type QuizQuestionMinAggregateInputType = {
    id?: true
    quizId?: true
    sectionId?: true
    groupId?: true
    content?: true
    explanation?: true
    questionType?: true
    points?: true
    orderIndex?: true
  }

  export type QuizQuestionMaxAggregateInputType = {
    id?: true
    quizId?: true
    sectionId?: true
    groupId?: true
    content?: true
    explanation?: true
    questionType?: true
    points?: true
    orderIndex?: true
  }

  export type QuizQuestionCountAggregateInputType = {
    id?: true
    quizId?: true
    sectionId?: true
    groupId?: true
    content?: true
    explanation?: true
    questionType?: true
    points?: true
    orderIndex?: true
    _all?: true
  }

  export type QuizQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestion to aggregate.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizQuestions
    **/
    _count?: true | QuizQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizQuestionMaxAggregateInputType
  }

  export type GetQuizQuestionAggregateType<T extends QuizQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizQuestion[P]>
      : GetScalarType<T[P], AggregateQuizQuestion[P]>
  }




  export type QuizQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionWhereInput
    orderBy?: QuizQuestionOrderByWithAggregationInput | QuizQuestionOrderByWithAggregationInput[]
    by: QuizQuestionScalarFieldEnum[] | QuizQuestionScalarFieldEnum
    having?: QuizQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizQuestionCountAggregateInputType | true
    _avg?: QuizQuestionAvgAggregateInputType
    _sum?: QuizQuestionSumAggregateInputType
    _min?: QuizQuestionMinAggregateInputType
    _max?: QuizQuestionMaxAggregateInputType
  }

  export type QuizQuestionGroupByOutputType = {
    id: number
    quizId: number
    sectionId: number | null
    groupId: number | null
    content: string
    explanation: string | null
    questionType: string
    points: Decimal
    orderIndex: number
    _count: QuizQuestionCountAggregateOutputType | null
    _avg: QuizQuestionAvgAggregateOutputType | null
    _sum: QuizQuestionSumAggregateOutputType | null
    _min: QuizQuestionMinAggregateOutputType | null
    _max: QuizQuestionMaxAggregateOutputType | null
  }

  type GetQuizQuestionGroupByPayload<T extends QuizQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuizQuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuizQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    sectionId?: boolean
    groupId?: boolean
    content?: boolean
    explanation?: boolean
    questionType?: boolean
    points?: boolean
    orderIndex?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    section?: boolean | QuizQuestion$sectionArgs<ExtArgs>
    group?: boolean | QuizQuestion$groupArgs<ExtArgs>
    options?: boolean | QuizQuestion$optionsArgs<ExtArgs>
    answers?: boolean | QuizQuestion$answersArgs<ExtArgs>
    medias?: boolean | QuizQuestion$mediasArgs<ExtArgs>
    _count?: boolean | QuizQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    sectionId?: boolean
    groupId?: boolean
    content?: boolean
    explanation?: boolean
    questionType?: boolean
    points?: boolean
    orderIndex?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    section?: boolean | QuizQuestion$sectionArgs<ExtArgs>
    group?: boolean | QuizQuestion$groupArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    sectionId?: boolean
    groupId?: boolean
    content?: boolean
    explanation?: boolean
    questionType?: boolean
    points?: boolean
    orderIndex?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    section?: boolean | QuizQuestion$sectionArgs<ExtArgs>
    group?: boolean | QuizQuestion$groupArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectScalar = {
    id?: boolean
    quizId?: boolean
    sectionId?: boolean
    groupId?: boolean
    content?: boolean
    explanation?: boolean
    questionType?: boolean
    points?: boolean
    orderIndex?: boolean
  }

  export type QuizQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quizId" | "sectionId" | "groupId" | "content" | "explanation" | "questionType" | "points" | "orderIndex", ExtArgs["result"]["quizQuestion"]>
  export type QuizQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    section?: boolean | QuizQuestion$sectionArgs<ExtArgs>
    group?: boolean | QuizQuestion$groupArgs<ExtArgs>
    options?: boolean | QuizQuestion$optionsArgs<ExtArgs>
    answers?: boolean | QuizQuestion$answersArgs<ExtArgs>
    medias?: boolean | QuizQuestion$mediasArgs<ExtArgs>
    _count?: boolean | QuizQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    section?: boolean | QuizQuestion$sectionArgs<ExtArgs>
    group?: boolean | QuizQuestion$groupArgs<ExtArgs>
  }
  export type QuizQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    section?: boolean | QuizQuestion$sectionArgs<ExtArgs>
    group?: boolean | QuizQuestion$groupArgs<ExtArgs>
  }

  export type $QuizQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizQuestion"
    objects: {
      quiz: Prisma.$QuizPayload<ExtArgs>
      section: Prisma.$QuizSectionPayload<ExtArgs> | null
      group: Prisma.$QuizQuestionGroupPayload<ExtArgs> | null
      options: Prisma.$QuizOptionPayload<ExtArgs>[]
      answers: Prisma.$QuizAnswerPayload<ExtArgs>[]
      medias: Prisma.$QuizQuestionMediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      quizId: number
      sectionId: number | null
      groupId: number | null
      content: string
      explanation: string | null
      questionType: string
      points: Prisma.Decimal
      orderIndex: number
    }, ExtArgs["result"]["quizQuestion"]>
    composites: {}
  }

  type QuizQuestionGetPayload<S extends boolean | null | undefined | QuizQuestionDefaultArgs> = $Result.GetResult<Prisma.$QuizQuestionPayload, S>

  type QuizQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizQuestionCountAggregateInputType | true
    }

  export interface QuizQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizQuestion'], meta: { name: 'QuizQuestion' } }
    /**
     * Find zero or one QuizQuestion that matches the filter.
     * @param {QuizQuestionFindUniqueArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizQuestionFindUniqueArgs>(args: SelectSubset<T, QuizQuestionFindUniqueArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizQuestionFindUniqueOrThrowArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindFirstArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizQuestionFindFirstArgs>(args?: SelectSubset<T, QuizQuestionFindFirstArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindFirstOrThrowArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizQuestions
     * const quizQuestions = await prisma.quizQuestion.findMany()
     * 
     * // Get first 10 QuizQuestions
     * const quizQuestions = await prisma.quizQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizQuestionFindManyArgs>(args?: SelectSubset<T, QuizQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizQuestion.
     * @param {QuizQuestionCreateArgs} args - Arguments to create a QuizQuestion.
     * @example
     * // Create one QuizQuestion
     * const QuizQuestion = await prisma.quizQuestion.create({
     *   data: {
     *     // ... data to create a QuizQuestion
     *   }
     * })
     * 
     */
    create<T extends QuizQuestionCreateArgs>(args: SelectSubset<T, QuizQuestionCreateArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizQuestions.
     * @param {QuizQuestionCreateManyArgs} args - Arguments to create many QuizQuestions.
     * @example
     * // Create many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizQuestionCreateManyArgs>(args?: SelectSubset<T, QuizQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizQuestions and returns the data saved in the database.
     * @param {QuizQuestionCreateManyAndReturnArgs} args - Arguments to create many QuizQuestions.
     * @example
     * // Create many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizQuestions and only return the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizQuestion.
     * @param {QuizQuestionDeleteArgs} args - Arguments to delete one QuizQuestion.
     * @example
     * // Delete one QuizQuestion
     * const QuizQuestion = await prisma.quizQuestion.delete({
     *   where: {
     *     // ... filter to delete one QuizQuestion
     *   }
     * })
     * 
     */
    delete<T extends QuizQuestionDeleteArgs>(args: SelectSubset<T, QuizQuestionDeleteArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizQuestion.
     * @param {QuizQuestionUpdateArgs} args - Arguments to update one QuizQuestion.
     * @example
     * // Update one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizQuestionUpdateArgs>(args: SelectSubset<T, QuizQuestionUpdateArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizQuestions.
     * @param {QuizQuestionDeleteManyArgs} args - Arguments to filter QuizQuestions to delete.
     * @example
     * // Delete a few QuizQuestions
     * const { count } = await prisma.quizQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizQuestionDeleteManyArgs>(args?: SelectSubset<T, QuizQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizQuestionUpdateManyArgs>(args: SelectSubset<T, QuizQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestions and returns the data updated in the database.
     * @param {QuizQuestionUpdateManyAndReturnArgs} args - Arguments to update many QuizQuestions.
     * @example
     * // Update many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizQuestions and only return the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizQuestion.
     * @param {QuizQuestionUpsertArgs} args - Arguments to update or create a QuizQuestion.
     * @example
     * // Update or create a QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.upsert({
     *   create: {
     *     // ... data to create a QuizQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizQuestion we want to update
     *   }
     * })
     */
    upsert<T extends QuizQuestionUpsertArgs>(args: SelectSubset<T, QuizQuestionUpsertArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionCountArgs} args - Arguments to filter QuizQuestions to count.
     * @example
     * // Count the number of QuizQuestions
     * const count = await prisma.quizQuestion.count({
     *   where: {
     *     // ... the filter for the QuizQuestions we want to count
     *   }
     * })
    **/
    count<T extends QuizQuestionCountArgs>(
      args?: Subset<T, QuizQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizQuestionAggregateArgs>(args: Subset<T, QuizQuestionAggregateArgs>): Prisma.PrismaPromise<GetQuizQuestionAggregateType<T>>

    /**
     * Group by QuizQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizQuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuizQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizQuestion model
   */
  readonly fields: QuizQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quiz<T extends QuizDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizDefaultArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    section<T extends QuizQuestion$sectionArgs<ExtArgs> = {}>(args?: Subset<T, QuizQuestion$sectionArgs<ExtArgs>>): Prisma__QuizSectionClient<$Result.GetResult<Prisma.$QuizSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    group<T extends QuizQuestion$groupArgs<ExtArgs> = {}>(args?: Subset<T, QuizQuestion$groupArgs<ExtArgs>>): Prisma__QuizQuestionGroupClient<$Result.GetResult<Prisma.$QuizQuestionGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    options<T extends QuizQuestion$optionsArgs<ExtArgs> = {}>(args?: Subset<T, QuizQuestion$optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    answers<T extends QuizQuestion$answersArgs<ExtArgs> = {}>(args?: Subset<T, QuizQuestion$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medias<T extends QuizQuestion$mediasArgs<ExtArgs> = {}>(args?: Subset<T, QuizQuestion$mediasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizQuestion model
   */
  interface QuizQuestionFieldRefs {
    readonly id: FieldRef<"QuizQuestion", 'Int'>
    readonly quizId: FieldRef<"QuizQuestion", 'Int'>
    readonly sectionId: FieldRef<"QuizQuestion", 'Int'>
    readonly groupId: FieldRef<"QuizQuestion", 'Int'>
    readonly content: FieldRef<"QuizQuestion", 'String'>
    readonly explanation: FieldRef<"QuizQuestion", 'String'>
    readonly questionType: FieldRef<"QuizQuestion", 'String'>
    readonly points: FieldRef<"QuizQuestion", 'Decimal'>
    readonly orderIndex: FieldRef<"QuizQuestion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * QuizQuestion findUnique
   */
  export type QuizQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion findUniqueOrThrow
   */
  export type QuizQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion findFirst
   */
  export type QuizQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestions.
     */
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion findFirstOrThrow
   */
  export type QuizQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestions.
     */
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion findMany
   */
  export type QuizQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestions to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion create
   */
  export type QuizQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizQuestion.
     */
    data: XOR<QuizQuestionCreateInput, QuizQuestionUncheckedCreateInput>
  }

  /**
   * QuizQuestion createMany
   */
  export type QuizQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizQuestions.
     */
    data: QuizQuestionCreateManyInput | QuizQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizQuestion createManyAndReturn
   */
  export type QuizQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many QuizQuestions.
     */
    data: QuizQuestionCreateManyInput | QuizQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizQuestion update
   */
  export type QuizQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizQuestion.
     */
    data: XOR<QuizQuestionUpdateInput, QuizQuestionUncheckedUpdateInput>
    /**
     * Choose, which QuizQuestion to update.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion updateMany
   */
  export type QuizQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizQuestions.
     */
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestions to update
     */
    where?: QuizQuestionWhereInput
    /**
     * Limit how many QuizQuestions to update.
     */
    limit?: number
  }

  /**
   * QuizQuestion updateManyAndReturn
   */
  export type QuizQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * The data used to update QuizQuestions.
     */
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestions to update
     */
    where?: QuizQuestionWhereInput
    /**
     * Limit how many QuizQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizQuestion upsert
   */
  export type QuizQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizQuestion to update in case it exists.
     */
    where: QuizQuestionWhereUniqueInput
    /**
     * In case the QuizQuestion found by the `where` argument doesn't exist, create a new QuizQuestion with this data.
     */
    create: XOR<QuizQuestionCreateInput, QuizQuestionUncheckedCreateInput>
    /**
     * In case the QuizQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizQuestionUpdateInput, QuizQuestionUncheckedUpdateInput>
  }

  /**
   * QuizQuestion delete
   */
  export type QuizQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter which QuizQuestion to delete.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion deleteMany
   */
  export type QuizQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestions to delete
     */
    where?: QuizQuestionWhereInput
    /**
     * Limit how many QuizQuestions to delete.
     */
    limit?: number
  }

  /**
   * QuizQuestion.section
   */
  export type QuizQuestion$sectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSection
     */
    select?: QuizSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizSection
     */
    omit?: QuizSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSectionInclude<ExtArgs> | null
    where?: QuizSectionWhereInput
  }

  /**
   * QuizQuestion.group
   */
  export type QuizQuestion$groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroup
     */
    select?: QuizQuestionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroup
     */
    omit?: QuizQuestionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupInclude<ExtArgs> | null
    where?: QuizQuestionGroupWhereInput
  }

  /**
   * QuizQuestion.options
   */
  export type QuizQuestion$optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOption
     */
    select?: QuizOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOption
     */
    omit?: QuizOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionInclude<ExtArgs> | null
    where?: QuizOptionWhereInput
    orderBy?: QuizOptionOrderByWithRelationInput | QuizOptionOrderByWithRelationInput[]
    cursor?: QuizOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizOptionScalarFieldEnum | QuizOptionScalarFieldEnum[]
  }

  /**
   * QuizQuestion.answers
   */
  export type QuizQuestion$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    where?: QuizAnswerWhereInput
    orderBy?: QuizAnswerOrderByWithRelationInput | QuizAnswerOrderByWithRelationInput[]
    cursor?: QuizAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizAnswerScalarFieldEnum | QuizAnswerScalarFieldEnum[]
  }

  /**
   * QuizQuestion.medias
   */
  export type QuizQuestion$mediasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionMedia
     */
    select?: QuizQuestionMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionMedia
     */
    omit?: QuizQuestionMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionMediaInclude<ExtArgs> | null
    where?: QuizQuestionMediaWhereInput
    orderBy?: QuizQuestionMediaOrderByWithRelationInput | QuizQuestionMediaOrderByWithRelationInput[]
    cursor?: QuizQuestionMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizQuestionMediaScalarFieldEnum | QuizQuestionMediaScalarFieldEnum[]
  }

  /**
   * QuizQuestion without action
   */
  export type QuizQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
  }


  /**
   * Model QuizOption
   */

  export type AggregateQuizOption = {
    _count: QuizOptionCountAggregateOutputType | null
    _avg: QuizOptionAvgAggregateOutputType | null
    _sum: QuizOptionSumAggregateOutputType | null
    _min: QuizOptionMinAggregateOutputType | null
    _max: QuizOptionMaxAggregateOutputType | null
  }

  export type QuizOptionAvgAggregateOutputType = {
    id: number | null
    questionId: number | null
    orderIndex: number | null
  }

  export type QuizOptionSumAggregateOutputType = {
    id: number | null
    questionId: number | null
    orderIndex: number | null
  }

  export type QuizOptionMinAggregateOutputType = {
    id: number | null
    questionId: number | null
    content: string | null
    isCorrect: boolean | null
    orderIndex: number | null
  }

  export type QuizOptionMaxAggregateOutputType = {
    id: number | null
    questionId: number | null
    content: string | null
    isCorrect: boolean | null
    orderIndex: number | null
  }

  export type QuizOptionCountAggregateOutputType = {
    id: number
    questionId: number
    content: number
    isCorrect: number
    orderIndex: number
    _all: number
  }


  export type QuizOptionAvgAggregateInputType = {
    id?: true
    questionId?: true
    orderIndex?: true
  }

  export type QuizOptionSumAggregateInputType = {
    id?: true
    questionId?: true
    orderIndex?: true
  }

  export type QuizOptionMinAggregateInputType = {
    id?: true
    questionId?: true
    content?: true
    isCorrect?: true
    orderIndex?: true
  }

  export type QuizOptionMaxAggregateInputType = {
    id?: true
    questionId?: true
    content?: true
    isCorrect?: true
    orderIndex?: true
  }

  export type QuizOptionCountAggregateInputType = {
    id?: true
    questionId?: true
    content?: true
    isCorrect?: true
    orderIndex?: true
    _all?: true
  }

  export type QuizOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizOption to aggregate.
     */
    where?: QuizOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizOptions to fetch.
     */
    orderBy?: QuizOptionOrderByWithRelationInput | QuizOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizOptions
    **/
    _count?: true | QuizOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizOptionMaxAggregateInputType
  }

  export type GetQuizOptionAggregateType<T extends QuizOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizOption[P]>
      : GetScalarType<T[P], AggregateQuizOption[P]>
  }




  export type QuizOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizOptionWhereInput
    orderBy?: QuizOptionOrderByWithAggregationInput | QuizOptionOrderByWithAggregationInput[]
    by: QuizOptionScalarFieldEnum[] | QuizOptionScalarFieldEnum
    having?: QuizOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizOptionCountAggregateInputType | true
    _avg?: QuizOptionAvgAggregateInputType
    _sum?: QuizOptionSumAggregateInputType
    _min?: QuizOptionMinAggregateInputType
    _max?: QuizOptionMaxAggregateInputType
  }

  export type QuizOptionGroupByOutputType = {
    id: number
    questionId: number
    content: string
    isCorrect: boolean
    orderIndex: number
    _count: QuizOptionCountAggregateOutputType | null
    _avg: QuizOptionAvgAggregateOutputType | null
    _sum: QuizOptionSumAggregateOutputType | null
    _min: QuizOptionMinAggregateOutputType | null
    _max: QuizOptionMaxAggregateOutputType | null
  }

  type GetQuizOptionGroupByPayload<T extends QuizOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizOptionGroupByOutputType[P]>
            : GetScalarType<T[P], QuizOptionGroupByOutputType[P]>
        }
      >
    >


  export type QuizOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    content?: boolean
    isCorrect?: boolean
    orderIndex?: boolean
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
    answers?: boolean | QuizOption$answersArgs<ExtArgs>
    medias?: boolean | QuizOption$mediasArgs<ExtArgs>
    _count?: boolean | QuizOptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizOption"]>

  export type QuizOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    content?: boolean
    isCorrect?: boolean
    orderIndex?: boolean
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizOption"]>

  export type QuizOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    content?: boolean
    isCorrect?: boolean
    orderIndex?: boolean
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizOption"]>

  export type QuizOptionSelectScalar = {
    id?: boolean
    questionId?: boolean
    content?: boolean
    isCorrect?: boolean
    orderIndex?: boolean
  }

  export type QuizOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "questionId" | "content" | "isCorrect" | "orderIndex", ExtArgs["result"]["quizOption"]>
  export type QuizOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
    answers?: boolean | QuizOption$answersArgs<ExtArgs>
    medias?: boolean | QuizOption$mediasArgs<ExtArgs>
    _count?: boolean | QuizOptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }
  export type QuizOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
  }

  export type $QuizOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizOption"
    objects: {
      question: Prisma.$QuizQuestionPayload<ExtArgs>
      answers: Prisma.$QuizAnswerPayload<ExtArgs>[]
      medias: Prisma.$QuizOptionMediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      questionId: number
      content: string
      isCorrect: boolean
      orderIndex: number
    }, ExtArgs["result"]["quizOption"]>
    composites: {}
  }

  type QuizOptionGetPayload<S extends boolean | null | undefined | QuizOptionDefaultArgs> = $Result.GetResult<Prisma.$QuizOptionPayload, S>

  type QuizOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizOptionCountAggregateInputType | true
    }

  export interface QuizOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizOption'], meta: { name: 'QuizOption' } }
    /**
     * Find zero or one QuizOption that matches the filter.
     * @param {QuizOptionFindUniqueArgs} args - Arguments to find a QuizOption
     * @example
     * // Get one QuizOption
     * const quizOption = await prisma.quizOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizOptionFindUniqueArgs>(args: SelectSubset<T, QuizOptionFindUniqueArgs<ExtArgs>>): Prisma__QuizOptionClient<$Result.GetResult<Prisma.$QuizOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizOptionFindUniqueOrThrowArgs} args - Arguments to find a QuizOption
     * @example
     * // Get one QuizOption
     * const quizOption = await prisma.quizOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizOptionClient<$Result.GetResult<Prisma.$QuizOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizOptionFindFirstArgs} args - Arguments to find a QuizOption
     * @example
     * // Get one QuizOption
     * const quizOption = await prisma.quizOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizOptionFindFirstArgs>(args?: SelectSubset<T, QuizOptionFindFirstArgs<ExtArgs>>): Prisma__QuizOptionClient<$Result.GetResult<Prisma.$QuizOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizOptionFindFirstOrThrowArgs} args - Arguments to find a QuizOption
     * @example
     * // Get one QuizOption
     * const quizOption = await prisma.quizOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizOptionClient<$Result.GetResult<Prisma.$QuizOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizOptions
     * const quizOptions = await prisma.quizOption.findMany()
     * 
     * // Get first 10 QuizOptions
     * const quizOptions = await prisma.quizOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizOptionWithIdOnly = await prisma.quizOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizOptionFindManyArgs>(args?: SelectSubset<T, QuizOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizOption.
     * @param {QuizOptionCreateArgs} args - Arguments to create a QuizOption.
     * @example
     * // Create one QuizOption
     * const QuizOption = await prisma.quizOption.create({
     *   data: {
     *     // ... data to create a QuizOption
     *   }
     * })
     * 
     */
    create<T extends QuizOptionCreateArgs>(args: SelectSubset<T, QuizOptionCreateArgs<ExtArgs>>): Prisma__QuizOptionClient<$Result.GetResult<Prisma.$QuizOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizOptions.
     * @param {QuizOptionCreateManyArgs} args - Arguments to create many QuizOptions.
     * @example
     * // Create many QuizOptions
     * const quizOption = await prisma.quizOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizOptionCreateManyArgs>(args?: SelectSubset<T, QuizOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizOptions and returns the data saved in the database.
     * @param {QuizOptionCreateManyAndReturnArgs} args - Arguments to create many QuizOptions.
     * @example
     * // Create many QuizOptions
     * const quizOption = await prisma.quizOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizOptions and only return the `id`
     * const quizOptionWithIdOnly = await prisma.quizOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizOption.
     * @param {QuizOptionDeleteArgs} args - Arguments to delete one QuizOption.
     * @example
     * // Delete one QuizOption
     * const QuizOption = await prisma.quizOption.delete({
     *   where: {
     *     // ... filter to delete one QuizOption
     *   }
     * })
     * 
     */
    delete<T extends QuizOptionDeleteArgs>(args: SelectSubset<T, QuizOptionDeleteArgs<ExtArgs>>): Prisma__QuizOptionClient<$Result.GetResult<Prisma.$QuizOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizOption.
     * @param {QuizOptionUpdateArgs} args - Arguments to update one QuizOption.
     * @example
     * // Update one QuizOption
     * const quizOption = await prisma.quizOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizOptionUpdateArgs>(args: SelectSubset<T, QuizOptionUpdateArgs<ExtArgs>>): Prisma__QuizOptionClient<$Result.GetResult<Prisma.$QuizOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizOptions.
     * @param {QuizOptionDeleteManyArgs} args - Arguments to filter QuizOptions to delete.
     * @example
     * // Delete a few QuizOptions
     * const { count } = await prisma.quizOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizOptionDeleteManyArgs>(args?: SelectSubset<T, QuizOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizOptions
     * const quizOption = await prisma.quizOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizOptionUpdateManyArgs>(args: SelectSubset<T, QuizOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizOptions and returns the data updated in the database.
     * @param {QuizOptionUpdateManyAndReturnArgs} args - Arguments to update many QuizOptions.
     * @example
     * // Update many QuizOptions
     * const quizOption = await prisma.quizOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizOptions and only return the `id`
     * const quizOptionWithIdOnly = await prisma.quizOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizOption.
     * @param {QuizOptionUpsertArgs} args - Arguments to update or create a QuizOption.
     * @example
     * // Update or create a QuizOption
     * const quizOption = await prisma.quizOption.upsert({
     *   create: {
     *     // ... data to create a QuizOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizOption we want to update
     *   }
     * })
     */
    upsert<T extends QuizOptionUpsertArgs>(args: SelectSubset<T, QuizOptionUpsertArgs<ExtArgs>>): Prisma__QuizOptionClient<$Result.GetResult<Prisma.$QuizOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizOptionCountArgs} args - Arguments to filter QuizOptions to count.
     * @example
     * // Count the number of QuizOptions
     * const count = await prisma.quizOption.count({
     *   where: {
     *     // ... the filter for the QuizOptions we want to count
     *   }
     * })
    **/
    count<T extends QuizOptionCountArgs>(
      args?: Subset<T, QuizOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizOptionAggregateArgs>(args: Subset<T, QuizOptionAggregateArgs>): Prisma.PrismaPromise<GetQuizOptionAggregateType<T>>

    /**
     * Group by QuizOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizOptionGroupByArgs['orderBy'] }
        : { orderBy?: QuizOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizOption model
   */
  readonly fields: QuizOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    question<T extends QuizQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizQuestionDefaultArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    answers<T extends QuizOption$answersArgs<ExtArgs> = {}>(args?: Subset<T, QuizOption$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medias<T extends QuizOption$mediasArgs<ExtArgs> = {}>(args?: Subset<T, QuizOption$mediasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizOptionMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizOption model
   */
  interface QuizOptionFieldRefs {
    readonly id: FieldRef<"QuizOption", 'Int'>
    readonly questionId: FieldRef<"QuizOption", 'Int'>
    readonly content: FieldRef<"QuizOption", 'String'>
    readonly isCorrect: FieldRef<"QuizOption", 'Boolean'>
    readonly orderIndex: FieldRef<"QuizOption", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * QuizOption findUnique
   */
  export type QuizOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOption
     */
    select?: QuizOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOption
     */
    omit?: QuizOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionInclude<ExtArgs> | null
    /**
     * Filter, which QuizOption to fetch.
     */
    where: QuizOptionWhereUniqueInput
  }

  /**
   * QuizOption findUniqueOrThrow
   */
  export type QuizOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOption
     */
    select?: QuizOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOption
     */
    omit?: QuizOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionInclude<ExtArgs> | null
    /**
     * Filter, which QuizOption to fetch.
     */
    where: QuizOptionWhereUniqueInput
  }

  /**
   * QuizOption findFirst
   */
  export type QuizOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOption
     */
    select?: QuizOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOption
     */
    omit?: QuizOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionInclude<ExtArgs> | null
    /**
     * Filter, which QuizOption to fetch.
     */
    where?: QuizOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizOptions to fetch.
     */
    orderBy?: QuizOptionOrderByWithRelationInput | QuizOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizOptions.
     */
    cursor?: QuizOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizOptions.
     */
    distinct?: QuizOptionScalarFieldEnum | QuizOptionScalarFieldEnum[]
  }

  /**
   * QuizOption findFirstOrThrow
   */
  export type QuizOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOption
     */
    select?: QuizOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOption
     */
    omit?: QuizOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionInclude<ExtArgs> | null
    /**
     * Filter, which QuizOption to fetch.
     */
    where?: QuizOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizOptions to fetch.
     */
    orderBy?: QuizOptionOrderByWithRelationInput | QuizOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizOptions.
     */
    cursor?: QuizOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizOptions.
     */
    distinct?: QuizOptionScalarFieldEnum | QuizOptionScalarFieldEnum[]
  }

  /**
   * QuizOption findMany
   */
  export type QuizOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOption
     */
    select?: QuizOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOption
     */
    omit?: QuizOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionInclude<ExtArgs> | null
    /**
     * Filter, which QuizOptions to fetch.
     */
    where?: QuizOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizOptions to fetch.
     */
    orderBy?: QuizOptionOrderByWithRelationInput | QuizOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizOptions.
     */
    cursor?: QuizOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizOptions.
     */
    skip?: number
    distinct?: QuizOptionScalarFieldEnum | QuizOptionScalarFieldEnum[]
  }

  /**
   * QuizOption create
   */
  export type QuizOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOption
     */
    select?: QuizOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOption
     */
    omit?: QuizOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizOption.
     */
    data: XOR<QuizOptionCreateInput, QuizOptionUncheckedCreateInput>
  }

  /**
   * QuizOption createMany
   */
  export type QuizOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizOptions.
     */
    data: QuizOptionCreateManyInput | QuizOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizOption createManyAndReturn
   */
  export type QuizOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOption
     */
    select?: QuizOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOption
     */
    omit?: QuizOptionOmit<ExtArgs> | null
    /**
     * The data used to create many QuizOptions.
     */
    data: QuizOptionCreateManyInput | QuizOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizOption update
   */
  export type QuizOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOption
     */
    select?: QuizOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOption
     */
    omit?: QuizOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizOption.
     */
    data: XOR<QuizOptionUpdateInput, QuizOptionUncheckedUpdateInput>
    /**
     * Choose, which QuizOption to update.
     */
    where: QuizOptionWhereUniqueInput
  }

  /**
   * QuizOption updateMany
   */
  export type QuizOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizOptions.
     */
    data: XOR<QuizOptionUpdateManyMutationInput, QuizOptionUncheckedUpdateManyInput>
    /**
     * Filter which QuizOptions to update
     */
    where?: QuizOptionWhereInput
    /**
     * Limit how many QuizOptions to update.
     */
    limit?: number
  }

  /**
   * QuizOption updateManyAndReturn
   */
  export type QuizOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOption
     */
    select?: QuizOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOption
     */
    omit?: QuizOptionOmit<ExtArgs> | null
    /**
     * The data used to update QuizOptions.
     */
    data: XOR<QuizOptionUpdateManyMutationInput, QuizOptionUncheckedUpdateManyInput>
    /**
     * Filter which QuizOptions to update
     */
    where?: QuizOptionWhereInput
    /**
     * Limit how many QuizOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizOption upsert
   */
  export type QuizOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOption
     */
    select?: QuizOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOption
     */
    omit?: QuizOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizOption to update in case it exists.
     */
    where: QuizOptionWhereUniqueInput
    /**
     * In case the QuizOption found by the `where` argument doesn't exist, create a new QuizOption with this data.
     */
    create: XOR<QuizOptionCreateInput, QuizOptionUncheckedCreateInput>
    /**
     * In case the QuizOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizOptionUpdateInput, QuizOptionUncheckedUpdateInput>
  }

  /**
   * QuizOption delete
   */
  export type QuizOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOption
     */
    select?: QuizOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOption
     */
    omit?: QuizOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionInclude<ExtArgs> | null
    /**
     * Filter which QuizOption to delete.
     */
    where: QuizOptionWhereUniqueInput
  }

  /**
   * QuizOption deleteMany
   */
  export type QuizOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizOptions to delete
     */
    where?: QuizOptionWhereInput
    /**
     * Limit how many QuizOptions to delete.
     */
    limit?: number
  }

  /**
   * QuizOption.answers
   */
  export type QuizOption$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    where?: QuizAnswerWhereInput
    orderBy?: QuizAnswerOrderByWithRelationInput | QuizAnswerOrderByWithRelationInput[]
    cursor?: QuizAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizAnswerScalarFieldEnum | QuizAnswerScalarFieldEnum[]
  }

  /**
   * QuizOption.medias
   */
  export type QuizOption$mediasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOptionMedia
     */
    select?: QuizOptionMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOptionMedia
     */
    omit?: QuizOptionMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionMediaInclude<ExtArgs> | null
    where?: QuizOptionMediaWhereInput
    orderBy?: QuizOptionMediaOrderByWithRelationInput | QuizOptionMediaOrderByWithRelationInput[]
    cursor?: QuizOptionMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizOptionMediaScalarFieldEnum | QuizOptionMediaScalarFieldEnum[]
  }

  /**
   * QuizOption without action
   */
  export type QuizOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOption
     */
    select?: QuizOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOption
     */
    omit?: QuizOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionInclude<ExtArgs> | null
  }


  /**
   * Model QuizAttempt
   */

  export type AggregateQuizAttempt = {
    _count: QuizAttemptCountAggregateOutputType | null
    _avg: QuizAttemptAvgAggregateOutputType | null
    _sum: QuizAttemptSumAggregateOutputType | null
    _min: QuizAttemptMinAggregateOutputType | null
    _max: QuizAttemptMaxAggregateOutputType | null
  }

  export type QuizAttemptAvgAggregateOutputType = {
    id: number | null
    quizId: number | null
    studentId: number | null
    scoreRaw: Decimal | null
    scoreScaled10: Decimal | null
  }

  export type QuizAttemptSumAggregateOutputType = {
    id: number | null
    quizId: number | null
    studentId: number | null
    scoreRaw: Decimal | null
    scoreScaled10: Decimal | null
  }

  export type QuizAttemptMinAggregateOutputType = {
    id: number | null
    quizId: number | null
    studentId: number | null
    startedAt: Date | null
    submittedAt: Date | null
    status: string | null
    scoreRaw: Decimal | null
    scoreScaled10: Decimal | null
  }

  export type QuizAttemptMaxAggregateOutputType = {
    id: number | null
    quizId: number | null
    studentId: number | null
    startedAt: Date | null
    submittedAt: Date | null
    status: string | null
    scoreRaw: Decimal | null
    scoreScaled10: Decimal | null
  }

  export type QuizAttemptCountAggregateOutputType = {
    id: number
    quizId: number
    studentId: number
    startedAt: number
    submittedAt: number
    status: number
    scoreRaw: number
    scoreScaled10: number
    _all: number
  }


  export type QuizAttemptAvgAggregateInputType = {
    id?: true
    quizId?: true
    studentId?: true
    scoreRaw?: true
    scoreScaled10?: true
  }

  export type QuizAttemptSumAggregateInputType = {
    id?: true
    quizId?: true
    studentId?: true
    scoreRaw?: true
    scoreScaled10?: true
  }

  export type QuizAttemptMinAggregateInputType = {
    id?: true
    quizId?: true
    studentId?: true
    startedAt?: true
    submittedAt?: true
    status?: true
    scoreRaw?: true
    scoreScaled10?: true
  }

  export type QuizAttemptMaxAggregateInputType = {
    id?: true
    quizId?: true
    studentId?: true
    startedAt?: true
    submittedAt?: true
    status?: true
    scoreRaw?: true
    scoreScaled10?: true
  }

  export type QuizAttemptCountAggregateInputType = {
    id?: true
    quizId?: true
    studentId?: true
    startedAt?: true
    submittedAt?: true
    status?: true
    scoreRaw?: true
    scoreScaled10?: true
    _all?: true
  }

  export type QuizAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizAttempt to aggregate.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizAttempts
    **/
    _count?: true | QuizAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizAttemptMaxAggregateInputType
  }

  export type GetQuizAttemptAggregateType<T extends QuizAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizAttempt[P]>
      : GetScalarType<T[P], AggregateQuizAttempt[P]>
  }




  export type QuizAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAttemptWhereInput
    orderBy?: QuizAttemptOrderByWithAggregationInput | QuizAttemptOrderByWithAggregationInput[]
    by: QuizAttemptScalarFieldEnum[] | QuizAttemptScalarFieldEnum
    having?: QuizAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizAttemptCountAggregateInputType | true
    _avg?: QuizAttemptAvgAggregateInputType
    _sum?: QuizAttemptSumAggregateInputType
    _min?: QuizAttemptMinAggregateInputType
    _max?: QuizAttemptMaxAggregateInputType
  }

  export type QuizAttemptGroupByOutputType = {
    id: number
    quizId: number
    studentId: number
    startedAt: Date
    submittedAt: Date | null
    status: string
    scoreRaw: Decimal | null
    scoreScaled10: Decimal | null
    _count: QuizAttemptCountAggregateOutputType | null
    _avg: QuizAttemptAvgAggregateOutputType | null
    _sum: QuizAttemptSumAggregateOutputType | null
    _min: QuizAttemptMinAggregateOutputType | null
    _max: QuizAttemptMaxAggregateOutputType | null
  }

  type GetQuizAttemptGroupByPayload<T extends QuizAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], QuizAttemptGroupByOutputType[P]>
        }
      >
    >


  export type QuizAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    studentId?: boolean
    startedAt?: boolean
    submittedAt?: boolean
    status?: boolean
    scoreRaw?: boolean
    scoreScaled10?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
    answers?: boolean | QuizAttempt$answersArgs<ExtArgs>
    _count?: boolean | QuizAttemptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAttempt"]>

  export type QuizAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    studentId?: boolean
    startedAt?: boolean
    submittedAt?: boolean
    status?: boolean
    scoreRaw?: boolean
    scoreScaled10?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAttempt"]>

  export type QuizAttemptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    studentId?: boolean
    startedAt?: boolean
    submittedAt?: boolean
    status?: boolean
    scoreRaw?: boolean
    scoreScaled10?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAttempt"]>

  export type QuizAttemptSelectScalar = {
    id?: boolean
    quizId?: boolean
    studentId?: boolean
    startedAt?: boolean
    submittedAt?: boolean
    status?: boolean
    scoreRaw?: boolean
    scoreScaled10?: boolean
  }

  export type QuizAttemptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quizId" | "studentId" | "startedAt" | "submittedAt" | "status" | "scoreRaw" | "scoreScaled10", ExtArgs["result"]["quizAttempt"]>
  export type QuizAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
    answers?: boolean | QuizAttempt$answersArgs<ExtArgs>
    _count?: boolean | QuizAttemptCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QuizAttemptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    student?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $QuizAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizAttempt"
    objects: {
      quiz: Prisma.$QuizPayload<ExtArgs>
      student: Prisma.$UserPayload<ExtArgs>
      answers: Prisma.$QuizAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      quizId: number
      studentId: number
      startedAt: Date
      submittedAt: Date | null
      status: string
      scoreRaw: Prisma.Decimal | null
      scoreScaled10: Prisma.Decimal | null
    }, ExtArgs["result"]["quizAttempt"]>
    composites: {}
  }

  type QuizAttemptGetPayload<S extends boolean | null | undefined | QuizAttemptDefaultArgs> = $Result.GetResult<Prisma.$QuizAttemptPayload, S>

  type QuizAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizAttemptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizAttemptCountAggregateInputType | true
    }

  export interface QuizAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizAttempt'], meta: { name: 'QuizAttempt' } }
    /**
     * Find zero or one QuizAttempt that matches the filter.
     * @param {QuizAttemptFindUniqueArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizAttemptFindUniqueArgs>(args: SelectSubset<T, QuizAttemptFindUniqueArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizAttempt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizAttemptFindUniqueOrThrowArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptFindFirstArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizAttemptFindFirstArgs>(args?: SelectSubset<T, QuizAttemptFindFirstArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptFindFirstOrThrowArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizAttempts
     * const quizAttempts = await prisma.quizAttempt.findMany()
     * 
     * // Get first 10 QuizAttempts
     * const quizAttempts = await prisma.quizAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizAttemptWithIdOnly = await prisma.quizAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizAttemptFindManyArgs>(args?: SelectSubset<T, QuizAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizAttempt.
     * @param {QuizAttemptCreateArgs} args - Arguments to create a QuizAttempt.
     * @example
     * // Create one QuizAttempt
     * const QuizAttempt = await prisma.quizAttempt.create({
     *   data: {
     *     // ... data to create a QuizAttempt
     *   }
     * })
     * 
     */
    create<T extends QuizAttemptCreateArgs>(args: SelectSubset<T, QuizAttemptCreateArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizAttempts.
     * @param {QuizAttemptCreateManyArgs} args - Arguments to create many QuizAttempts.
     * @example
     * // Create many QuizAttempts
     * const quizAttempt = await prisma.quizAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizAttemptCreateManyArgs>(args?: SelectSubset<T, QuizAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizAttempts and returns the data saved in the database.
     * @param {QuizAttemptCreateManyAndReturnArgs} args - Arguments to create many QuizAttempts.
     * @example
     * // Create many QuizAttempts
     * const quizAttempt = await prisma.quizAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizAttempts and only return the `id`
     * const quizAttemptWithIdOnly = await prisma.quizAttempt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizAttempt.
     * @param {QuizAttemptDeleteArgs} args - Arguments to delete one QuizAttempt.
     * @example
     * // Delete one QuizAttempt
     * const QuizAttempt = await prisma.quizAttempt.delete({
     *   where: {
     *     // ... filter to delete one QuizAttempt
     *   }
     * })
     * 
     */
    delete<T extends QuizAttemptDeleteArgs>(args: SelectSubset<T, QuizAttemptDeleteArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizAttempt.
     * @param {QuizAttemptUpdateArgs} args - Arguments to update one QuizAttempt.
     * @example
     * // Update one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizAttemptUpdateArgs>(args: SelectSubset<T, QuizAttemptUpdateArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizAttempts.
     * @param {QuizAttemptDeleteManyArgs} args - Arguments to filter QuizAttempts to delete.
     * @example
     * // Delete a few QuizAttempts
     * const { count } = await prisma.quizAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizAttemptDeleteManyArgs>(args?: SelectSubset<T, QuizAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizAttempts
     * const quizAttempt = await prisma.quizAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizAttemptUpdateManyArgs>(args: SelectSubset<T, QuizAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizAttempts and returns the data updated in the database.
     * @param {QuizAttemptUpdateManyAndReturnArgs} args - Arguments to update many QuizAttempts.
     * @example
     * // Update many QuizAttempts
     * const quizAttempt = await prisma.quizAttempt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizAttempts and only return the `id`
     * const quizAttemptWithIdOnly = await prisma.quizAttempt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizAttemptUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizAttemptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizAttempt.
     * @param {QuizAttemptUpsertArgs} args - Arguments to update or create a QuizAttempt.
     * @example
     * // Update or create a QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.upsert({
     *   create: {
     *     // ... data to create a QuizAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizAttempt we want to update
     *   }
     * })
     */
    upsert<T extends QuizAttemptUpsertArgs>(args: SelectSubset<T, QuizAttemptUpsertArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptCountArgs} args - Arguments to filter QuizAttempts to count.
     * @example
     * // Count the number of QuizAttempts
     * const count = await prisma.quizAttempt.count({
     *   where: {
     *     // ... the filter for the QuizAttempts we want to count
     *   }
     * })
    **/
    count<T extends QuizAttemptCountArgs>(
      args?: Subset<T, QuizAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAttemptAggregateArgs>(args: Subset<T, QuizAttemptAggregateArgs>): Prisma.PrismaPromise<GetQuizAttemptAggregateType<T>>

    /**
     * Group by QuizAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizAttemptGroupByArgs['orderBy'] }
        : { orderBy?: QuizAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizAttempt model
   */
  readonly fields: QuizAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quiz<T extends QuizDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizDefaultArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    answers<T extends QuizAttempt$answersArgs<ExtArgs> = {}>(args?: Subset<T, QuizAttempt$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizAttempt model
   */
  interface QuizAttemptFieldRefs {
    readonly id: FieldRef<"QuizAttempt", 'Int'>
    readonly quizId: FieldRef<"QuizAttempt", 'Int'>
    readonly studentId: FieldRef<"QuizAttempt", 'Int'>
    readonly startedAt: FieldRef<"QuizAttempt", 'DateTime'>
    readonly submittedAt: FieldRef<"QuizAttempt", 'DateTime'>
    readonly status: FieldRef<"QuizAttempt", 'String'>
    readonly scoreRaw: FieldRef<"QuizAttempt", 'Decimal'>
    readonly scoreScaled10: FieldRef<"QuizAttempt", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * QuizAttempt findUnique
   */
  export type QuizAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt findUniqueOrThrow
   */
  export type QuizAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt findFirst
   */
  export type QuizAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizAttempts.
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizAttempts.
     */
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * QuizAttempt findFirstOrThrow
   */
  export type QuizAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizAttempts.
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizAttempts.
     */
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * QuizAttempt findMany
   */
  export type QuizAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempts to fetch.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizAttempts.
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * QuizAttempt create
   */
  export type QuizAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizAttempt.
     */
    data: XOR<QuizAttemptCreateInput, QuizAttemptUncheckedCreateInput>
  }

  /**
   * QuizAttempt createMany
   */
  export type QuizAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizAttempts.
     */
    data: QuizAttemptCreateManyInput | QuizAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizAttempt createManyAndReturn
   */
  export type QuizAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * The data used to create many QuizAttempts.
     */
    data: QuizAttemptCreateManyInput | QuizAttemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizAttempt update
   */
  export type QuizAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizAttempt.
     */
    data: XOR<QuizAttemptUpdateInput, QuizAttemptUncheckedUpdateInput>
    /**
     * Choose, which QuizAttempt to update.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt updateMany
   */
  export type QuizAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizAttempts.
     */
    data: XOR<QuizAttemptUpdateManyMutationInput, QuizAttemptUncheckedUpdateManyInput>
    /**
     * Filter which QuizAttempts to update
     */
    where?: QuizAttemptWhereInput
    /**
     * Limit how many QuizAttempts to update.
     */
    limit?: number
  }

  /**
   * QuizAttempt updateManyAndReturn
   */
  export type QuizAttemptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * The data used to update QuizAttempts.
     */
    data: XOR<QuizAttemptUpdateManyMutationInput, QuizAttemptUncheckedUpdateManyInput>
    /**
     * Filter which QuizAttempts to update
     */
    where?: QuizAttemptWhereInput
    /**
     * Limit how many QuizAttempts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizAttempt upsert
   */
  export type QuizAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizAttempt to update in case it exists.
     */
    where: QuizAttemptWhereUniqueInput
    /**
     * In case the QuizAttempt found by the `where` argument doesn't exist, create a new QuizAttempt with this data.
     */
    create: XOR<QuizAttemptCreateInput, QuizAttemptUncheckedCreateInput>
    /**
     * In case the QuizAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizAttemptUpdateInput, QuizAttemptUncheckedUpdateInput>
  }

  /**
   * QuizAttempt delete
   */
  export type QuizAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter which QuizAttempt to delete.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt deleteMany
   */
  export type QuizAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizAttempts to delete
     */
    where?: QuizAttemptWhereInput
    /**
     * Limit how many QuizAttempts to delete.
     */
    limit?: number
  }

  /**
   * QuizAttempt.answers
   */
  export type QuizAttempt$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    where?: QuizAnswerWhereInput
    orderBy?: QuizAnswerOrderByWithRelationInput | QuizAnswerOrderByWithRelationInput[]
    cursor?: QuizAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizAnswerScalarFieldEnum | QuizAnswerScalarFieldEnum[]
  }

  /**
   * QuizAttempt without action
   */
  export type QuizAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
  }


  /**
   * Model QuizAnswer
   */

  export type AggregateQuizAnswer = {
    _count: QuizAnswerCountAggregateOutputType | null
    _avg: QuizAnswerAvgAggregateOutputType | null
    _sum: QuizAnswerSumAggregateOutputType | null
    _min: QuizAnswerMinAggregateOutputType | null
    _max: QuizAnswerMaxAggregateOutputType | null
  }

  export type QuizAnswerAvgAggregateOutputType = {
    attemptId: number | null
    questionId: number | null
    optionId: number | null
  }

  export type QuizAnswerSumAggregateOutputType = {
    attemptId: number | null
    questionId: number | null
    optionId: number | null
  }

  export type QuizAnswerMinAggregateOutputType = {
    attemptId: number | null
    questionId: number | null
    optionId: number | null
  }

  export type QuizAnswerMaxAggregateOutputType = {
    attemptId: number | null
    questionId: number | null
    optionId: number | null
  }

  export type QuizAnswerCountAggregateOutputType = {
    attemptId: number
    questionId: number
    optionId: number
    _all: number
  }


  export type QuizAnswerAvgAggregateInputType = {
    attemptId?: true
    questionId?: true
    optionId?: true
  }

  export type QuizAnswerSumAggregateInputType = {
    attemptId?: true
    questionId?: true
    optionId?: true
  }

  export type QuizAnswerMinAggregateInputType = {
    attemptId?: true
    questionId?: true
    optionId?: true
  }

  export type QuizAnswerMaxAggregateInputType = {
    attemptId?: true
    questionId?: true
    optionId?: true
  }

  export type QuizAnswerCountAggregateInputType = {
    attemptId?: true
    questionId?: true
    optionId?: true
    _all?: true
  }

  export type QuizAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizAnswer to aggregate.
     */
    where?: QuizAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAnswers to fetch.
     */
    orderBy?: QuizAnswerOrderByWithRelationInput | QuizAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizAnswers
    **/
    _count?: true | QuizAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizAnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizAnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizAnswerMaxAggregateInputType
  }

  export type GetQuizAnswerAggregateType<T extends QuizAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizAnswer[P]>
      : GetScalarType<T[P], AggregateQuizAnswer[P]>
  }




  export type QuizAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAnswerWhereInput
    orderBy?: QuizAnswerOrderByWithAggregationInput | QuizAnswerOrderByWithAggregationInput[]
    by: QuizAnswerScalarFieldEnum[] | QuizAnswerScalarFieldEnum
    having?: QuizAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizAnswerCountAggregateInputType | true
    _avg?: QuizAnswerAvgAggregateInputType
    _sum?: QuizAnswerSumAggregateInputType
    _min?: QuizAnswerMinAggregateInputType
    _max?: QuizAnswerMaxAggregateInputType
  }

  export type QuizAnswerGroupByOutputType = {
    attemptId: number
    questionId: number
    optionId: number
    _count: QuizAnswerCountAggregateOutputType | null
    _avg: QuizAnswerAvgAggregateOutputType | null
    _sum: QuizAnswerSumAggregateOutputType | null
    _min: QuizAnswerMinAggregateOutputType | null
    _max: QuizAnswerMaxAggregateOutputType | null
  }

  type GetQuizAnswerGroupByPayload<T extends QuizAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], QuizAnswerGroupByOutputType[P]>
        }
      >
    >


  export type QuizAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    attemptId?: boolean
    questionId?: boolean
    optionId?: boolean
    attempt?: boolean | QuizAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
    option?: boolean | QuizOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAnswer"]>

  export type QuizAnswerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    attemptId?: boolean
    questionId?: boolean
    optionId?: boolean
    attempt?: boolean | QuizAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
    option?: boolean | QuizOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAnswer"]>

  export type QuizAnswerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    attemptId?: boolean
    questionId?: boolean
    optionId?: boolean
    attempt?: boolean | QuizAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
    option?: boolean | QuizOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAnswer"]>

  export type QuizAnswerSelectScalar = {
    attemptId?: boolean
    questionId?: boolean
    optionId?: boolean
  }

  export type QuizAnswerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"attemptId" | "questionId" | "optionId", ExtArgs["result"]["quizAnswer"]>
  export type QuizAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt?: boolean | QuizAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
    option?: boolean | QuizOptionDefaultArgs<ExtArgs>
  }
  export type QuizAnswerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt?: boolean | QuizAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
    option?: boolean | QuizOptionDefaultArgs<ExtArgs>
  }
  export type QuizAnswerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt?: boolean | QuizAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
    option?: boolean | QuizOptionDefaultArgs<ExtArgs>
  }

  export type $QuizAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizAnswer"
    objects: {
      attempt: Prisma.$QuizAttemptPayload<ExtArgs>
      question: Prisma.$QuizQuestionPayload<ExtArgs>
      option: Prisma.$QuizOptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      attemptId: number
      questionId: number
      optionId: number
    }, ExtArgs["result"]["quizAnswer"]>
    composites: {}
  }

  type QuizAnswerGetPayload<S extends boolean | null | undefined | QuizAnswerDefaultArgs> = $Result.GetResult<Prisma.$QuizAnswerPayload, S>

  type QuizAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizAnswerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizAnswerCountAggregateInputType | true
    }

  export interface QuizAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizAnswer'], meta: { name: 'QuizAnswer' } }
    /**
     * Find zero or one QuizAnswer that matches the filter.
     * @param {QuizAnswerFindUniqueArgs} args - Arguments to find a QuizAnswer
     * @example
     * // Get one QuizAnswer
     * const quizAnswer = await prisma.quizAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizAnswerFindUniqueArgs>(args: SelectSubset<T, QuizAnswerFindUniqueArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizAnswer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizAnswerFindUniqueOrThrowArgs} args - Arguments to find a QuizAnswer
     * @example
     * // Get one QuizAnswer
     * const quizAnswer = await prisma.quizAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizAnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizAnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerFindFirstArgs} args - Arguments to find a QuizAnswer
     * @example
     * // Get one QuizAnswer
     * const quizAnswer = await prisma.quizAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizAnswerFindFirstArgs>(args?: SelectSubset<T, QuizAnswerFindFirstArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerFindFirstOrThrowArgs} args - Arguments to find a QuizAnswer
     * @example
     * // Get one QuizAnswer
     * const quizAnswer = await prisma.quizAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizAnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizAnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizAnswers
     * const quizAnswers = await prisma.quizAnswer.findMany()
     * 
     * // Get first 10 QuizAnswers
     * const quizAnswers = await prisma.quizAnswer.findMany({ take: 10 })
     * 
     * // Only select the `attemptId`
     * const quizAnswerWithAttemptIdOnly = await prisma.quizAnswer.findMany({ select: { attemptId: true } })
     * 
     */
    findMany<T extends QuizAnswerFindManyArgs>(args?: SelectSubset<T, QuizAnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizAnswer.
     * @param {QuizAnswerCreateArgs} args - Arguments to create a QuizAnswer.
     * @example
     * // Create one QuizAnswer
     * const QuizAnswer = await prisma.quizAnswer.create({
     *   data: {
     *     // ... data to create a QuizAnswer
     *   }
     * })
     * 
     */
    create<T extends QuizAnswerCreateArgs>(args: SelectSubset<T, QuizAnswerCreateArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizAnswers.
     * @param {QuizAnswerCreateManyArgs} args - Arguments to create many QuizAnswers.
     * @example
     * // Create many QuizAnswers
     * const quizAnswer = await prisma.quizAnswer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizAnswerCreateManyArgs>(args?: SelectSubset<T, QuizAnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizAnswers and returns the data saved in the database.
     * @param {QuizAnswerCreateManyAndReturnArgs} args - Arguments to create many QuizAnswers.
     * @example
     * // Create many QuizAnswers
     * const quizAnswer = await prisma.quizAnswer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizAnswers and only return the `attemptId`
     * const quizAnswerWithAttemptIdOnly = await prisma.quizAnswer.createManyAndReturn({
     *   select: { attemptId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizAnswerCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizAnswerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizAnswer.
     * @param {QuizAnswerDeleteArgs} args - Arguments to delete one QuizAnswer.
     * @example
     * // Delete one QuizAnswer
     * const QuizAnswer = await prisma.quizAnswer.delete({
     *   where: {
     *     // ... filter to delete one QuizAnswer
     *   }
     * })
     * 
     */
    delete<T extends QuizAnswerDeleteArgs>(args: SelectSubset<T, QuizAnswerDeleteArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizAnswer.
     * @param {QuizAnswerUpdateArgs} args - Arguments to update one QuizAnswer.
     * @example
     * // Update one QuizAnswer
     * const quizAnswer = await prisma.quizAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizAnswerUpdateArgs>(args: SelectSubset<T, QuizAnswerUpdateArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizAnswers.
     * @param {QuizAnswerDeleteManyArgs} args - Arguments to filter QuizAnswers to delete.
     * @example
     * // Delete a few QuizAnswers
     * const { count } = await prisma.quizAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizAnswerDeleteManyArgs>(args?: SelectSubset<T, QuizAnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizAnswers
     * const quizAnswer = await prisma.quizAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizAnswerUpdateManyArgs>(args: SelectSubset<T, QuizAnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizAnswers and returns the data updated in the database.
     * @param {QuizAnswerUpdateManyAndReturnArgs} args - Arguments to update many QuizAnswers.
     * @example
     * // Update many QuizAnswers
     * const quizAnswer = await prisma.quizAnswer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizAnswers and only return the `attemptId`
     * const quizAnswerWithAttemptIdOnly = await prisma.quizAnswer.updateManyAndReturn({
     *   select: { attemptId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizAnswerUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizAnswerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizAnswer.
     * @param {QuizAnswerUpsertArgs} args - Arguments to update or create a QuizAnswer.
     * @example
     * // Update or create a QuizAnswer
     * const quizAnswer = await prisma.quizAnswer.upsert({
     *   create: {
     *     // ... data to create a QuizAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizAnswer we want to update
     *   }
     * })
     */
    upsert<T extends QuizAnswerUpsertArgs>(args: SelectSubset<T, QuizAnswerUpsertArgs<ExtArgs>>): Prisma__QuizAnswerClient<$Result.GetResult<Prisma.$QuizAnswerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerCountArgs} args - Arguments to filter QuizAnswers to count.
     * @example
     * // Count the number of QuizAnswers
     * const count = await prisma.quizAnswer.count({
     *   where: {
     *     // ... the filter for the QuizAnswers we want to count
     *   }
     * })
    **/
    count<T extends QuizAnswerCountArgs>(
      args?: Subset<T, QuizAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAnswerAggregateArgs>(args: Subset<T, QuizAnswerAggregateArgs>): Prisma.PrismaPromise<GetQuizAnswerAggregateType<T>>

    /**
     * Group by QuizAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizAnswerGroupByArgs['orderBy'] }
        : { orderBy?: QuizAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizAnswer model
   */
  readonly fields: QuizAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attempt<T extends QuizAttemptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizAttemptDefaultArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    question<T extends QuizQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizQuestionDefaultArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    option<T extends QuizOptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizOptionDefaultArgs<ExtArgs>>): Prisma__QuizOptionClient<$Result.GetResult<Prisma.$QuizOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizAnswer model
   */
  interface QuizAnswerFieldRefs {
    readonly attemptId: FieldRef<"QuizAnswer", 'Int'>
    readonly questionId: FieldRef<"QuizAnswer", 'Int'>
    readonly optionId: FieldRef<"QuizAnswer", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * QuizAnswer findUnique
   */
  export type QuizAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuizAnswer to fetch.
     */
    where: QuizAnswerWhereUniqueInput
  }

  /**
   * QuizAnswer findUniqueOrThrow
   */
  export type QuizAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuizAnswer to fetch.
     */
    where: QuizAnswerWhereUniqueInput
  }

  /**
   * QuizAnswer findFirst
   */
  export type QuizAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuizAnswer to fetch.
     */
    where?: QuizAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAnswers to fetch.
     */
    orderBy?: QuizAnswerOrderByWithRelationInput | QuizAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizAnswers.
     */
    cursor?: QuizAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizAnswers.
     */
    distinct?: QuizAnswerScalarFieldEnum | QuizAnswerScalarFieldEnum[]
  }

  /**
   * QuizAnswer findFirstOrThrow
   */
  export type QuizAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuizAnswer to fetch.
     */
    where?: QuizAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAnswers to fetch.
     */
    orderBy?: QuizAnswerOrderByWithRelationInput | QuizAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizAnswers.
     */
    cursor?: QuizAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizAnswers.
     */
    distinct?: QuizAnswerScalarFieldEnum | QuizAnswerScalarFieldEnum[]
  }

  /**
   * QuizAnswer findMany
   */
  export type QuizAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuizAnswers to fetch.
     */
    where?: QuizAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAnswers to fetch.
     */
    orderBy?: QuizAnswerOrderByWithRelationInput | QuizAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizAnswers.
     */
    cursor?: QuizAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAnswers.
     */
    skip?: number
    distinct?: QuizAnswerScalarFieldEnum | QuizAnswerScalarFieldEnum[]
  }

  /**
   * QuizAnswer create
   */
  export type QuizAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizAnswer.
     */
    data: XOR<QuizAnswerCreateInput, QuizAnswerUncheckedCreateInput>
  }

  /**
   * QuizAnswer createMany
   */
  export type QuizAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizAnswers.
     */
    data: QuizAnswerCreateManyInput | QuizAnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizAnswer createManyAndReturn
   */
  export type QuizAnswerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * The data used to create many QuizAnswers.
     */
    data: QuizAnswerCreateManyInput | QuizAnswerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizAnswer update
   */
  export type QuizAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizAnswer.
     */
    data: XOR<QuizAnswerUpdateInput, QuizAnswerUncheckedUpdateInput>
    /**
     * Choose, which QuizAnswer to update.
     */
    where: QuizAnswerWhereUniqueInput
  }

  /**
   * QuizAnswer updateMany
   */
  export type QuizAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizAnswers.
     */
    data: XOR<QuizAnswerUpdateManyMutationInput, QuizAnswerUncheckedUpdateManyInput>
    /**
     * Filter which QuizAnswers to update
     */
    where?: QuizAnswerWhereInput
    /**
     * Limit how many QuizAnswers to update.
     */
    limit?: number
  }

  /**
   * QuizAnswer updateManyAndReturn
   */
  export type QuizAnswerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * The data used to update QuizAnswers.
     */
    data: XOR<QuizAnswerUpdateManyMutationInput, QuizAnswerUncheckedUpdateManyInput>
    /**
     * Filter which QuizAnswers to update
     */
    where?: QuizAnswerWhereInput
    /**
     * Limit how many QuizAnswers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizAnswer upsert
   */
  export type QuizAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizAnswer to update in case it exists.
     */
    where: QuizAnswerWhereUniqueInput
    /**
     * In case the QuizAnswer found by the `where` argument doesn't exist, create a new QuizAnswer with this data.
     */
    create: XOR<QuizAnswerCreateInput, QuizAnswerUncheckedCreateInput>
    /**
     * In case the QuizAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizAnswerUpdateInput, QuizAnswerUncheckedUpdateInput>
  }

  /**
   * QuizAnswer delete
   */
  export type QuizAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
    /**
     * Filter which QuizAnswer to delete.
     */
    where: QuizAnswerWhereUniqueInput
  }

  /**
   * QuizAnswer deleteMany
   */
  export type QuizAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizAnswers to delete
     */
    where?: QuizAnswerWhereInput
    /**
     * Limit how many QuizAnswers to delete.
     */
    limit?: number
  }

  /**
   * QuizAnswer without action
   */
  export type QuizAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAnswer
     */
    select?: QuizAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAnswer
     */
    omit?: QuizAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAnswerInclude<ExtArgs> | null
  }


  /**
   * Model QuizQuestionGroupMedia
   */

  export type AggregateQuizQuestionGroupMedia = {
    _count: QuizQuestionGroupMediaCountAggregateOutputType | null
    _avg: QuizQuestionGroupMediaAvgAggregateOutputType | null
    _sum: QuizQuestionGroupMediaSumAggregateOutputType | null
    _min: QuizQuestionGroupMediaMinAggregateOutputType | null
    _max: QuizQuestionGroupMediaMaxAggregateOutputType | null
  }

  export type QuizQuestionGroupMediaAvgAggregateOutputType = {
    id: number | null
    groupId: number | null
    mediaId: number | null
  }

  export type QuizQuestionGroupMediaSumAggregateOutputType = {
    id: number | null
    groupId: number | null
    mediaId: number | null
  }

  export type QuizQuestionGroupMediaMinAggregateOutputType = {
    id: number | null
    groupId: number | null
    mediaId: number | null
    createdAt: Date | null
  }

  export type QuizQuestionGroupMediaMaxAggregateOutputType = {
    id: number | null
    groupId: number | null
    mediaId: number | null
    createdAt: Date | null
  }

  export type QuizQuestionGroupMediaCountAggregateOutputType = {
    id: number
    groupId: number
    mediaId: number
    createdAt: number
    _all: number
  }


  export type QuizQuestionGroupMediaAvgAggregateInputType = {
    id?: true
    groupId?: true
    mediaId?: true
  }

  export type QuizQuestionGroupMediaSumAggregateInputType = {
    id?: true
    groupId?: true
    mediaId?: true
  }

  export type QuizQuestionGroupMediaMinAggregateInputType = {
    id?: true
    groupId?: true
    mediaId?: true
    createdAt?: true
  }

  export type QuizQuestionGroupMediaMaxAggregateInputType = {
    id?: true
    groupId?: true
    mediaId?: true
    createdAt?: true
  }

  export type QuizQuestionGroupMediaCountAggregateInputType = {
    id?: true
    groupId?: true
    mediaId?: true
    createdAt?: true
    _all?: true
  }

  export type QuizQuestionGroupMediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestionGroupMedia to aggregate.
     */
    where?: QuizQuestionGroupMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestionGroupMedias to fetch.
     */
    orderBy?: QuizQuestionGroupMediaOrderByWithRelationInput | QuizQuestionGroupMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizQuestionGroupMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestionGroupMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestionGroupMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizQuestionGroupMedias
    **/
    _count?: true | QuizQuestionGroupMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizQuestionGroupMediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizQuestionGroupMediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizQuestionGroupMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizQuestionGroupMediaMaxAggregateInputType
  }

  export type GetQuizQuestionGroupMediaAggregateType<T extends QuizQuestionGroupMediaAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizQuestionGroupMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizQuestionGroupMedia[P]>
      : GetScalarType<T[P], AggregateQuizQuestionGroupMedia[P]>
  }




  export type QuizQuestionGroupMediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionGroupMediaWhereInput
    orderBy?: QuizQuestionGroupMediaOrderByWithAggregationInput | QuizQuestionGroupMediaOrderByWithAggregationInput[]
    by: QuizQuestionGroupMediaScalarFieldEnum[] | QuizQuestionGroupMediaScalarFieldEnum
    having?: QuizQuestionGroupMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizQuestionGroupMediaCountAggregateInputType | true
    _avg?: QuizQuestionGroupMediaAvgAggregateInputType
    _sum?: QuizQuestionGroupMediaSumAggregateInputType
    _min?: QuizQuestionGroupMediaMinAggregateInputType
    _max?: QuizQuestionGroupMediaMaxAggregateInputType
  }

  export type QuizQuestionGroupMediaGroupByOutputType = {
    id: number
    groupId: number
    mediaId: number
    createdAt: Date
    _count: QuizQuestionGroupMediaCountAggregateOutputType | null
    _avg: QuizQuestionGroupMediaAvgAggregateOutputType | null
    _sum: QuizQuestionGroupMediaSumAggregateOutputType | null
    _min: QuizQuestionGroupMediaMinAggregateOutputType | null
    _max: QuizQuestionGroupMediaMaxAggregateOutputType | null
  }

  type GetQuizQuestionGroupMediaGroupByPayload<T extends QuizQuestionGroupMediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizQuestionGroupMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizQuestionGroupMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizQuestionGroupMediaGroupByOutputType[P]>
            : GetScalarType<T[P], QuizQuestionGroupMediaGroupByOutputType[P]>
        }
      >
    >


  export type QuizQuestionGroupMediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    mediaId?: boolean
    createdAt?: boolean
    group?: boolean | QuizQuestionGroupDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestionGroupMedia"]>

  export type QuizQuestionGroupMediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    mediaId?: boolean
    createdAt?: boolean
    group?: boolean | QuizQuestionGroupDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestionGroupMedia"]>

  export type QuizQuestionGroupMediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    mediaId?: boolean
    createdAt?: boolean
    group?: boolean | QuizQuestionGroupDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestionGroupMedia"]>

  export type QuizQuestionGroupMediaSelectScalar = {
    id?: boolean
    groupId?: boolean
    mediaId?: boolean
    createdAt?: boolean
  }

  export type QuizQuestionGroupMediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "groupId" | "mediaId" | "createdAt", ExtArgs["result"]["quizQuestionGroupMedia"]>
  export type QuizQuestionGroupMediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | QuizQuestionGroupDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }
  export type QuizQuestionGroupMediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | QuizQuestionGroupDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }
  export type QuizQuestionGroupMediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | QuizQuestionGroupDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }

  export type $QuizQuestionGroupMediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizQuestionGroupMedia"
    objects: {
      group: Prisma.$QuizQuestionGroupPayload<ExtArgs>
      media: Prisma.$MediaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      groupId: number
      mediaId: number
      createdAt: Date
    }, ExtArgs["result"]["quizQuestionGroupMedia"]>
    composites: {}
  }

  type QuizQuestionGroupMediaGetPayload<S extends boolean | null | undefined | QuizQuestionGroupMediaDefaultArgs> = $Result.GetResult<Prisma.$QuizQuestionGroupMediaPayload, S>

  type QuizQuestionGroupMediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizQuestionGroupMediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizQuestionGroupMediaCountAggregateInputType | true
    }

  export interface QuizQuestionGroupMediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizQuestionGroupMedia'], meta: { name: 'QuizQuestionGroupMedia' } }
    /**
     * Find zero or one QuizQuestionGroupMedia that matches the filter.
     * @param {QuizQuestionGroupMediaFindUniqueArgs} args - Arguments to find a QuizQuestionGroupMedia
     * @example
     * // Get one QuizQuestionGroupMedia
     * const quizQuestionGroupMedia = await prisma.quizQuestionGroupMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizQuestionGroupMediaFindUniqueArgs>(args: SelectSubset<T, QuizQuestionGroupMediaFindUniqueArgs<ExtArgs>>): Prisma__QuizQuestionGroupMediaClient<$Result.GetResult<Prisma.$QuizQuestionGroupMediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizQuestionGroupMedia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizQuestionGroupMediaFindUniqueOrThrowArgs} args - Arguments to find a QuizQuestionGroupMedia
     * @example
     * // Get one QuizQuestionGroupMedia
     * const quizQuestionGroupMedia = await prisma.quizQuestionGroupMedia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizQuestionGroupMediaFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizQuestionGroupMediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionGroupMediaClient<$Result.GetResult<Prisma.$QuizQuestionGroupMediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizQuestionGroupMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionGroupMediaFindFirstArgs} args - Arguments to find a QuizQuestionGroupMedia
     * @example
     * // Get one QuizQuestionGroupMedia
     * const quizQuestionGroupMedia = await prisma.quizQuestionGroupMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizQuestionGroupMediaFindFirstArgs>(args?: SelectSubset<T, QuizQuestionGroupMediaFindFirstArgs<ExtArgs>>): Prisma__QuizQuestionGroupMediaClient<$Result.GetResult<Prisma.$QuizQuestionGroupMediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizQuestionGroupMedia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionGroupMediaFindFirstOrThrowArgs} args - Arguments to find a QuizQuestionGroupMedia
     * @example
     * // Get one QuizQuestionGroupMedia
     * const quizQuestionGroupMedia = await prisma.quizQuestionGroupMedia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizQuestionGroupMediaFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizQuestionGroupMediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionGroupMediaClient<$Result.GetResult<Prisma.$QuizQuestionGroupMediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizQuestionGroupMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionGroupMediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizQuestionGroupMedias
     * const quizQuestionGroupMedias = await prisma.quizQuestionGroupMedia.findMany()
     * 
     * // Get first 10 QuizQuestionGroupMedias
     * const quizQuestionGroupMedias = await prisma.quizQuestionGroupMedia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizQuestionGroupMediaWithIdOnly = await prisma.quizQuestionGroupMedia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizQuestionGroupMediaFindManyArgs>(args?: SelectSubset<T, QuizQuestionGroupMediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionGroupMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizQuestionGroupMedia.
     * @param {QuizQuestionGroupMediaCreateArgs} args - Arguments to create a QuizQuestionGroupMedia.
     * @example
     * // Create one QuizQuestionGroupMedia
     * const QuizQuestionGroupMedia = await prisma.quizQuestionGroupMedia.create({
     *   data: {
     *     // ... data to create a QuizQuestionGroupMedia
     *   }
     * })
     * 
     */
    create<T extends QuizQuestionGroupMediaCreateArgs>(args: SelectSubset<T, QuizQuestionGroupMediaCreateArgs<ExtArgs>>): Prisma__QuizQuestionGroupMediaClient<$Result.GetResult<Prisma.$QuizQuestionGroupMediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizQuestionGroupMedias.
     * @param {QuizQuestionGroupMediaCreateManyArgs} args - Arguments to create many QuizQuestionGroupMedias.
     * @example
     * // Create many QuizQuestionGroupMedias
     * const quizQuestionGroupMedia = await prisma.quizQuestionGroupMedia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizQuestionGroupMediaCreateManyArgs>(args?: SelectSubset<T, QuizQuestionGroupMediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizQuestionGroupMedias and returns the data saved in the database.
     * @param {QuizQuestionGroupMediaCreateManyAndReturnArgs} args - Arguments to create many QuizQuestionGroupMedias.
     * @example
     * // Create many QuizQuestionGroupMedias
     * const quizQuestionGroupMedia = await prisma.quizQuestionGroupMedia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizQuestionGroupMedias and only return the `id`
     * const quizQuestionGroupMediaWithIdOnly = await prisma.quizQuestionGroupMedia.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizQuestionGroupMediaCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizQuestionGroupMediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionGroupMediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizQuestionGroupMedia.
     * @param {QuizQuestionGroupMediaDeleteArgs} args - Arguments to delete one QuizQuestionGroupMedia.
     * @example
     * // Delete one QuizQuestionGroupMedia
     * const QuizQuestionGroupMedia = await prisma.quizQuestionGroupMedia.delete({
     *   where: {
     *     // ... filter to delete one QuizQuestionGroupMedia
     *   }
     * })
     * 
     */
    delete<T extends QuizQuestionGroupMediaDeleteArgs>(args: SelectSubset<T, QuizQuestionGroupMediaDeleteArgs<ExtArgs>>): Prisma__QuizQuestionGroupMediaClient<$Result.GetResult<Prisma.$QuizQuestionGroupMediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizQuestionGroupMedia.
     * @param {QuizQuestionGroupMediaUpdateArgs} args - Arguments to update one QuizQuestionGroupMedia.
     * @example
     * // Update one QuizQuestionGroupMedia
     * const quizQuestionGroupMedia = await prisma.quizQuestionGroupMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizQuestionGroupMediaUpdateArgs>(args: SelectSubset<T, QuizQuestionGroupMediaUpdateArgs<ExtArgs>>): Prisma__QuizQuestionGroupMediaClient<$Result.GetResult<Prisma.$QuizQuestionGroupMediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizQuestionGroupMedias.
     * @param {QuizQuestionGroupMediaDeleteManyArgs} args - Arguments to filter QuizQuestionGroupMedias to delete.
     * @example
     * // Delete a few QuizQuestionGroupMedias
     * const { count } = await prisma.quizQuestionGroupMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizQuestionGroupMediaDeleteManyArgs>(args?: SelectSubset<T, QuizQuestionGroupMediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestionGroupMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionGroupMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizQuestionGroupMedias
     * const quizQuestionGroupMedia = await prisma.quizQuestionGroupMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizQuestionGroupMediaUpdateManyArgs>(args: SelectSubset<T, QuizQuestionGroupMediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestionGroupMedias and returns the data updated in the database.
     * @param {QuizQuestionGroupMediaUpdateManyAndReturnArgs} args - Arguments to update many QuizQuestionGroupMedias.
     * @example
     * // Update many QuizQuestionGroupMedias
     * const quizQuestionGroupMedia = await prisma.quizQuestionGroupMedia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizQuestionGroupMedias and only return the `id`
     * const quizQuestionGroupMediaWithIdOnly = await prisma.quizQuestionGroupMedia.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizQuestionGroupMediaUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizQuestionGroupMediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionGroupMediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizQuestionGroupMedia.
     * @param {QuizQuestionGroupMediaUpsertArgs} args - Arguments to update or create a QuizQuestionGroupMedia.
     * @example
     * // Update or create a QuizQuestionGroupMedia
     * const quizQuestionGroupMedia = await prisma.quizQuestionGroupMedia.upsert({
     *   create: {
     *     // ... data to create a QuizQuestionGroupMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizQuestionGroupMedia we want to update
     *   }
     * })
     */
    upsert<T extends QuizQuestionGroupMediaUpsertArgs>(args: SelectSubset<T, QuizQuestionGroupMediaUpsertArgs<ExtArgs>>): Prisma__QuizQuestionGroupMediaClient<$Result.GetResult<Prisma.$QuizQuestionGroupMediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizQuestionGroupMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionGroupMediaCountArgs} args - Arguments to filter QuizQuestionGroupMedias to count.
     * @example
     * // Count the number of QuizQuestionGroupMedias
     * const count = await prisma.quizQuestionGroupMedia.count({
     *   where: {
     *     // ... the filter for the QuizQuestionGroupMedias we want to count
     *   }
     * })
    **/
    count<T extends QuizQuestionGroupMediaCountArgs>(
      args?: Subset<T, QuizQuestionGroupMediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizQuestionGroupMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizQuestionGroupMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionGroupMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizQuestionGroupMediaAggregateArgs>(args: Subset<T, QuizQuestionGroupMediaAggregateArgs>): Prisma.PrismaPromise<GetQuizQuestionGroupMediaAggregateType<T>>

    /**
     * Group by QuizQuestionGroupMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionGroupMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizQuestionGroupMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizQuestionGroupMediaGroupByArgs['orderBy'] }
        : { orderBy?: QuizQuestionGroupMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizQuestionGroupMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizQuestionGroupMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizQuestionGroupMedia model
   */
  readonly fields: QuizQuestionGroupMediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizQuestionGroupMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizQuestionGroupMediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends QuizQuestionGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizQuestionGroupDefaultArgs<ExtArgs>>): Prisma__QuizQuestionGroupClient<$Result.GetResult<Prisma.$QuizQuestionGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    media<T extends MediaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MediaDefaultArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizQuestionGroupMedia model
   */
  interface QuizQuestionGroupMediaFieldRefs {
    readonly id: FieldRef<"QuizQuestionGroupMedia", 'Int'>
    readonly groupId: FieldRef<"QuizQuestionGroupMedia", 'Int'>
    readonly mediaId: FieldRef<"QuizQuestionGroupMedia", 'Int'>
    readonly createdAt: FieldRef<"QuizQuestionGroupMedia", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizQuestionGroupMedia findUnique
   */
  export type QuizQuestionGroupMediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroupMedia
     */
    select?: QuizQuestionGroupMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroupMedia
     */
    omit?: QuizQuestionGroupMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupMediaInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestionGroupMedia to fetch.
     */
    where: QuizQuestionGroupMediaWhereUniqueInput
  }

  /**
   * QuizQuestionGroupMedia findUniqueOrThrow
   */
  export type QuizQuestionGroupMediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroupMedia
     */
    select?: QuizQuestionGroupMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroupMedia
     */
    omit?: QuizQuestionGroupMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupMediaInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestionGroupMedia to fetch.
     */
    where: QuizQuestionGroupMediaWhereUniqueInput
  }

  /**
   * QuizQuestionGroupMedia findFirst
   */
  export type QuizQuestionGroupMediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroupMedia
     */
    select?: QuizQuestionGroupMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroupMedia
     */
    omit?: QuizQuestionGroupMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupMediaInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestionGroupMedia to fetch.
     */
    where?: QuizQuestionGroupMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestionGroupMedias to fetch.
     */
    orderBy?: QuizQuestionGroupMediaOrderByWithRelationInput | QuizQuestionGroupMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestionGroupMedias.
     */
    cursor?: QuizQuestionGroupMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestionGroupMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestionGroupMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestionGroupMedias.
     */
    distinct?: QuizQuestionGroupMediaScalarFieldEnum | QuizQuestionGroupMediaScalarFieldEnum[]
  }

  /**
   * QuizQuestionGroupMedia findFirstOrThrow
   */
  export type QuizQuestionGroupMediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroupMedia
     */
    select?: QuizQuestionGroupMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroupMedia
     */
    omit?: QuizQuestionGroupMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupMediaInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestionGroupMedia to fetch.
     */
    where?: QuizQuestionGroupMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestionGroupMedias to fetch.
     */
    orderBy?: QuizQuestionGroupMediaOrderByWithRelationInput | QuizQuestionGroupMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestionGroupMedias.
     */
    cursor?: QuizQuestionGroupMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestionGroupMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestionGroupMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestionGroupMedias.
     */
    distinct?: QuizQuestionGroupMediaScalarFieldEnum | QuizQuestionGroupMediaScalarFieldEnum[]
  }

  /**
   * QuizQuestionGroupMedia findMany
   */
  export type QuizQuestionGroupMediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroupMedia
     */
    select?: QuizQuestionGroupMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroupMedia
     */
    omit?: QuizQuestionGroupMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupMediaInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestionGroupMedias to fetch.
     */
    where?: QuizQuestionGroupMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestionGroupMedias to fetch.
     */
    orderBy?: QuizQuestionGroupMediaOrderByWithRelationInput | QuizQuestionGroupMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizQuestionGroupMedias.
     */
    cursor?: QuizQuestionGroupMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestionGroupMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestionGroupMedias.
     */
    skip?: number
    distinct?: QuizQuestionGroupMediaScalarFieldEnum | QuizQuestionGroupMediaScalarFieldEnum[]
  }

  /**
   * QuizQuestionGroupMedia create
   */
  export type QuizQuestionGroupMediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroupMedia
     */
    select?: QuizQuestionGroupMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroupMedia
     */
    omit?: QuizQuestionGroupMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupMediaInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizQuestionGroupMedia.
     */
    data: XOR<QuizQuestionGroupMediaCreateInput, QuizQuestionGroupMediaUncheckedCreateInput>
  }

  /**
   * QuizQuestionGroupMedia createMany
   */
  export type QuizQuestionGroupMediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizQuestionGroupMedias.
     */
    data: QuizQuestionGroupMediaCreateManyInput | QuizQuestionGroupMediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizQuestionGroupMedia createManyAndReturn
   */
  export type QuizQuestionGroupMediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroupMedia
     */
    select?: QuizQuestionGroupMediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroupMedia
     */
    omit?: QuizQuestionGroupMediaOmit<ExtArgs> | null
    /**
     * The data used to create many QuizQuestionGroupMedias.
     */
    data: QuizQuestionGroupMediaCreateManyInput | QuizQuestionGroupMediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupMediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizQuestionGroupMedia update
   */
  export type QuizQuestionGroupMediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroupMedia
     */
    select?: QuizQuestionGroupMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroupMedia
     */
    omit?: QuizQuestionGroupMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupMediaInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizQuestionGroupMedia.
     */
    data: XOR<QuizQuestionGroupMediaUpdateInput, QuizQuestionGroupMediaUncheckedUpdateInput>
    /**
     * Choose, which QuizQuestionGroupMedia to update.
     */
    where: QuizQuestionGroupMediaWhereUniqueInput
  }

  /**
   * QuizQuestionGroupMedia updateMany
   */
  export type QuizQuestionGroupMediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizQuestionGroupMedias.
     */
    data: XOR<QuizQuestionGroupMediaUpdateManyMutationInput, QuizQuestionGroupMediaUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestionGroupMedias to update
     */
    where?: QuizQuestionGroupMediaWhereInput
    /**
     * Limit how many QuizQuestionGroupMedias to update.
     */
    limit?: number
  }

  /**
   * QuizQuestionGroupMedia updateManyAndReturn
   */
  export type QuizQuestionGroupMediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroupMedia
     */
    select?: QuizQuestionGroupMediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroupMedia
     */
    omit?: QuizQuestionGroupMediaOmit<ExtArgs> | null
    /**
     * The data used to update QuizQuestionGroupMedias.
     */
    data: XOR<QuizQuestionGroupMediaUpdateManyMutationInput, QuizQuestionGroupMediaUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestionGroupMedias to update
     */
    where?: QuizQuestionGroupMediaWhereInput
    /**
     * Limit how many QuizQuestionGroupMedias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupMediaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizQuestionGroupMedia upsert
   */
  export type QuizQuestionGroupMediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroupMedia
     */
    select?: QuizQuestionGroupMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroupMedia
     */
    omit?: QuizQuestionGroupMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupMediaInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizQuestionGroupMedia to update in case it exists.
     */
    where: QuizQuestionGroupMediaWhereUniqueInput
    /**
     * In case the QuizQuestionGroupMedia found by the `where` argument doesn't exist, create a new QuizQuestionGroupMedia with this data.
     */
    create: XOR<QuizQuestionGroupMediaCreateInput, QuizQuestionGroupMediaUncheckedCreateInput>
    /**
     * In case the QuizQuestionGroupMedia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizQuestionGroupMediaUpdateInput, QuizQuestionGroupMediaUncheckedUpdateInput>
  }

  /**
   * QuizQuestionGroupMedia delete
   */
  export type QuizQuestionGroupMediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroupMedia
     */
    select?: QuizQuestionGroupMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroupMedia
     */
    omit?: QuizQuestionGroupMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupMediaInclude<ExtArgs> | null
    /**
     * Filter which QuizQuestionGroupMedia to delete.
     */
    where: QuizQuestionGroupMediaWhereUniqueInput
  }

  /**
   * QuizQuestionGroupMedia deleteMany
   */
  export type QuizQuestionGroupMediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestionGroupMedias to delete
     */
    where?: QuizQuestionGroupMediaWhereInput
    /**
     * Limit how many QuizQuestionGroupMedias to delete.
     */
    limit?: number
  }

  /**
   * QuizQuestionGroupMedia without action
   */
  export type QuizQuestionGroupMediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionGroupMedia
     */
    select?: QuizQuestionGroupMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionGroupMedia
     */
    omit?: QuizQuestionGroupMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionGroupMediaInclude<ExtArgs> | null
  }


  /**
   * Model QuizQuestionMedia
   */

  export type AggregateQuizQuestionMedia = {
    _count: QuizQuestionMediaCountAggregateOutputType | null
    _avg: QuizQuestionMediaAvgAggregateOutputType | null
    _sum: QuizQuestionMediaSumAggregateOutputType | null
    _min: QuizQuestionMediaMinAggregateOutputType | null
    _max: QuizQuestionMediaMaxAggregateOutputType | null
  }

  export type QuizQuestionMediaAvgAggregateOutputType = {
    id: number | null
    questionId: number | null
    mediaId: number | null
  }

  export type QuizQuestionMediaSumAggregateOutputType = {
    id: number | null
    questionId: number | null
    mediaId: number | null
  }

  export type QuizQuestionMediaMinAggregateOutputType = {
    id: number | null
    questionId: number | null
    mediaId: number | null
    createdAt: Date | null
  }

  export type QuizQuestionMediaMaxAggregateOutputType = {
    id: number | null
    questionId: number | null
    mediaId: number | null
    createdAt: Date | null
  }

  export type QuizQuestionMediaCountAggregateOutputType = {
    id: number
    questionId: number
    mediaId: number
    createdAt: number
    _all: number
  }


  export type QuizQuestionMediaAvgAggregateInputType = {
    id?: true
    questionId?: true
    mediaId?: true
  }

  export type QuizQuestionMediaSumAggregateInputType = {
    id?: true
    questionId?: true
    mediaId?: true
  }

  export type QuizQuestionMediaMinAggregateInputType = {
    id?: true
    questionId?: true
    mediaId?: true
    createdAt?: true
  }

  export type QuizQuestionMediaMaxAggregateInputType = {
    id?: true
    questionId?: true
    mediaId?: true
    createdAt?: true
  }

  export type QuizQuestionMediaCountAggregateInputType = {
    id?: true
    questionId?: true
    mediaId?: true
    createdAt?: true
    _all?: true
  }

  export type QuizQuestionMediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestionMedia to aggregate.
     */
    where?: QuizQuestionMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestionMedias to fetch.
     */
    orderBy?: QuizQuestionMediaOrderByWithRelationInput | QuizQuestionMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizQuestionMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestionMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestionMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizQuestionMedias
    **/
    _count?: true | QuizQuestionMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizQuestionMediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizQuestionMediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizQuestionMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizQuestionMediaMaxAggregateInputType
  }

  export type GetQuizQuestionMediaAggregateType<T extends QuizQuestionMediaAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizQuestionMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizQuestionMedia[P]>
      : GetScalarType<T[P], AggregateQuizQuestionMedia[P]>
  }




  export type QuizQuestionMediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionMediaWhereInput
    orderBy?: QuizQuestionMediaOrderByWithAggregationInput | QuizQuestionMediaOrderByWithAggregationInput[]
    by: QuizQuestionMediaScalarFieldEnum[] | QuizQuestionMediaScalarFieldEnum
    having?: QuizQuestionMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizQuestionMediaCountAggregateInputType | true
    _avg?: QuizQuestionMediaAvgAggregateInputType
    _sum?: QuizQuestionMediaSumAggregateInputType
    _min?: QuizQuestionMediaMinAggregateInputType
    _max?: QuizQuestionMediaMaxAggregateInputType
  }

  export type QuizQuestionMediaGroupByOutputType = {
    id: number
    questionId: number
    mediaId: number
    createdAt: Date
    _count: QuizQuestionMediaCountAggregateOutputType | null
    _avg: QuizQuestionMediaAvgAggregateOutputType | null
    _sum: QuizQuestionMediaSumAggregateOutputType | null
    _min: QuizQuestionMediaMinAggregateOutputType | null
    _max: QuizQuestionMediaMaxAggregateOutputType | null
  }

  type GetQuizQuestionMediaGroupByPayload<T extends QuizQuestionMediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizQuestionMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizQuestionMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizQuestionMediaGroupByOutputType[P]>
            : GetScalarType<T[P], QuizQuestionMediaGroupByOutputType[P]>
        }
      >
    >


  export type QuizQuestionMediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    mediaId?: boolean
    createdAt?: boolean
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestionMedia"]>

  export type QuizQuestionMediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    mediaId?: boolean
    createdAt?: boolean
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestionMedia"]>

  export type QuizQuestionMediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    mediaId?: boolean
    createdAt?: boolean
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestionMedia"]>

  export type QuizQuestionMediaSelectScalar = {
    id?: boolean
    questionId?: boolean
    mediaId?: boolean
    createdAt?: boolean
  }

  export type QuizQuestionMediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "questionId" | "mediaId" | "createdAt", ExtArgs["result"]["quizQuestionMedia"]>
  export type QuizQuestionMediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }
  export type QuizQuestionMediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }
  export type QuizQuestionMediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuizQuestionDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }

  export type $QuizQuestionMediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizQuestionMedia"
    objects: {
      question: Prisma.$QuizQuestionPayload<ExtArgs>
      media: Prisma.$MediaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      questionId: number
      mediaId: number
      createdAt: Date
    }, ExtArgs["result"]["quizQuestionMedia"]>
    composites: {}
  }

  type QuizQuestionMediaGetPayload<S extends boolean | null | undefined | QuizQuestionMediaDefaultArgs> = $Result.GetResult<Prisma.$QuizQuestionMediaPayload, S>

  type QuizQuestionMediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizQuestionMediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizQuestionMediaCountAggregateInputType | true
    }

  export interface QuizQuestionMediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizQuestionMedia'], meta: { name: 'QuizQuestionMedia' } }
    /**
     * Find zero or one QuizQuestionMedia that matches the filter.
     * @param {QuizQuestionMediaFindUniqueArgs} args - Arguments to find a QuizQuestionMedia
     * @example
     * // Get one QuizQuestionMedia
     * const quizQuestionMedia = await prisma.quizQuestionMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizQuestionMediaFindUniqueArgs>(args: SelectSubset<T, QuizQuestionMediaFindUniqueArgs<ExtArgs>>): Prisma__QuizQuestionMediaClient<$Result.GetResult<Prisma.$QuizQuestionMediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizQuestionMedia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizQuestionMediaFindUniqueOrThrowArgs} args - Arguments to find a QuizQuestionMedia
     * @example
     * // Get one QuizQuestionMedia
     * const quizQuestionMedia = await prisma.quizQuestionMedia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizQuestionMediaFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizQuestionMediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionMediaClient<$Result.GetResult<Prisma.$QuizQuestionMediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizQuestionMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionMediaFindFirstArgs} args - Arguments to find a QuizQuestionMedia
     * @example
     * // Get one QuizQuestionMedia
     * const quizQuestionMedia = await prisma.quizQuestionMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizQuestionMediaFindFirstArgs>(args?: SelectSubset<T, QuizQuestionMediaFindFirstArgs<ExtArgs>>): Prisma__QuizQuestionMediaClient<$Result.GetResult<Prisma.$QuizQuestionMediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizQuestionMedia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionMediaFindFirstOrThrowArgs} args - Arguments to find a QuizQuestionMedia
     * @example
     * // Get one QuizQuestionMedia
     * const quizQuestionMedia = await prisma.quizQuestionMedia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizQuestionMediaFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizQuestionMediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionMediaClient<$Result.GetResult<Prisma.$QuizQuestionMediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizQuestionMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionMediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizQuestionMedias
     * const quizQuestionMedias = await prisma.quizQuestionMedia.findMany()
     * 
     * // Get first 10 QuizQuestionMedias
     * const quizQuestionMedias = await prisma.quizQuestionMedia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizQuestionMediaWithIdOnly = await prisma.quizQuestionMedia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizQuestionMediaFindManyArgs>(args?: SelectSubset<T, QuizQuestionMediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizQuestionMedia.
     * @param {QuizQuestionMediaCreateArgs} args - Arguments to create a QuizQuestionMedia.
     * @example
     * // Create one QuizQuestionMedia
     * const QuizQuestionMedia = await prisma.quizQuestionMedia.create({
     *   data: {
     *     // ... data to create a QuizQuestionMedia
     *   }
     * })
     * 
     */
    create<T extends QuizQuestionMediaCreateArgs>(args: SelectSubset<T, QuizQuestionMediaCreateArgs<ExtArgs>>): Prisma__QuizQuestionMediaClient<$Result.GetResult<Prisma.$QuizQuestionMediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizQuestionMedias.
     * @param {QuizQuestionMediaCreateManyArgs} args - Arguments to create many QuizQuestionMedias.
     * @example
     * // Create many QuizQuestionMedias
     * const quizQuestionMedia = await prisma.quizQuestionMedia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizQuestionMediaCreateManyArgs>(args?: SelectSubset<T, QuizQuestionMediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizQuestionMedias and returns the data saved in the database.
     * @param {QuizQuestionMediaCreateManyAndReturnArgs} args - Arguments to create many QuizQuestionMedias.
     * @example
     * // Create many QuizQuestionMedias
     * const quizQuestionMedia = await prisma.quizQuestionMedia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizQuestionMedias and only return the `id`
     * const quizQuestionMediaWithIdOnly = await prisma.quizQuestionMedia.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizQuestionMediaCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizQuestionMediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionMediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizQuestionMedia.
     * @param {QuizQuestionMediaDeleteArgs} args - Arguments to delete one QuizQuestionMedia.
     * @example
     * // Delete one QuizQuestionMedia
     * const QuizQuestionMedia = await prisma.quizQuestionMedia.delete({
     *   where: {
     *     // ... filter to delete one QuizQuestionMedia
     *   }
     * })
     * 
     */
    delete<T extends QuizQuestionMediaDeleteArgs>(args: SelectSubset<T, QuizQuestionMediaDeleteArgs<ExtArgs>>): Prisma__QuizQuestionMediaClient<$Result.GetResult<Prisma.$QuizQuestionMediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizQuestionMedia.
     * @param {QuizQuestionMediaUpdateArgs} args - Arguments to update one QuizQuestionMedia.
     * @example
     * // Update one QuizQuestionMedia
     * const quizQuestionMedia = await prisma.quizQuestionMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizQuestionMediaUpdateArgs>(args: SelectSubset<T, QuizQuestionMediaUpdateArgs<ExtArgs>>): Prisma__QuizQuestionMediaClient<$Result.GetResult<Prisma.$QuizQuestionMediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizQuestionMedias.
     * @param {QuizQuestionMediaDeleteManyArgs} args - Arguments to filter QuizQuestionMedias to delete.
     * @example
     * // Delete a few QuizQuestionMedias
     * const { count } = await prisma.quizQuestionMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizQuestionMediaDeleteManyArgs>(args?: SelectSubset<T, QuizQuestionMediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestionMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizQuestionMedias
     * const quizQuestionMedia = await prisma.quizQuestionMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizQuestionMediaUpdateManyArgs>(args: SelectSubset<T, QuizQuestionMediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestionMedias and returns the data updated in the database.
     * @param {QuizQuestionMediaUpdateManyAndReturnArgs} args - Arguments to update many QuizQuestionMedias.
     * @example
     * // Update many QuizQuestionMedias
     * const quizQuestionMedia = await prisma.quizQuestionMedia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizQuestionMedias and only return the `id`
     * const quizQuestionMediaWithIdOnly = await prisma.quizQuestionMedia.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizQuestionMediaUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizQuestionMediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionMediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizQuestionMedia.
     * @param {QuizQuestionMediaUpsertArgs} args - Arguments to update or create a QuizQuestionMedia.
     * @example
     * // Update or create a QuizQuestionMedia
     * const quizQuestionMedia = await prisma.quizQuestionMedia.upsert({
     *   create: {
     *     // ... data to create a QuizQuestionMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizQuestionMedia we want to update
     *   }
     * })
     */
    upsert<T extends QuizQuestionMediaUpsertArgs>(args: SelectSubset<T, QuizQuestionMediaUpsertArgs<ExtArgs>>): Prisma__QuizQuestionMediaClient<$Result.GetResult<Prisma.$QuizQuestionMediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizQuestionMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionMediaCountArgs} args - Arguments to filter QuizQuestionMedias to count.
     * @example
     * // Count the number of QuizQuestionMedias
     * const count = await prisma.quizQuestionMedia.count({
     *   where: {
     *     // ... the filter for the QuizQuestionMedias we want to count
     *   }
     * })
    **/
    count<T extends QuizQuestionMediaCountArgs>(
      args?: Subset<T, QuizQuestionMediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizQuestionMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizQuestionMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizQuestionMediaAggregateArgs>(args: Subset<T, QuizQuestionMediaAggregateArgs>): Prisma.PrismaPromise<GetQuizQuestionMediaAggregateType<T>>

    /**
     * Group by QuizQuestionMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizQuestionMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizQuestionMediaGroupByArgs['orderBy'] }
        : { orderBy?: QuizQuestionMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizQuestionMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizQuestionMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizQuestionMedia model
   */
  readonly fields: QuizQuestionMediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizQuestionMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizQuestionMediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    question<T extends QuizQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizQuestionDefaultArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    media<T extends MediaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MediaDefaultArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizQuestionMedia model
   */
  interface QuizQuestionMediaFieldRefs {
    readonly id: FieldRef<"QuizQuestionMedia", 'Int'>
    readonly questionId: FieldRef<"QuizQuestionMedia", 'Int'>
    readonly mediaId: FieldRef<"QuizQuestionMedia", 'Int'>
    readonly createdAt: FieldRef<"QuizQuestionMedia", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizQuestionMedia findUnique
   */
  export type QuizQuestionMediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionMedia
     */
    select?: QuizQuestionMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionMedia
     */
    omit?: QuizQuestionMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionMediaInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestionMedia to fetch.
     */
    where: QuizQuestionMediaWhereUniqueInput
  }

  /**
   * QuizQuestionMedia findUniqueOrThrow
   */
  export type QuizQuestionMediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionMedia
     */
    select?: QuizQuestionMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionMedia
     */
    omit?: QuizQuestionMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionMediaInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestionMedia to fetch.
     */
    where: QuizQuestionMediaWhereUniqueInput
  }

  /**
   * QuizQuestionMedia findFirst
   */
  export type QuizQuestionMediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionMedia
     */
    select?: QuizQuestionMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionMedia
     */
    omit?: QuizQuestionMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionMediaInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestionMedia to fetch.
     */
    where?: QuizQuestionMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestionMedias to fetch.
     */
    orderBy?: QuizQuestionMediaOrderByWithRelationInput | QuizQuestionMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestionMedias.
     */
    cursor?: QuizQuestionMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestionMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestionMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestionMedias.
     */
    distinct?: QuizQuestionMediaScalarFieldEnum | QuizQuestionMediaScalarFieldEnum[]
  }

  /**
   * QuizQuestionMedia findFirstOrThrow
   */
  export type QuizQuestionMediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionMedia
     */
    select?: QuizQuestionMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionMedia
     */
    omit?: QuizQuestionMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionMediaInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestionMedia to fetch.
     */
    where?: QuizQuestionMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestionMedias to fetch.
     */
    orderBy?: QuizQuestionMediaOrderByWithRelationInput | QuizQuestionMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestionMedias.
     */
    cursor?: QuizQuestionMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestionMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestionMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestionMedias.
     */
    distinct?: QuizQuestionMediaScalarFieldEnum | QuizQuestionMediaScalarFieldEnum[]
  }

  /**
   * QuizQuestionMedia findMany
   */
  export type QuizQuestionMediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionMedia
     */
    select?: QuizQuestionMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionMedia
     */
    omit?: QuizQuestionMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionMediaInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestionMedias to fetch.
     */
    where?: QuizQuestionMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestionMedias to fetch.
     */
    orderBy?: QuizQuestionMediaOrderByWithRelationInput | QuizQuestionMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizQuestionMedias.
     */
    cursor?: QuizQuestionMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestionMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestionMedias.
     */
    skip?: number
    distinct?: QuizQuestionMediaScalarFieldEnum | QuizQuestionMediaScalarFieldEnum[]
  }

  /**
   * QuizQuestionMedia create
   */
  export type QuizQuestionMediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionMedia
     */
    select?: QuizQuestionMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionMedia
     */
    omit?: QuizQuestionMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionMediaInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizQuestionMedia.
     */
    data: XOR<QuizQuestionMediaCreateInput, QuizQuestionMediaUncheckedCreateInput>
  }

  /**
   * QuizQuestionMedia createMany
   */
  export type QuizQuestionMediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizQuestionMedias.
     */
    data: QuizQuestionMediaCreateManyInput | QuizQuestionMediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizQuestionMedia createManyAndReturn
   */
  export type QuizQuestionMediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionMedia
     */
    select?: QuizQuestionMediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionMedia
     */
    omit?: QuizQuestionMediaOmit<ExtArgs> | null
    /**
     * The data used to create many QuizQuestionMedias.
     */
    data: QuizQuestionMediaCreateManyInput | QuizQuestionMediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionMediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizQuestionMedia update
   */
  export type QuizQuestionMediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionMedia
     */
    select?: QuizQuestionMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionMedia
     */
    omit?: QuizQuestionMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionMediaInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizQuestionMedia.
     */
    data: XOR<QuizQuestionMediaUpdateInput, QuizQuestionMediaUncheckedUpdateInput>
    /**
     * Choose, which QuizQuestionMedia to update.
     */
    where: QuizQuestionMediaWhereUniqueInput
  }

  /**
   * QuizQuestionMedia updateMany
   */
  export type QuizQuestionMediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizQuestionMedias.
     */
    data: XOR<QuizQuestionMediaUpdateManyMutationInput, QuizQuestionMediaUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestionMedias to update
     */
    where?: QuizQuestionMediaWhereInput
    /**
     * Limit how many QuizQuestionMedias to update.
     */
    limit?: number
  }

  /**
   * QuizQuestionMedia updateManyAndReturn
   */
  export type QuizQuestionMediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionMedia
     */
    select?: QuizQuestionMediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionMedia
     */
    omit?: QuizQuestionMediaOmit<ExtArgs> | null
    /**
     * The data used to update QuizQuestionMedias.
     */
    data: XOR<QuizQuestionMediaUpdateManyMutationInput, QuizQuestionMediaUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestionMedias to update
     */
    where?: QuizQuestionMediaWhereInput
    /**
     * Limit how many QuizQuestionMedias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionMediaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizQuestionMedia upsert
   */
  export type QuizQuestionMediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionMedia
     */
    select?: QuizQuestionMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionMedia
     */
    omit?: QuizQuestionMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionMediaInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizQuestionMedia to update in case it exists.
     */
    where: QuizQuestionMediaWhereUniqueInput
    /**
     * In case the QuizQuestionMedia found by the `where` argument doesn't exist, create a new QuizQuestionMedia with this data.
     */
    create: XOR<QuizQuestionMediaCreateInput, QuizQuestionMediaUncheckedCreateInput>
    /**
     * In case the QuizQuestionMedia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizQuestionMediaUpdateInput, QuizQuestionMediaUncheckedUpdateInput>
  }

  /**
   * QuizQuestionMedia delete
   */
  export type QuizQuestionMediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionMedia
     */
    select?: QuizQuestionMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionMedia
     */
    omit?: QuizQuestionMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionMediaInclude<ExtArgs> | null
    /**
     * Filter which QuizQuestionMedia to delete.
     */
    where: QuizQuestionMediaWhereUniqueInput
  }

  /**
   * QuizQuestionMedia deleteMany
   */
  export type QuizQuestionMediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestionMedias to delete
     */
    where?: QuizQuestionMediaWhereInput
    /**
     * Limit how many QuizQuestionMedias to delete.
     */
    limit?: number
  }

  /**
   * QuizQuestionMedia without action
   */
  export type QuizQuestionMediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestionMedia
     */
    select?: QuizQuestionMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestionMedia
     */
    omit?: QuizQuestionMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionMediaInclude<ExtArgs> | null
  }


  /**
   * Model QuizOptionMedia
   */

  export type AggregateQuizOptionMedia = {
    _count: QuizOptionMediaCountAggregateOutputType | null
    _avg: QuizOptionMediaAvgAggregateOutputType | null
    _sum: QuizOptionMediaSumAggregateOutputType | null
    _min: QuizOptionMediaMinAggregateOutputType | null
    _max: QuizOptionMediaMaxAggregateOutputType | null
  }

  export type QuizOptionMediaAvgAggregateOutputType = {
    id: number | null
    optionId: number | null
    mediaId: number | null
  }

  export type QuizOptionMediaSumAggregateOutputType = {
    id: number | null
    optionId: number | null
    mediaId: number | null
  }

  export type QuizOptionMediaMinAggregateOutputType = {
    id: number | null
    optionId: number | null
    mediaId: number | null
    createdAt: Date | null
  }

  export type QuizOptionMediaMaxAggregateOutputType = {
    id: number | null
    optionId: number | null
    mediaId: number | null
    createdAt: Date | null
  }

  export type QuizOptionMediaCountAggregateOutputType = {
    id: number
    optionId: number
    mediaId: number
    createdAt: number
    _all: number
  }


  export type QuizOptionMediaAvgAggregateInputType = {
    id?: true
    optionId?: true
    mediaId?: true
  }

  export type QuizOptionMediaSumAggregateInputType = {
    id?: true
    optionId?: true
    mediaId?: true
  }

  export type QuizOptionMediaMinAggregateInputType = {
    id?: true
    optionId?: true
    mediaId?: true
    createdAt?: true
  }

  export type QuizOptionMediaMaxAggregateInputType = {
    id?: true
    optionId?: true
    mediaId?: true
    createdAt?: true
  }

  export type QuizOptionMediaCountAggregateInputType = {
    id?: true
    optionId?: true
    mediaId?: true
    createdAt?: true
    _all?: true
  }

  export type QuizOptionMediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizOptionMedia to aggregate.
     */
    where?: QuizOptionMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizOptionMedias to fetch.
     */
    orderBy?: QuizOptionMediaOrderByWithRelationInput | QuizOptionMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizOptionMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizOptionMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizOptionMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizOptionMedias
    **/
    _count?: true | QuizOptionMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizOptionMediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizOptionMediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizOptionMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizOptionMediaMaxAggregateInputType
  }

  export type GetQuizOptionMediaAggregateType<T extends QuizOptionMediaAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizOptionMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizOptionMedia[P]>
      : GetScalarType<T[P], AggregateQuizOptionMedia[P]>
  }




  export type QuizOptionMediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizOptionMediaWhereInput
    orderBy?: QuizOptionMediaOrderByWithAggregationInput | QuizOptionMediaOrderByWithAggregationInput[]
    by: QuizOptionMediaScalarFieldEnum[] | QuizOptionMediaScalarFieldEnum
    having?: QuizOptionMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizOptionMediaCountAggregateInputType | true
    _avg?: QuizOptionMediaAvgAggregateInputType
    _sum?: QuizOptionMediaSumAggregateInputType
    _min?: QuizOptionMediaMinAggregateInputType
    _max?: QuizOptionMediaMaxAggregateInputType
  }

  export type QuizOptionMediaGroupByOutputType = {
    id: number
    optionId: number
    mediaId: number
    createdAt: Date
    _count: QuizOptionMediaCountAggregateOutputType | null
    _avg: QuizOptionMediaAvgAggregateOutputType | null
    _sum: QuizOptionMediaSumAggregateOutputType | null
    _min: QuizOptionMediaMinAggregateOutputType | null
    _max: QuizOptionMediaMaxAggregateOutputType | null
  }

  type GetQuizOptionMediaGroupByPayload<T extends QuizOptionMediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizOptionMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizOptionMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizOptionMediaGroupByOutputType[P]>
            : GetScalarType<T[P], QuizOptionMediaGroupByOutputType[P]>
        }
      >
    >


  export type QuizOptionMediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    optionId?: boolean
    mediaId?: boolean
    createdAt?: boolean
    option?: boolean | QuizOptionDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizOptionMedia"]>

  export type QuizOptionMediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    optionId?: boolean
    mediaId?: boolean
    createdAt?: boolean
    option?: boolean | QuizOptionDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizOptionMedia"]>

  export type QuizOptionMediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    optionId?: boolean
    mediaId?: boolean
    createdAt?: boolean
    option?: boolean | QuizOptionDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizOptionMedia"]>

  export type QuizOptionMediaSelectScalar = {
    id?: boolean
    optionId?: boolean
    mediaId?: boolean
    createdAt?: boolean
  }

  export type QuizOptionMediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "optionId" | "mediaId" | "createdAt", ExtArgs["result"]["quizOptionMedia"]>
  export type QuizOptionMediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    option?: boolean | QuizOptionDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }
  export type QuizOptionMediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    option?: boolean | QuizOptionDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }
  export type QuizOptionMediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    option?: boolean | QuizOptionDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }

  export type $QuizOptionMediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizOptionMedia"
    objects: {
      option: Prisma.$QuizOptionPayload<ExtArgs>
      media: Prisma.$MediaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      optionId: number
      mediaId: number
      createdAt: Date
    }, ExtArgs["result"]["quizOptionMedia"]>
    composites: {}
  }

  type QuizOptionMediaGetPayload<S extends boolean | null | undefined | QuizOptionMediaDefaultArgs> = $Result.GetResult<Prisma.$QuizOptionMediaPayload, S>

  type QuizOptionMediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizOptionMediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizOptionMediaCountAggregateInputType | true
    }

  export interface QuizOptionMediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizOptionMedia'], meta: { name: 'QuizOptionMedia' } }
    /**
     * Find zero or one QuizOptionMedia that matches the filter.
     * @param {QuizOptionMediaFindUniqueArgs} args - Arguments to find a QuizOptionMedia
     * @example
     * // Get one QuizOptionMedia
     * const quizOptionMedia = await prisma.quizOptionMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizOptionMediaFindUniqueArgs>(args: SelectSubset<T, QuizOptionMediaFindUniqueArgs<ExtArgs>>): Prisma__QuizOptionMediaClient<$Result.GetResult<Prisma.$QuizOptionMediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizOptionMedia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizOptionMediaFindUniqueOrThrowArgs} args - Arguments to find a QuizOptionMedia
     * @example
     * // Get one QuizOptionMedia
     * const quizOptionMedia = await prisma.quizOptionMedia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizOptionMediaFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizOptionMediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizOptionMediaClient<$Result.GetResult<Prisma.$QuizOptionMediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizOptionMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizOptionMediaFindFirstArgs} args - Arguments to find a QuizOptionMedia
     * @example
     * // Get one QuizOptionMedia
     * const quizOptionMedia = await prisma.quizOptionMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizOptionMediaFindFirstArgs>(args?: SelectSubset<T, QuizOptionMediaFindFirstArgs<ExtArgs>>): Prisma__QuizOptionMediaClient<$Result.GetResult<Prisma.$QuizOptionMediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizOptionMedia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizOptionMediaFindFirstOrThrowArgs} args - Arguments to find a QuizOptionMedia
     * @example
     * // Get one QuizOptionMedia
     * const quizOptionMedia = await prisma.quizOptionMedia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizOptionMediaFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizOptionMediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizOptionMediaClient<$Result.GetResult<Prisma.$QuizOptionMediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizOptionMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizOptionMediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizOptionMedias
     * const quizOptionMedias = await prisma.quizOptionMedia.findMany()
     * 
     * // Get first 10 QuizOptionMedias
     * const quizOptionMedias = await prisma.quizOptionMedia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizOptionMediaWithIdOnly = await prisma.quizOptionMedia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizOptionMediaFindManyArgs>(args?: SelectSubset<T, QuizOptionMediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizOptionMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizOptionMedia.
     * @param {QuizOptionMediaCreateArgs} args - Arguments to create a QuizOptionMedia.
     * @example
     * // Create one QuizOptionMedia
     * const QuizOptionMedia = await prisma.quizOptionMedia.create({
     *   data: {
     *     // ... data to create a QuizOptionMedia
     *   }
     * })
     * 
     */
    create<T extends QuizOptionMediaCreateArgs>(args: SelectSubset<T, QuizOptionMediaCreateArgs<ExtArgs>>): Prisma__QuizOptionMediaClient<$Result.GetResult<Prisma.$QuizOptionMediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizOptionMedias.
     * @param {QuizOptionMediaCreateManyArgs} args - Arguments to create many QuizOptionMedias.
     * @example
     * // Create many QuizOptionMedias
     * const quizOptionMedia = await prisma.quizOptionMedia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizOptionMediaCreateManyArgs>(args?: SelectSubset<T, QuizOptionMediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizOptionMedias and returns the data saved in the database.
     * @param {QuizOptionMediaCreateManyAndReturnArgs} args - Arguments to create many QuizOptionMedias.
     * @example
     * // Create many QuizOptionMedias
     * const quizOptionMedia = await prisma.quizOptionMedia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizOptionMedias and only return the `id`
     * const quizOptionMediaWithIdOnly = await prisma.quizOptionMedia.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizOptionMediaCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizOptionMediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizOptionMediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizOptionMedia.
     * @param {QuizOptionMediaDeleteArgs} args - Arguments to delete one QuizOptionMedia.
     * @example
     * // Delete one QuizOptionMedia
     * const QuizOptionMedia = await prisma.quizOptionMedia.delete({
     *   where: {
     *     // ... filter to delete one QuizOptionMedia
     *   }
     * })
     * 
     */
    delete<T extends QuizOptionMediaDeleteArgs>(args: SelectSubset<T, QuizOptionMediaDeleteArgs<ExtArgs>>): Prisma__QuizOptionMediaClient<$Result.GetResult<Prisma.$QuizOptionMediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizOptionMedia.
     * @param {QuizOptionMediaUpdateArgs} args - Arguments to update one QuizOptionMedia.
     * @example
     * // Update one QuizOptionMedia
     * const quizOptionMedia = await prisma.quizOptionMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizOptionMediaUpdateArgs>(args: SelectSubset<T, QuizOptionMediaUpdateArgs<ExtArgs>>): Prisma__QuizOptionMediaClient<$Result.GetResult<Prisma.$QuizOptionMediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizOptionMedias.
     * @param {QuizOptionMediaDeleteManyArgs} args - Arguments to filter QuizOptionMedias to delete.
     * @example
     * // Delete a few QuizOptionMedias
     * const { count } = await prisma.quizOptionMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizOptionMediaDeleteManyArgs>(args?: SelectSubset<T, QuizOptionMediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizOptionMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizOptionMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizOptionMedias
     * const quizOptionMedia = await prisma.quizOptionMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizOptionMediaUpdateManyArgs>(args: SelectSubset<T, QuizOptionMediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizOptionMedias and returns the data updated in the database.
     * @param {QuizOptionMediaUpdateManyAndReturnArgs} args - Arguments to update many QuizOptionMedias.
     * @example
     * // Update many QuizOptionMedias
     * const quizOptionMedia = await prisma.quizOptionMedia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizOptionMedias and only return the `id`
     * const quizOptionMediaWithIdOnly = await prisma.quizOptionMedia.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizOptionMediaUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizOptionMediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizOptionMediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizOptionMedia.
     * @param {QuizOptionMediaUpsertArgs} args - Arguments to update or create a QuizOptionMedia.
     * @example
     * // Update or create a QuizOptionMedia
     * const quizOptionMedia = await prisma.quizOptionMedia.upsert({
     *   create: {
     *     // ... data to create a QuizOptionMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizOptionMedia we want to update
     *   }
     * })
     */
    upsert<T extends QuizOptionMediaUpsertArgs>(args: SelectSubset<T, QuizOptionMediaUpsertArgs<ExtArgs>>): Prisma__QuizOptionMediaClient<$Result.GetResult<Prisma.$QuizOptionMediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizOptionMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizOptionMediaCountArgs} args - Arguments to filter QuizOptionMedias to count.
     * @example
     * // Count the number of QuizOptionMedias
     * const count = await prisma.quizOptionMedia.count({
     *   where: {
     *     // ... the filter for the QuizOptionMedias we want to count
     *   }
     * })
    **/
    count<T extends QuizOptionMediaCountArgs>(
      args?: Subset<T, QuizOptionMediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizOptionMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizOptionMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizOptionMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizOptionMediaAggregateArgs>(args: Subset<T, QuizOptionMediaAggregateArgs>): Prisma.PrismaPromise<GetQuizOptionMediaAggregateType<T>>

    /**
     * Group by QuizOptionMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizOptionMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizOptionMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizOptionMediaGroupByArgs['orderBy'] }
        : { orderBy?: QuizOptionMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizOptionMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizOptionMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizOptionMedia model
   */
  readonly fields: QuizOptionMediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizOptionMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizOptionMediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    option<T extends QuizOptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizOptionDefaultArgs<ExtArgs>>): Prisma__QuizOptionClient<$Result.GetResult<Prisma.$QuizOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    media<T extends MediaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MediaDefaultArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizOptionMedia model
   */
  interface QuizOptionMediaFieldRefs {
    readonly id: FieldRef<"QuizOptionMedia", 'Int'>
    readonly optionId: FieldRef<"QuizOptionMedia", 'Int'>
    readonly mediaId: FieldRef<"QuizOptionMedia", 'Int'>
    readonly createdAt: FieldRef<"QuizOptionMedia", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizOptionMedia findUnique
   */
  export type QuizOptionMediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOptionMedia
     */
    select?: QuizOptionMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOptionMedia
     */
    omit?: QuizOptionMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionMediaInclude<ExtArgs> | null
    /**
     * Filter, which QuizOptionMedia to fetch.
     */
    where: QuizOptionMediaWhereUniqueInput
  }

  /**
   * QuizOptionMedia findUniqueOrThrow
   */
  export type QuizOptionMediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOptionMedia
     */
    select?: QuizOptionMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOptionMedia
     */
    omit?: QuizOptionMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionMediaInclude<ExtArgs> | null
    /**
     * Filter, which QuizOptionMedia to fetch.
     */
    where: QuizOptionMediaWhereUniqueInput
  }

  /**
   * QuizOptionMedia findFirst
   */
  export type QuizOptionMediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOptionMedia
     */
    select?: QuizOptionMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOptionMedia
     */
    omit?: QuizOptionMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionMediaInclude<ExtArgs> | null
    /**
     * Filter, which QuizOptionMedia to fetch.
     */
    where?: QuizOptionMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizOptionMedias to fetch.
     */
    orderBy?: QuizOptionMediaOrderByWithRelationInput | QuizOptionMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizOptionMedias.
     */
    cursor?: QuizOptionMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizOptionMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizOptionMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizOptionMedias.
     */
    distinct?: QuizOptionMediaScalarFieldEnum | QuizOptionMediaScalarFieldEnum[]
  }

  /**
   * QuizOptionMedia findFirstOrThrow
   */
  export type QuizOptionMediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOptionMedia
     */
    select?: QuizOptionMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOptionMedia
     */
    omit?: QuizOptionMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionMediaInclude<ExtArgs> | null
    /**
     * Filter, which QuizOptionMedia to fetch.
     */
    where?: QuizOptionMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizOptionMedias to fetch.
     */
    orderBy?: QuizOptionMediaOrderByWithRelationInput | QuizOptionMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizOptionMedias.
     */
    cursor?: QuizOptionMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizOptionMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizOptionMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizOptionMedias.
     */
    distinct?: QuizOptionMediaScalarFieldEnum | QuizOptionMediaScalarFieldEnum[]
  }

  /**
   * QuizOptionMedia findMany
   */
  export type QuizOptionMediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOptionMedia
     */
    select?: QuizOptionMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOptionMedia
     */
    omit?: QuizOptionMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionMediaInclude<ExtArgs> | null
    /**
     * Filter, which QuizOptionMedias to fetch.
     */
    where?: QuizOptionMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizOptionMedias to fetch.
     */
    orderBy?: QuizOptionMediaOrderByWithRelationInput | QuizOptionMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizOptionMedias.
     */
    cursor?: QuizOptionMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizOptionMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizOptionMedias.
     */
    skip?: number
    distinct?: QuizOptionMediaScalarFieldEnum | QuizOptionMediaScalarFieldEnum[]
  }

  /**
   * QuizOptionMedia create
   */
  export type QuizOptionMediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOptionMedia
     */
    select?: QuizOptionMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOptionMedia
     */
    omit?: QuizOptionMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionMediaInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizOptionMedia.
     */
    data: XOR<QuizOptionMediaCreateInput, QuizOptionMediaUncheckedCreateInput>
  }

  /**
   * QuizOptionMedia createMany
   */
  export type QuizOptionMediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizOptionMedias.
     */
    data: QuizOptionMediaCreateManyInput | QuizOptionMediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizOptionMedia createManyAndReturn
   */
  export type QuizOptionMediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOptionMedia
     */
    select?: QuizOptionMediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOptionMedia
     */
    omit?: QuizOptionMediaOmit<ExtArgs> | null
    /**
     * The data used to create many QuizOptionMedias.
     */
    data: QuizOptionMediaCreateManyInput | QuizOptionMediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionMediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizOptionMedia update
   */
  export type QuizOptionMediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOptionMedia
     */
    select?: QuizOptionMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOptionMedia
     */
    omit?: QuizOptionMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionMediaInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizOptionMedia.
     */
    data: XOR<QuizOptionMediaUpdateInput, QuizOptionMediaUncheckedUpdateInput>
    /**
     * Choose, which QuizOptionMedia to update.
     */
    where: QuizOptionMediaWhereUniqueInput
  }

  /**
   * QuizOptionMedia updateMany
   */
  export type QuizOptionMediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizOptionMedias.
     */
    data: XOR<QuizOptionMediaUpdateManyMutationInput, QuizOptionMediaUncheckedUpdateManyInput>
    /**
     * Filter which QuizOptionMedias to update
     */
    where?: QuizOptionMediaWhereInput
    /**
     * Limit how many QuizOptionMedias to update.
     */
    limit?: number
  }

  /**
   * QuizOptionMedia updateManyAndReturn
   */
  export type QuizOptionMediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOptionMedia
     */
    select?: QuizOptionMediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOptionMedia
     */
    omit?: QuizOptionMediaOmit<ExtArgs> | null
    /**
     * The data used to update QuizOptionMedias.
     */
    data: XOR<QuizOptionMediaUpdateManyMutationInput, QuizOptionMediaUncheckedUpdateManyInput>
    /**
     * Filter which QuizOptionMedias to update
     */
    where?: QuizOptionMediaWhereInput
    /**
     * Limit how many QuizOptionMedias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionMediaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizOptionMedia upsert
   */
  export type QuizOptionMediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOptionMedia
     */
    select?: QuizOptionMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOptionMedia
     */
    omit?: QuizOptionMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionMediaInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizOptionMedia to update in case it exists.
     */
    where: QuizOptionMediaWhereUniqueInput
    /**
     * In case the QuizOptionMedia found by the `where` argument doesn't exist, create a new QuizOptionMedia with this data.
     */
    create: XOR<QuizOptionMediaCreateInput, QuizOptionMediaUncheckedCreateInput>
    /**
     * In case the QuizOptionMedia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizOptionMediaUpdateInput, QuizOptionMediaUncheckedUpdateInput>
  }

  /**
   * QuizOptionMedia delete
   */
  export type QuizOptionMediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOptionMedia
     */
    select?: QuizOptionMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOptionMedia
     */
    omit?: QuizOptionMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionMediaInclude<ExtArgs> | null
    /**
     * Filter which QuizOptionMedia to delete.
     */
    where: QuizOptionMediaWhereUniqueInput
  }

  /**
   * QuizOptionMedia deleteMany
   */
  export type QuizOptionMediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizOptionMedias to delete
     */
    where?: QuizOptionMediaWhereInput
    /**
     * Limit how many QuizOptionMedias to delete.
     */
    limit?: number
  }

  /**
   * QuizOptionMedia without action
   */
  export type QuizOptionMediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizOptionMedia
     */
    select?: QuizOptionMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizOptionMedia
     */
    omit?: QuizOptionMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizOptionMediaInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const OtpRecordScalarFieldEnum: {
    id: 'id',
    email: 'email',
    OtpCode: 'OtpCode',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type OtpRecordScalarFieldEnum = (typeof OtpRecordScalarFieldEnum)[keyof typeof OtpRecordScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tokenHash: 'tokenHash',
    issuedAt: 'issuedAt',
    expiresAt: 'expiresAt',
    revokedAt: 'revokedAt',
    replacedByHash: 'replacedByHash'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const MediaScalarFieldEnum: {
    id: 'id',
    disk: 'disk',
    bucket: 'bucket',
    objectKey: 'objectKey',
    mimeType: 'mimeType',
    sizeBytes: 'sizeBytes',
    visibility: 'visibility',
    uploadedBy: 'uploadedBy',
    createdAt: 'createdAt'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    email: 'email',
    passwordHash: 'passwordHash',
    phone: 'phone',
    role: 'role',
    avatarMediaId: 'avatarMediaId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ClassroomScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    tutorId: 'tutorId',
    coverMediaId: 'coverMediaId',
    isArchived: 'isArchived',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClassroomScalarFieldEnum = (typeof ClassroomScalarFieldEnum)[keyof typeof ClassroomScalarFieldEnum]


  export const ClassroomStudentScalarFieldEnum: {
    classroomId: 'classroomId',
    studentId: 'studentId',
    joinedAt: 'joinedAt',
    status: 'status'
  };

  export type ClassroomStudentScalarFieldEnum = (typeof ClassroomStudentScalarFieldEnum)[keyof typeof ClassroomStudentScalarFieldEnum]


  export const JoinRequestScalarFieldEnum: {
    id: 'id',
    classroomId: 'classroomId',
    studentId: 'studentId',
    status: 'status',
    requestedAt: 'requestedAt',
    handledAt: 'handledAt'
  };

  export type JoinRequestScalarFieldEnum = (typeof JoinRequestScalarFieldEnum)[keyof typeof JoinRequestScalarFieldEnum]


  export const LessonScalarFieldEnum: {
    id: 'id',
    classroomId: 'classroomId',
    parentId: 'parentId',
    title: 'title',
    content: 'content',
    lessonType: 'lessonType',
    orderIndex: 'orderIndex',
    publishedAt: 'publishedAt'
  };

  export type LessonScalarFieldEnum = (typeof LessonScalarFieldEnum)[keyof typeof LessonScalarFieldEnum]


  export const MaterialScalarFieldEnum: {
    id: 'id',
    lessonId: 'lessonId',
    title: 'title',
    mediaId: 'mediaId',
    uploadedBy: 'uploadedBy',
    uploadedAt: 'uploadedAt'
  };

  export type MaterialScalarFieldEnum = (typeof MaterialScalarFieldEnum)[keyof typeof MaterialScalarFieldEnum]


  export const ExerciseScalarFieldEnum: {
    id: 'id',
    lessonId: 'lessonId',
    title: 'title',
    description: 'description',
    attachMediaId: 'attachMediaId',
    dueAt: 'dueAt',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ExerciseScalarFieldEnum = (typeof ExerciseScalarFieldEnum)[keyof typeof ExerciseScalarFieldEnum]


  export const ExerciseSubmissionScalarFieldEnum: {
    id: 'id',
    exerciseId: 'exerciseId',
    studentId: 'studentId',
    mediaId: 'mediaId',
    submittedAt: 'submittedAt',
    score: 'score',
    comment: 'comment',
    gradedAt: 'gradedAt'
  };

  export type ExerciseSubmissionScalarFieldEnum = (typeof ExerciseSubmissionScalarFieldEnum)[keyof typeof ExerciseSubmissionScalarFieldEnum]


  export const QuizScalarFieldEnum: {
    id: 'id',
    lessonId: 'lessonId',
    title: 'title',
    description: 'description',
    timeLimitSec: 'timeLimitSec',
    maxAttempts: 'maxAttempts',
    shuffleQuestions: 'shuffleQuestions',
    shuffleOptions: 'shuffleOptions',
    gradingMethod: 'gradingMethod',
    showAnswersAfter: 'showAnswersAfter',
    dueAt: 'dueAt',
    isPublished: 'isPublished',
    totalPoints: 'totalPoints',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type QuizScalarFieldEnum = (typeof QuizScalarFieldEnum)[keyof typeof QuizScalarFieldEnum]


  export const QuizSectionScalarFieldEnum: {
    id: 'id',
    quizId: 'quizId',
    title: 'title',
    description: 'description',
    orderIndex: 'orderIndex'
  };

  export type QuizSectionScalarFieldEnum = (typeof QuizSectionScalarFieldEnum)[keyof typeof QuizSectionScalarFieldEnum]


  export const QuizQuestionGroupScalarFieldEnum: {
    id: 'id',
    quizId: 'quizId',
    sectionId: 'sectionId',
    title: 'title',
    introText: 'introText',
    orderIndex: 'orderIndex',
    shuffleInside: 'shuffleInside',
    pointsPolicy: 'pointsPolicy',
    createdAt: 'createdAt'
  };

  export type QuizQuestionGroupScalarFieldEnum = (typeof QuizQuestionGroupScalarFieldEnum)[keyof typeof QuizQuestionGroupScalarFieldEnum]


  export const QuizQuestionScalarFieldEnum: {
    id: 'id',
    quizId: 'quizId',
    sectionId: 'sectionId',
    groupId: 'groupId',
    content: 'content',
    explanation: 'explanation',
    questionType: 'questionType',
    points: 'points',
    orderIndex: 'orderIndex'
  };

  export type QuizQuestionScalarFieldEnum = (typeof QuizQuestionScalarFieldEnum)[keyof typeof QuizQuestionScalarFieldEnum]


  export const QuizOptionScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    content: 'content',
    isCorrect: 'isCorrect',
    orderIndex: 'orderIndex'
  };

  export type QuizOptionScalarFieldEnum = (typeof QuizOptionScalarFieldEnum)[keyof typeof QuizOptionScalarFieldEnum]


  export const QuizAttemptScalarFieldEnum: {
    id: 'id',
    quizId: 'quizId',
    studentId: 'studentId',
    startedAt: 'startedAt',
    submittedAt: 'submittedAt',
    status: 'status',
    scoreRaw: 'scoreRaw',
    scoreScaled10: 'scoreScaled10'
  };

  export type QuizAttemptScalarFieldEnum = (typeof QuizAttemptScalarFieldEnum)[keyof typeof QuizAttemptScalarFieldEnum]


  export const QuizAnswerScalarFieldEnum: {
    attemptId: 'attemptId',
    questionId: 'questionId',
    optionId: 'optionId'
  };

  export type QuizAnswerScalarFieldEnum = (typeof QuizAnswerScalarFieldEnum)[keyof typeof QuizAnswerScalarFieldEnum]


  export const QuizQuestionGroupMediaScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    mediaId: 'mediaId',
    createdAt: 'createdAt'
  };

  export type QuizQuestionGroupMediaScalarFieldEnum = (typeof QuizQuestionGroupMediaScalarFieldEnum)[keyof typeof QuizQuestionGroupMediaScalarFieldEnum]


  export const QuizQuestionMediaScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    mediaId: 'mediaId',
    createdAt: 'createdAt'
  };

  export type QuizQuestionMediaScalarFieldEnum = (typeof QuizQuestionMediaScalarFieldEnum)[keyof typeof QuizQuestionMediaScalarFieldEnum]


  export const QuizOptionMediaScalarFieldEnum: {
    id: 'id',
    optionId: 'optionId',
    mediaId: 'mediaId',
    createdAt: 'createdAt'
  };

  export type QuizOptionMediaScalarFieldEnum = (typeof QuizOptionMediaScalarFieldEnum)[keyof typeof QuizOptionMediaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'LessonType'
   */
  export type EnumLessonTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LessonType'>
    


  /**
   * Reference to a field of type 'LessonType[]'
   */
  export type ListEnumLessonTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LessonType[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type OtpRecordWhereInput = {
    AND?: OtpRecordWhereInput | OtpRecordWhereInput[]
    OR?: OtpRecordWhereInput[]
    NOT?: OtpRecordWhereInput | OtpRecordWhereInput[]
    id?: BigIntFilter<"OtpRecord"> | bigint | number
    email?: StringFilter<"OtpRecord"> | string
    OtpCode?: StringFilter<"OtpRecord"> | string
    createdAt?: DateTimeFilter<"OtpRecord"> | Date | string
    expiresAt?: DateTimeFilter<"OtpRecord"> | Date | string
  }

  export type OtpRecordOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    OtpCode?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type OtpRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: OtpRecordWhereInput | OtpRecordWhereInput[]
    OR?: OtpRecordWhereInput[]
    NOT?: OtpRecordWhereInput | OtpRecordWhereInput[]
    email?: StringFilter<"OtpRecord"> | string
    OtpCode?: StringFilter<"OtpRecord"> | string
    createdAt?: DateTimeFilter<"OtpRecord"> | Date | string
    expiresAt?: DateTimeFilter<"OtpRecord"> | Date | string
  }, "id">

  export type OtpRecordOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    OtpCode?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    _count?: OtpRecordCountOrderByAggregateInput
    _avg?: OtpRecordAvgOrderByAggregateInput
    _max?: OtpRecordMaxOrderByAggregateInput
    _min?: OtpRecordMinOrderByAggregateInput
    _sum?: OtpRecordSumOrderByAggregateInput
  }

  export type OtpRecordScalarWhereWithAggregatesInput = {
    AND?: OtpRecordScalarWhereWithAggregatesInput | OtpRecordScalarWhereWithAggregatesInput[]
    OR?: OtpRecordScalarWhereWithAggregatesInput[]
    NOT?: OtpRecordScalarWhereWithAggregatesInput | OtpRecordScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"OtpRecord"> | bigint | number
    email?: StringWithAggregatesFilter<"OtpRecord"> | string
    OtpCode?: StringWithAggregatesFilter<"OtpRecord"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OtpRecord"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"OtpRecord"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: BigIntFilter<"RefreshToken"> | bigint | number
    userId?: IntFilter<"RefreshToken"> | number
    tokenHash?: StringFilter<"RefreshToken"> | string
    issuedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    replacedByHash?: StringNullableFilter<"RefreshToken"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    replacedByHash?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    tokenHash?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: IntFilter<"RefreshToken"> | number
    issuedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    replacedByHash?: StringNullableFilter<"RefreshToken"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "tokenHash">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    replacedByHash?: SortOrderInput | SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _avg?: RefreshTokenAvgOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
    _sum?: RefreshTokenSumOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"RefreshToken"> | bigint | number
    userId?: IntWithAggregatesFilter<"RefreshToken"> | number
    tokenHash?: StringWithAggregatesFilter<"RefreshToken"> | string
    issuedAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableWithAggregatesFilter<"RefreshToken"> | Date | string | null
    replacedByHash?: StringNullableWithAggregatesFilter<"RefreshToken"> | string | null
  }

  export type MediaWhereInput = {
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    id?: IntFilter<"Media"> | number
    disk?: StringFilter<"Media"> | string
    bucket?: StringNullableFilter<"Media"> | string | null
    objectKey?: StringFilter<"Media"> | string
    mimeType?: StringNullableFilter<"Media"> | string | null
    sizeBytes?: BigIntNullableFilter<"Media"> | bigint | number | null
    visibility?: StringFilter<"Media"> | string
    uploadedBy?: IntNullableFilter<"Media"> | number | null
    createdAt?: DateTimeFilter<"Media"> | Date | string
    uploader?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    userAvatars?: UserListRelationFilter
    classroomCovers?: ClassroomListRelationFilter
    materials?: MaterialListRelationFilter
    exerciseAttachments?: ExerciseListRelationFilter
    exerciseSubmissions?: ExerciseSubmissionListRelationFilter
    quizQuestionGroupMedias?: QuizQuestionGroupMediaListRelationFilter
    quizQuestionMedias?: QuizQuestionMediaListRelationFilter
    quizOptionMedias?: QuizOptionMediaListRelationFilter
  }

  export type MediaOrderByWithRelationInput = {
    id?: SortOrder
    disk?: SortOrder
    bucket?: SortOrderInput | SortOrder
    objectKey?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    sizeBytes?: SortOrderInput | SortOrder
    visibility?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    uploader?: UserOrderByWithRelationInput
    userAvatars?: UserOrderByRelationAggregateInput
    classroomCovers?: ClassroomOrderByRelationAggregateInput
    materials?: MaterialOrderByRelationAggregateInput
    exerciseAttachments?: ExerciseOrderByRelationAggregateInput
    exerciseSubmissions?: ExerciseSubmissionOrderByRelationAggregateInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaOrderByRelationAggregateInput
    quizQuestionMedias?: QuizQuestionMediaOrderByRelationAggregateInput
    quizOptionMedias?: QuizOptionMediaOrderByRelationAggregateInput
  }

  export type MediaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    bucket_objectKey?: MediaBucketObjectKeyCompoundUniqueInput
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    disk?: StringFilter<"Media"> | string
    bucket?: StringNullableFilter<"Media"> | string | null
    objectKey?: StringFilter<"Media"> | string
    mimeType?: StringNullableFilter<"Media"> | string | null
    sizeBytes?: BigIntNullableFilter<"Media"> | bigint | number | null
    visibility?: StringFilter<"Media"> | string
    uploadedBy?: IntNullableFilter<"Media"> | number | null
    createdAt?: DateTimeFilter<"Media"> | Date | string
    uploader?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    userAvatars?: UserListRelationFilter
    classroomCovers?: ClassroomListRelationFilter
    materials?: MaterialListRelationFilter
    exerciseAttachments?: ExerciseListRelationFilter
    exerciseSubmissions?: ExerciseSubmissionListRelationFilter
    quizQuestionGroupMedias?: QuizQuestionGroupMediaListRelationFilter
    quizQuestionMedias?: QuizQuestionMediaListRelationFilter
    quizOptionMedias?: QuizOptionMediaListRelationFilter
  }, "id" | "bucket_objectKey">

  export type MediaOrderByWithAggregationInput = {
    id?: SortOrder
    disk?: SortOrder
    bucket?: SortOrderInput | SortOrder
    objectKey?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    sizeBytes?: SortOrderInput | SortOrder
    visibility?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MediaCountOrderByAggregateInput
    _avg?: MediaAvgOrderByAggregateInput
    _max?: MediaMaxOrderByAggregateInput
    _min?: MediaMinOrderByAggregateInput
    _sum?: MediaSumOrderByAggregateInput
  }

  export type MediaScalarWhereWithAggregatesInput = {
    AND?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    OR?: MediaScalarWhereWithAggregatesInput[]
    NOT?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Media"> | number
    disk?: StringWithAggregatesFilter<"Media"> | string
    bucket?: StringNullableWithAggregatesFilter<"Media"> | string | null
    objectKey?: StringWithAggregatesFilter<"Media"> | string
    mimeType?: StringNullableWithAggregatesFilter<"Media"> | string | null
    sizeBytes?: BigIntNullableWithAggregatesFilter<"Media"> | bigint | number | null
    visibility?: StringWithAggregatesFilter<"Media"> | string
    uploadedBy?: IntNullableWithAggregatesFilter<"Media"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    fullName?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    avatarMediaId?: IntNullableFilter<"User"> | number | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    avatarMedia?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    uploadedMedia?: MediaListRelationFilter
    taughtClassrooms?: ClassroomListRelationFilter
    createdClassrooms?: ClassroomListRelationFilter
    classroomStudents?: ClassroomStudentListRelationFilter
    joinRequests?: JoinRequestListRelationFilter
    uploadedMaterials?: MaterialListRelationFilter
    createdExercises?: ExerciseListRelationFilter
    exerciseSubmissions?: ExerciseSubmissionListRelationFilter
    createdQuizzes?: QuizListRelationFilter
    quizAttempts?: QuizAttemptListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    avatarMediaId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    avatarMedia?: MediaOrderByWithRelationInput
    uploadedMedia?: MediaOrderByRelationAggregateInput
    taughtClassrooms?: ClassroomOrderByRelationAggregateInput
    createdClassrooms?: ClassroomOrderByRelationAggregateInput
    classroomStudents?: ClassroomStudentOrderByRelationAggregateInput
    joinRequests?: JoinRequestOrderByRelationAggregateInput
    uploadedMaterials?: MaterialOrderByRelationAggregateInput
    createdExercises?: ExerciseOrderByRelationAggregateInput
    exerciseSubmissions?: ExerciseSubmissionOrderByRelationAggregateInput
    createdQuizzes?: QuizOrderByRelationAggregateInput
    quizAttempts?: QuizAttemptOrderByRelationAggregateInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    fullName?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    avatarMediaId?: IntNullableFilter<"User"> | number | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    avatarMedia?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    uploadedMedia?: MediaListRelationFilter
    taughtClassrooms?: ClassroomListRelationFilter
    createdClassrooms?: ClassroomListRelationFilter
    classroomStudents?: ClassroomStudentListRelationFilter
    joinRequests?: JoinRequestListRelationFilter
    uploadedMaterials?: MaterialListRelationFilter
    createdExercises?: ExerciseListRelationFilter
    exerciseSubmissions?: ExerciseSubmissionListRelationFilter
    createdQuizzes?: QuizListRelationFilter
    quizAttempts?: QuizAttemptListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    avatarMediaId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    fullName?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    phone?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    avatarMediaId?: IntNullableWithAggregatesFilter<"User"> | number | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ClassroomWhereInput = {
    AND?: ClassroomWhereInput | ClassroomWhereInput[]
    OR?: ClassroomWhereInput[]
    NOT?: ClassroomWhereInput | ClassroomWhereInput[]
    id?: IntFilter<"Classroom"> | number
    name?: StringFilter<"Classroom"> | string
    description?: StringNullableFilter<"Classroom"> | string | null
    tutorId?: IntFilter<"Classroom"> | number
    coverMediaId?: IntNullableFilter<"Classroom"> | number | null
    isArchived?: BoolFilter<"Classroom"> | boolean
    createdBy?: IntFilter<"Classroom"> | number
    createdAt?: DateTimeFilter<"Classroom"> | Date | string
    updatedAt?: DateTimeFilter<"Classroom"> | Date | string
    tutor?: XOR<UserScalarRelationFilter, UserWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    coverMedia?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    classroomStudents?: ClassroomStudentListRelationFilter
    joinRequests?: JoinRequestListRelationFilter
    lessons?: LessonListRelationFilter
  }

  export type ClassroomOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    tutorId?: SortOrder
    coverMediaId?: SortOrderInput | SortOrder
    isArchived?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tutor?: UserOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    coverMedia?: MediaOrderByWithRelationInput
    classroomStudents?: ClassroomStudentOrderByRelationAggregateInput
    joinRequests?: JoinRequestOrderByRelationAggregateInput
    lessons?: LessonOrderByRelationAggregateInput
  }

  export type ClassroomWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClassroomWhereInput | ClassroomWhereInput[]
    OR?: ClassroomWhereInput[]
    NOT?: ClassroomWhereInput | ClassroomWhereInput[]
    name?: StringFilter<"Classroom"> | string
    description?: StringNullableFilter<"Classroom"> | string | null
    tutorId?: IntFilter<"Classroom"> | number
    coverMediaId?: IntNullableFilter<"Classroom"> | number | null
    isArchived?: BoolFilter<"Classroom"> | boolean
    createdBy?: IntFilter<"Classroom"> | number
    createdAt?: DateTimeFilter<"Classroom"> | Date | string
    updatedAt?: DateTimeFilter<"Classroom"> | Date | string
    tutor?: XOR<UserScalarRelationFilter, UserWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    coverMedia?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    classroomStudents?: ClassroomStudentListRelationFilter
    joinRequests?: JoinRequestListRelationFilter
    lessons?: LessonListRelationFilter
  }, "id">

  export type ClassroomOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    tutorId?: SortOrder
    coverMediaId?: SortOrderInput | SortOrder
    isArchived?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClassroomCountOrderByAggregateInput
    _avg?: ClassroomAvgOrderByAggregateInput
    _max?: ClassroomMaxOrderByAggregateInput
    _min?: ClassroomMinOrderByAggregateInput
    _sum?: ClassroomSumOrderByAggregateInput
  }

  export type ClassroomScalarWhereWithAggregatesInput = {
    AND?: ClassroomScalarWhereWithAggregatesInput | ClassroomScalarWhereWithAggregatesInput[]
    OR?: ClassroomScalarWhereWithAggregatesInput[]
    NOT?: ClassroomScalarWhereWithAggregatesInput | ClassroomScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Classroom"> | number
    name?: StringWithAggregatesFilter<"Classroom"> | string
    description?: StringNullableWithAggregatesFilter<"Classroom"> | string | null
    tutorId?: IntWithAggregatesFilter<"Classroom"> | number
    coverMediaId?: IntNullableWithAggregatesFilter<"Classroom"> | number | null
    isArchived?: BoolWithAggregatesFilter<"Classroom"> | boolean
    createdBy?: IntWithAggregatesFilter<"Classroom"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Classroom"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Classroom"> | Date | string
  }

  export type ClassroomStudentWhereInput = {
    AND?: ClassroomStudentWhereInput | ClassroomStudentWhereInput[]
    OR?: ClassroomStudentWhereInput[]
    NOT?: ClassroomStudentWhereInput | ClassroomStudentWhereInput[]
    classroomId?: IntFilter<"ClassroomStudent"> | number
    studentId?: IntFilter<"ClassroomStudent"> | number
    joinedAt?: DateTimeFilter<"ClassroomStudent"> | Date | string
    status?: IntFilter<"ClassroomStudent"> | number
    classroom?: XOR<ClassroomScalarRelationFilter, ClassroomWhereInput>
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ClassroomStudentOrderByWithRelationInput = {
    classroomId?: SortOrder
    studentId?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
    classroom?: ClassroomOrderByWithRelationInput
    student?: UserOrderByWithRelationInput
  }

  export type ClassroomStudentWhereUniqueInput = Prisma.AtLeast<{
    classroomId_studentId?: ClassroomStudentClassroomIdStudentIdCompoundUniqueInput
    AND?: ClassroomStudentWhereInput | ClassroomStudentWhereInput[]
    OR?: ClassroomStudentWhereInput[]
    NOT?: ClassroomStudentWhereInput | ClassroomStudentWhereInput[]
    classroomId?: IntFilter<"ClassroomStudent"> | number
    studentId?: IntFilter<"ClassroomStudent"> | number
    joinedAt?: DateTimeFilter<"ClassroomStudent"> | Date | string
    status?: IntFilter<"ClassroomStudent"> | number
    classroom?: XOR<ClassroomScalarRelationFilter, ClassroomWhereInput>
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "classroomId_studentId">

  export type ClassroomStudentOrderByWithAggregationInput = {
    classroomId?: SortOrder
    studentId?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
    _count?: ClassroomStudentCountOrderByAggregateInput
    _avg?: ClassroomStudentAvgOrderByAggregateInput
    _max?: ClassroomStudentMaxOrderByAggregateInput
    _min?: ClassroomStudentMinOrderByAggregateInput
    _sum?: ClassroomStudentSumOrderByAggregateInput
  }

  export type ClassroomStudentScalarWhereWithAggregatesInput = {
    AND?: ClassroomStudentScalarWhereWithAggregatesInput | ClassroomStudentScalarWhereWithAggregatesInput[]
    OR?: ClassroomStudentScalarWhereWithAggregatesInput[]
    NOT?: ClassroomStudentScalarWhereWithAggregatesInput | ClassroomStudentScalarWhereWithAggregatesInput[]
    classroomId?: IntWithAggregatesFilter<"ClassroomStudent"> | number
    studentId?: IntWithAggregatesFilter<"ClassroomStudent"> | number
    joinedAt?: DateTimeWithAggregatesFilter<"ClassroomStudent"> | Date | string
    status?: IntWithAggregatesFilter<"ClassroomStudent"> | number
  }

  export type JoinRequestWhereInput = {
    AND?: JoinRequestWhereInput | JoinRequestWhereInput[]
    OR?: JoinRequestWhereInput[]
    NOT?: JoinRequestWhereInput | JoinRequestWhereInput[]
    id?: IntFilter<"JoinRequest"> | number
    classroomId?: IntFilter<"JoinRequest"> | number
    studentId?: IntFilter<"JoinRequest"> | number
    status?: StringFilter<"JoinRequest"> | string
    requestedAt?: DateTimeFilter<"JoinRequest"> | Date | string
    handledAt?: DateTimeNullableFilter<"JoinRequest"> | Date | string | null
    classroom?: XOR<ClassroomScalarRelationFilter, ClassroomWhereInput>
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type JoinRequestOrderByWithRelationInput = {
    id?: SortOrder
    classroomId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    handledAt?: SortOrderInput | SortOrder
    classroom?: ClassroomOrderByWithRelationInput
    student?: UserOrderByWithRelationInput
  }

  export type JoinRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: JoinRequestWhereInput | JoinRequestWhereInput[]
    OR?: JoinRequestWhereInput[]
    NOT?: JoinRequestWhereInput | JoinRequestWhereInput[]
    classroomId?: IntFilter<"JoinRequest"> | number
    studentId?: IntFilter<"JoinRequest"> | number
    status?: StringFilter<"JoinRequest"> | string
    requestedAt?: DateTimeFilter<"JoinRequest"> | Date | string
    handledAt?: DateTimeNullableFilter<"JoinRequest"> | Date | string | null
    classroom?: XOR<ClassroomScalarRelationFilter, ClassroomWhereInput>
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type JoinRequestOrderByWithAggregationInput = {
    id?: SortOrder
    classroomId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    handledAt?: SortOrderInput | SortOrder
    _count?: JoinRequestCountOrderByAggregateInput
    _avg?: JoinRequestAvgOrderByAggregateInput
    _max?: JoinRequestMaxOrderByAggregateInput
    _min?: JoinRequestMinOrderByAggregateInput
    _sum?: JoinRequestSumOrderByAggregateInput
  }

  export type JoinRequestScalarWhereWithAggregatesInput = {
    AND?: JoinRequestScalarWhereWithAggregatesInput | JoinRequestScalarWhereWithAggregatesInput[]
    OR?: JoinRequestScalarWhereWithAggregatesInput[]
    NOT?: JoinRequestScalarWhereWithAggregatesInput | JoinRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"JoinRequest"> | number
    classroomId?: IntWithAggregatesFilter<"JoinRequest"> | number
    studentId?: IntWithAggregatesFilter<"JoinRequest"> | number
    status?: StringWithAggregatesFilter<"JoinRequest"> | string
    requestedAt?: DateTimeWithAggregatesFilter<"JoinRequest"> | Date | string
    handledAt?: DateTimeNullableWithAggregatesFilter<"JoinRequest"> | Date | string | null
  }

  export type LessonWhereInput = {
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    id?: IntFilter<"Lesson"> | number
    classroomId?: IntFilter<"Lesson"> | number
    parentId?: IntNullableFilter<"Lesson"> | number | null
    title?: StringFilter<"Lesson"> | string
    content?: StringNullableFilter<"Lesson"> | string | null
    lessonType?: EnumLessonTypeFilter<"Lesson"> | $Enums.LessonType
    orderIndex?: IntFilter<"Lesson"> | number
    publishedAt?: DateTimeNullableFilter<"Lesson"> | Date | string | null
    classroom?: XOR<ClassroomScalarRelationFilter, ClassroomWhereInput>
    materials?: MaterialListRelationFilter
    exercises?: ExerciseListRelationFilter
    quizzes?: QuizListRelationFilter
    parent?: XOR<LessonNullableScalarRelationFilter, LessonWhereInput> | null
    subLessons?: LessonListRelationFilter
  }

  export type LessonOrderByWithRelationInput = {
    id?: SortOrder
    classroomId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    lessonType?: SortOrder
    orderIndex?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    classroom?: ClassroomOrderByWithRelationInput
    materials?: MaterialOrderByRelationAggregateInput
    exercises?: ExerciseOrderByRelationAggregateInput
    quizzes?: QuizOrderByRelationAggregateInput
    parent?: LessonOrderByWithRelationInput
    subLessons?: LessonOrderByRelationAggregateInput
  }

  export type LessonWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    classroomId?: IntFilter<"Lesson"> | number
    parentId?: IntNullableFilter<"Lesson"> | number | null
    title?: StringFilter<"Lesson"> | string
    content?: StringNullableFilter<"Lesson"> | string | null
    lessonType?: EnumLessonTypeFilter<"Lesson"> | $Enums.LessonType
    orderIndex?: IntFilter<"Lesson"> | number
    publishedAt?: DateTimeNullableFilter<"Lesson"> | Date | string | null
    classroom?: XOR<ClassroomScalarRelationFilter, ClassroomWhereInput>
    materials?: MaterialListRelationFilter
    exercises?: ExerciseListRelationFilter
    quizzes?: QuizListRelationFilter
    parent?: XOR<LessonNullableScalarRelationFilter, LessonWhereInput> | null
    subLessons?: LessonListRelationFilter
  }, "id">

  export type LessonOrderByWithAggregationInput = {
    id?: SortOrder
    classroomId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    lessonType?: SortOrder
    orderIndex?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    _count?: LessonCountOrderByAggregateInput
    _avg?: LessonAvgOrderByAggregateInput
    _max?: LessonMaxOrderByAggregateInput
    _min?: LessonMinOrderByAggregateInput
    _sum?: LessonSumOrderByAggregateInput
  }

  export type LessonScalarWhereWithAggregatesInput = {
    AND?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    OR?: LessonScalarWhereWithAggregatesInput[]
    NOT?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Lesson"> | number
    classroomId?: IntWithAggregatesFilter<"Lesson"> | number
    parentId?: IntNullableWithAggregatesFilter<"Lesson"> | number | null
    title?: StringWithAggregatesFilter<"Lesson"> | string
    content?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    lessonType?: EnumLessonTypeWithAggregatesFilter<"Lesson"> | $Enums.LessonType
    orderIndex?: IntWithAggregatesFilter<"Lesson"> | number
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Lesson"> | Date | string | null
  }

  export type MaterialWhereInput = {
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    id?: IntFilter<"Material"> | number
    lessonId?: IntFilter<"Material"> | number
    title?: StringFilter<"Material"> | string
    mediaId?: IntFilter<"Material"> | number
    uploadedBy?: IntFilter<"Material"> | number
    uploadedAt?: DateTimeFilter<"Material"> | Date | string
    lesson?: XOR<LessonNullableScalarRelationFilter, LessonWhereInput> | null
    media?: XOR<MediaScalarRelationFilter, MediaWhereInput>
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MaterialOrderByWithRelationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    title?: SortOrder
    mediaId?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    lesson?: LessonOrderByWithRelationInput
    media?: MediaOrderByWithRelationInput
    uploader?: UserOrderByWithRelationInput
  }

  export type MaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    lessonId?: IntFilter<"Material"> | number
    title?: StringFilter<"Material"> | string
    mediaId?: IntFilter<"Material"> | number
    uploadedBy?: IntFilter<"Material"> | number
    uploadedAt?: DateTimeFilter<"Material"> | Date | string
    lesson?: XOR<LessonNullableScalarRelationFilter, LessonWhereInput> | null
    media?: XOR<MediaScalarRelationFilter, MediaWhereInput>
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MaterialOrderByWithAggregationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    title?: SortOrder
    mediaId?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    _count?: MaterialCountOrderByAggregateInput
    _avg?: MaterialAvgOrderByAggregateInput
    _max?: MaterialMaxOrderByAggregateInput
    _min?: MaterialMinOrderByAggregateInput
    _sum?: MaterialSumOrderByAggregateInput
  }

  export type MaterialScalarWhereWithAggregatesInput = {
    AND?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    OR?: MaterialScalarWhereWithAggregatesInput[]
    NOT?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Material"> | number
    lessonId?: IntWithAggregatesFilter<"Material"> | number
    title?: StringWithAggregatesFilter<"Material"> | string
    mediaId?: IntWithAggregatesFilter<"Material"> | number
    uploadedBy?: IntWithAggregatesFilter<"Material"> | number
    uploadedAt?: DateTimeWithAggregatesFilter<"Material"> | Date | string
  }

  export type ExerciseWhereInput = {
    AND?: ExerciseWhereInput | ExerciseWhereInput[]
    OR?: ExerciseWhereInput[]
    NOT?: ExerciseWhereInput | ExerciseWhereInput[]
    id?: IntFilter<"Exercise"> | number
    lessonId?: IntFilter<"Exercise"> | number
    title?: StringFilter<"Exercise"> | string
    description?: StringNullableFilter<"Exercise"> | string | null
    attachMediaId?: IntNullableFilter<"Exercise"> | number | null
    dueAt?: DateTimeNullableFilter<"Exercise"> | Date | string | null
    createdBy?: IntFilter<"Exercise"> | number
    createdAt?: DateTimeFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeFilter<"Exercise"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Exercise"> | Date | string | null
    lesson?: XOR<LessonNullableScalarRelationFilter, LessonWhereInput> | null
    attachMedia?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    submissions?: ExerciseSubmissionListRelationFilter
  }

  export type ExerciseOrderByWithRelationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    attachMediaId?: SortOrderInput | SortOrder
    dueAt?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    lesson?: LessonOrderByWithRelationInput
    attachMedia?: MediaOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    submissions?: ExerciseSubmissionOrderByRelationAggregateInput
  }

  export type ExerciseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ExerciseWhereInput | ExerciseWhereInput[]
    OR?: ExerciseWhereInput[]
    NOT?: ExerciseWhereInput | ExerciseWhereInput[]
    lessonId?: IntFilter<"Exercise"> | number
    title?: StringFilter<"Exercise"> | string
    description?: StringNullableFilter<"Exercise"> | string | null
    attachMediaId?: IntNullableFilter<"Exercise"> | number | null
    dueAt?: DateTimeNullableFilter<"Exercise"> | Date | string | null
    createdBy?: IntFilter<"Exercise"> | number
    createdAt?: DateTimeFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeFilter<"Exercise"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Exercise"> | Date | string | null
    lesson?: XOR<LessonNullableScalarRelationFilter, LessonWhereInput> | null
    attachMedia?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    submissions?: ExerciseSubmissionListRelationFilter
  }, "id">

  export type ExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    attachMediaId?: SortOrderInput | SortOrder
    dueAt?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ExerciseCountOrderByAggregateInput
    _avg?: ExerciseAvgOrderByAggregateInput
    _max?: ExerciseMaxOrderByAggregateInput
    _min?: ExerciseMinOrderByAggregateInput
    _sum?: ExerciseSumOrderByAggregateInput
  }

  export type ExerciseScalarWhereWithAggregatesInput = {
    AND?: ExerciseScalarWhereWithAggregatesInput | ExerciseScalarWhereWithAggregatesInput[]
    OR?: ExerciseScalarWhereWithAggregatesInput[]
    NOT?: ExerciseScalarWhereWithAggregatesInput | ExerciseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Exercise"> | number
    lessonId?: IntWithAggregatesFilter<"Exercise"> | number
    title?: StringWithAggregatesFilter<"Exercise"> | string
    description?: StringNullableWithAggregatesFilter<"Exercise"> | string | null
    attachMediaId?: IntNullableWithAggregatesFilter<"Exercise"> | number | null
    dueAt?: DateTimeNullableWithAggregatesFilter<"Exercise"> | Date | string | null
    createdBy?: IntWithAggregatesFilter<"Exercise"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Exercise"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Exercise"> | Date | string | null
  }

  export type ExerciseSubmissionWhereInput = {
    AND?: ExerciseSubmissionWhereInput | ExerciseSubmissionWhereInput[]
    OR?: ExerciseSubmissionWhereInput[]
    NOT?: ExerciseSubmissionWhereInput | ExerciseSubmissionWhereInput[]
    id?: IntFilter<"ExerciseSubmission"> | number
    exerciseId?: IntFilter<"ExerciseSubmission"> | number
    studentId?: IntFilter<"ExerciseSubmission"> | number
    mediaId?: IntFilter<"ExerciseSubmission"> | number
    submittedAt?: DateTimeFilter<"ExerciseSubmission"> | Date | string
    score?: DecimalNullableFilter<"ExerciseSubmission"> | Decimal | DecimalJsLike | number | string | null
    comment?: StringNullableFilter<"ExerciseSubmission"> | string | null
    gradedAt?: DateTimeNullableFilter<"ExerciseSubmission"> | Date | string | null
    exercise?: XOR<ExerciseScalarRelationFilter, ExerciseWhereInput>
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
    media?: XOR<MediaScalarRelationFilter, MediaWhereInput>
  }

  export type ExerciseSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    studentId?: SortOrder
    mediaId?: SortOrder
    submittedAt?: SortOrder
    score?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    gradedAt?: SortOrderInput | SortOrder
    exercise?: ExerciseOrderByWithRelationInput
    student?: UserOrderByWithRelationInput
    media?: MediaOrderByWithRelationInput
  }

  export type ExerciseSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    exerciseId_studentId?: ExerciseSubmissionExerciseIdStudentIdCompoundUniqueInput
    AND?: ExerciseSubmissionWhereInput | ExerciseSubmissionWhereInput[]
    OR?: ExerciseSubmissionWhereInput[]
    NOT?: ExerciseSubmissionWhereInput | ExerciseSubmissionWhereInput[]
    exerciseId?: IntFilter<"ExerciseSubmission"> | number
    studentId?: IntFilter<"ExerciseSubmission"> | number
    mediaId?: IntFilter<"ExerciseSubmission"> | number
    submittedAt?: DateTimeFilter<"ExerciseSubmission"> | Date | string
    score?: DecimalNullableFilter<"ExerciseSubmission"> | Decimal | DecimalJsLike | number | string | null
    comment?: StringNullableFilter<"ExerciseSubmission"> | string | null
    gradedAt?: DateTimeNullableFilter<"ExerciseSubmission"> | Date | string | null
    exercise?: XOR<ExerciseScalarRelationFilter, ExerciseWhereInput>
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
    media?: XOR<MediaScalarRelationFilter, MediaWhereInput>
  }, "id" | "exerciseId_studentId">

  export type ExerciseSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    studentId?: SortOrder
    mediaId?: SortOrder
    submittedAt?: SortOrder
    score?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    gradedAt?: SortOrderInput | SortOrder
    _count?: ExerciseSubmissionCountOrderByAggregateInput
    _avg?: ExerciseSubmissionAvgOrderByAggregateInput
    _max?: ExerciseSubmissionMaxOrderByAggregateInput
    _min?: ExerciseSubmissionMinOrderByAggregateInput
    _sum?: ExerciseSubmissionSumOrderByAggregateInput
  }

  export type ExerciseSubmissionScalarWhereWithAggregatesInput = {
    AND?: ExerciseSubmissionScalarWhereWithAggregatesInput | ExerciseSubmissionScalarWhereWithAggregatesInput[]
    OR?: ExerciseSubmissionScalarWhereWithAggregatesInput[]
    NOT?: ExerciseSubmissionScalarWhereWithAggregatesInput | ExerciseSubmissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ExerciseSubmission"> | number
    exerciseId?: IntWithAggregatesFilter<"ExerciseSubmission"> | number
    studentId?: IntWithAggregatesFilter<"ExerciseSubmission"> | number
    mediaId?: IntWithAggregatesFilter<"ExerciseSubmission"> | number
    submittedAt?: DateTimeWithAggregatesFilter<"ExerciseSubmission"> | Date | string
    score?: DecimalNullableWithAggregatesFilter<"ExerciseSubmission"> | Decimal | DecimalJsLike | number | string | null
    comment?: StringNullableWithAggregatesFilter<"ExerciseSubmission"> | string | null
    gradedAt?: DateTimeNullableWithAggregatesFilter<"ExerciseSubmission"> | Date | string | null
  }

  export type QuizWhereInput = {
    AND?: QuizWhereInput | QuizWhereInput[]
    OR?: QuizWhereInput[]
    NOT?: QuizWhereInput | QuizWhereInput[]
    id?: IntFilter<"Quiz"> | number
    lessonId?: IntFilter<"Quiz"> | number
    title?: StringFilter<"Quiz"> | string
    description?: StringNullableFilter<"Quiz"> | string | null
    timeLimitSec?: IntNullableFilter<"Quiz"> | number | null
    maxAttempts?: IntFilter<"Quiz"> | number
    shuffleQuestions?: BoolFilter<"Quiz"> | boolean
    shuffleOptions?: BoolFilter<"Quiz"> | boolean
    gradingMethod?: StringFilter<"Quiz"> | string
    showAnswersAfter?: StringFilter<"Quiz"> | string
    dueAt?: DateTimeNullableFilter<"Quiz"> | Date | string | null
    isPublished?: BoolFilter<"Quiz"> | boolean
    totalPoints?: DecimalFilter<"Quiz"> | Decimal | DecimalJsLike | number | string
    createdBy?: IntFilter<"Quiz"> | number
    createdAt?: DateTimeFilter<"Quiz"> | Date | string
    updatedAt?: DateTimeFilter<"Quiz"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Quiz"> | Date | string | null
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    sections?: QuizSectionListRelationFilter
    questionGroups?: QuizQuestionGroupListRelationFilter
    questions?: QuizQuestionListRelationFilter
    attempts?: QuizAttemptListRelationFilter
  }

  export type QuizOrderByWithRelationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    timeLimitSec?: SortOrderInput | SortOrder
    maxAttempts?: SortOrder
    shuffleQuestions?: SortOrder
    shuffleOptions?: SortOrder
    gradingMethod?: SortOrder
    showAnswersAfter?: SortOrder
    dueAt?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    totalPoints?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    lesson?: LessonOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    sections?: QuizSectionOrderByRelationAggregateInput
    questionGroups?: QuizQuestionGroupOrderByRelationAggregateInput
    questions?: QuizQuestionOrderByRelationAggregateInput
    attempts?: QuizAttemptOrderByRelationAggregateInput
  }

  export type QuizWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuizWhereInput | QuizWhereInput[]
    OR?: QuizWhereInput[]
    NOT?: QuizWhereInput | QuizWhereInput[]
    lessonId?: IntFilter<"Quiz"> | number
    title?: StringFilter<"Quiz"> | string
    description?: StringNullableFilter<"Quiz"> | string | null
    timeLimitSec?: IntNullableFilter<"Quiz"> | number | null
    maxAttempts?: IntFilter<"Quiz"> | number
    shuffleQuestions?: BoolFilter<"Quiz"> | boolean
    shuffleOptions?: BoolFilter<"Quiz"> | boolean
    gradingMethod?: StringFilter<"Quiz"> | string
    showAnswersAfter?: StringFilter<"Quiz"> | string
    dueAt?: DateTimeNullableFilter<"Quiz"> | Date | string | null
    isPublished?: BoolFilter<"Quiz"> | boolean
    totalPoints?: DecimalFilter<"Quiz"> | Decimal | DecimalJsLike | number | string
    createdBy?: IntFilter<"Quiz"> | number
    createdAt?: DateTimeFilter<"Quiz"> | Date | string
    updatedAt?: DateTimeFilter<"Quiz"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Quiz"> | Date | string | null
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    sections?: QuizSectionListRelationFilter
    questionGroups?: QuizQuestionGroupListRelationFilter
    questions?: QuizQuestionListRelationFilter
    attempts?: QuizAttemptListRelationFilter
  }, "id">

  export type QuizOrderByWithAggregationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    timeLimitSec?: SortOrderInput | SortOrder
    maxAttempts?: SortOrder
    shuffleQuestions?: SortOrder
    shuffleOptions?: SortOrder
    gradingMethod?: SortOrder
    showAnswersAfter?: SortOrder
    dueAt?: SortOrderInput | SortOrder
    isPublished?: SortOrder
    totalPoints?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: QuizCountOrderByAggregateInput
    _avg?: QuizAvgOrderByAggregateInput
    _max?: QuizMaxOrderByAggregateInput
    _min?: QuizMinOrderByAggregateInput
    _sum?: QuizSumOrderByAggregateInput
  }

  export type QuizScalarWhereWithAggregatesInput = {
    AND?: QuizScalarWhereWithAggregatesInput | QuizScalarWhereWithAggregatesInput[]
    OR?: QuizScalarWhereWithAggregatesInput[]
    NOT?: QuizScalarWhereWithAggregatesInput | QuizScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Quiz"> | number
    lessonId?: IntWithAggregatesFilter<"Quiz"> | number
    title?: StringWithAggregatesFilter<"Quiz"> | string
    description?: StringNullableWithAggregatesFilter<"Quiz"> | string | null
    timeLimitSec?: IntNullableWithAggregatesFilter<"Quiz"> | number | null
    maxAttempts?: IntWithAggregatesFilter<"Quiz"> | number
    shuffleQuestions?: BoolWithAggregatesFilter<"Quiz"> | boolean
    shuffleOptions?: BoolWithAggregatesFilter<"Quiz"> | boolean
    gradingMethod?: StringWithAggregatesFilter<"Quiz"> | string
    showAnswersAfter?: StringWithAggregatesFilter<"Quiz"> | string
    dueAt?: DateTimeNullableWithAggregatesFilter<"Quiz"> | Date | string | null
    isPublished?: BoolWithAggregatesFilter<"Quiz"> | boolean
    totalPoints?: DecimalWithAggregatesFilter<"Quiz"> | Decimal | DecimalJsLike | number | string
    createdBy?: IntWithAggregatesFilter<"Quiz"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Quiz"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Quiz"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Quiz"> | Date | string | null
  }

  export type QuizSectionWhereInput = {
    AND?: QuizSectionWhereInput | QuizSectionWhereInput[]
    OR?: QuizSectionWhereInput[]
    NOT?: QuizSectionWhereInput | QuizSectionWhereInput[]
    id?: IntFilter<"QuizSection"> | number
    quizId?: IntFilter<"QuizSection"> | number
    title?: StringFilter<"QuizSection"> | string
    description?: StringNullableFilter<"QuizSection"> | string | null
    orderIndex?: IntFilter<"QuizSection"> | number
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
    questionGroups?: QuizQuestionGroupListRelationFilter
    questions?: QuizQuestionListRelationFilter
  }

  export type QuizSectionOrderByWithRelationInput = {
    id?: SortOrder
    quizId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    orderIndex?: SortOrder
    quiz?: QuizOrderByWithRelationInput
    questionGroups?: QuizQuestionGroupOrderByRelationAggregateInput
    questions?: QuizQuestionOrderByRelationAggregateInput
  }

  export type QuizSectionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuizSectionWhereInput | QuizSectionWhereInput[]
    OR?: QuizSectionWhereInput[]
    NOT?: QuizSectionWhereInput | QuizSectionWhereInput[]
    quizId?: IntFilter<"QuizSection"> | number
    title?: StringFilter<"QuizSection"> | string
    description?: StringNullableFilter<"QuizSection"> | string | null
    orderIndex?: IntFilter<"QuizSection"> | number
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
    questionGroups?: QuizQuestionGroupListRelationFilter
    questions?: QuizQuestionListRelationFilter
  }, "id">

  export type QuizSectionOrderByWithAggregationInput = {
    id?: SortOrder
    quizId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    orderIndex?: SortOrder
    _count?: QuizSectionCountOrderByAggregateInput
    _avg?: QuizSectionAvgOrderByAggregateInput
    _max?: QuizSectionMaxOrderByAggregateInput
    _min?: QuizSectionMinOrderByAggregateInput
    _sum?: QuizSectionSumOrderByAggregateInput
  }

  export type QuizSectionScalarWhereWithAggregatesInput = {
    AND?: QuizSectionScalarWhereWithAggregatesInput | QuizSectionScalarWhereWithAggregatesInput[]
    OR?: QuizSectionScalarWhereWithAggregatesInput[]
    NOT?: QuizSectionScalarWhereWithAggregatesInput | QuizSectionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuizSection"> | number
    quizId?: IntWithAggregatesFilter<"QuizSection"> | number
    title?: StringWithAggregatesFilter<"QuizSection"> | string
    description?: StringNullableWithAggregatesFilter<"QuizSection"> | string | null
    orderIndex?: IntWithAggregatesFilter<"QuizSection"> | number
  }

  export type QuizQuestionGroupWhereInput = {
    AND?: QuizQuestionGroupWhereInput | QuizQuestionGroupWhereInput[]
    OR?: QuizQuestionGroupWhereInput[]
    NOT?: QuizQuestionGroupWhereInput | QuizQuestionGroupWhereInput[]
    id?: IntFilter<"QuizQuestionGroup"> | number
    quizId?: IntFilter<"QuizQuestionGroup"> | number
    sectionId?: IntNullableFilter<"QuizQuestionGroup"> | number | null
    title?: StringNullableFilter<"QuizQuestionGroup"> | string | null
    introText?: StringNullableFilter<"QuizQuestionGroup"> | string | null
    orderIndex?: IntFilter<"QuizQuestionGroup"> | number
    shuffleInside?: BoolFilter<"QuizQuestionGroup"> | boolean
    pointsPolicy?: StringFilter<"QuizQuestionGroup"> | string
    createdAt?: DateTimeFilter<"QuizQuestionGroup"> | Date | string
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
    section?: XOR<QuizSectionNullableScalarRelationFilter, QuizSectionWhereInput> | null
    questions?: QuizQuestionListRelationFilter
    medias?: QuizQuestionGroupMediaListRelationFilter
  }

  export type QuizQuestionGroupOrderByWithRelationInput = {
    id?: SortOrder
    quizId?: SortOrder
    sectionId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    introText?: SortOrderInput | SortOrder
    orderIndex?: SortOrder
    shuffleInside?: SortOrder
    pointsPolicy?: SortOrder
    createdAt?: SortOrder
    quiz?: QuizOrderByWithRelationInput
    section?: QuizSectionOrderByWithRelationInput
    questions?: QuizQuestionOrderByRelationAggregateInput
    medias?: QuizQuestionGroupMediaOrderByRelationAggregateInput
  }

  export type QuizQuestionGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuizQuestionGroupWhereInput | QuizQuestionGroupWhereInput[]
    OR?: QuizQuestionGroupWhereInput[]
    NOT?: QuizQuestionGroupWhereInput | QuizQuestionGroupWhereInput[]
    quizId?: IntFilter<"QuizQuestionGroup"> | number
    sectionId?: IntNullableFilter<"QuizQuestionGroup"> | number | null
    title?: StringNullableFilter<"QuizQuestionGroup"> | string | null
    introText?: StringNullableFilter<"QuizQuestionGroup"> | string | null
    orderIndex?: IntFilter<"QuizQuestionGroup"> | number
    shuffleInside?: BoolFilter<"QuizQuestionGroup"> | boolean
    pointsPolicy?: StringFilter<"QuizQuestionGroup"> | string
    createdAt?: DateTimeFilter<"QuizQuestionGroup"> | Date | string
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
    section?: XOR<QuizSectionNullableScalarRelationFilter, QuizSectionWhereInput> | null
    questions?: QuizQuestionListRelationFilter
    medias?: QuizQuestionGroupMediaListRelationFilter
  }, "id">

  export type QuizQuestionGroupOrderByWithAggregationInput = {
    id?: SortOrder
    quizId?: SortOrder
    sectionId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    introText?: SortOrderInput | SortOrder
    orderIndex?: SortOrder
    shuffleInside?: SortOrder
    pointsPolicy?: SortOrder
    createdAt?: SortOrder
    _count?: QuizQuestionGroupCountOrderByAggregateInput
    _avg?: QuizQuestionGroupAvgOrderByAggregateInput
    _max?: QuizQuestionGroupMaxOrderByAggregateInput
    _min?: QuizQuestionGroupMinOrderByAggregateInput
    _sum?: QuizQuestionGroupSumOrderByAggregateInput
  }

  export type QuizQuestionGroupScalarWhereWithAggregatesInput = {
    AND?: QuizQuestionGroupScalarWhereWithAggregatesInput | QuizQuestionGroupScalarWhereWithAggregatesInput[]
    OR?: QuizQuestionGroupScalarWhereWithAggregatesInput[]
    NOT?: QuizQuestionGroupScalarWhereWithAggregatesInput | QuizQuestionGroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuizQuestionGroup"> | number
    quizId?: IntWithAggregatesFilter<"QuizQuestionGroup"> | number
    sectionId?: IntNullableWithAggregatesFilter<"QuizQuestionGroup"> | number | null
    title?: StringNullableWithAggregatesFilter<"QuizQuestionGroup"> | string | null
    introText?: StringNullableWithAggregatesFilter<"QuizQuestionGroup"> | string | null
    orderIndex?: IntWithAggregatesFilter<"QuizQuestionGroup"> | number
    shuffleInside?: BoolWithAggregatesFilter<"QuizQuestionGroup"> | boolean
    pointsPolicy?: StringWithAggregatesFilter<"QuizQuestionGroup"> | string
    createdAt?: DateTimeWithAggregatesFilter<"QuizQuestionGroup"> | Date | string
  }

  export type QuizQuestionWhereInput = {
    AND?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    OR?: QuizQuestionWhereInput[]
    NOT?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    id?: IntFilter<"QuizQuestion"> | number
    quizId?: IntFilter<"QuizQuestion"> | number
    sectionId?: IntNullableFilter<"QuizQuestion"> | number | null
    groupId?: IntNullableFilter<"QuizQuestion"> | number | null
    content?: StringFilter<"QuizQuestion"> | string
    explanation?: StringNullableFilter<"QuizQuestion"> | string | null
    questionType?: StringFilter<"QuizQuestion"> | string
    points?: DecimalFilter<"QuizQuestion"> | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFilter<"QuizQuestion"> | number
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
    section?: XOR<QuizSectionNullableScalarRelationFilter, QuizSectionWhereInput> | null
    group?: XOR<QuizQuestionGroupNullableScalarRelationFilter, QuizQuestionGroupWhereInput> | null
    options?: QuizOptionListRelationFilter
    answers?: QuizAnswerListRelationFilter
    medias?: QuizQuestionMediaListRelationFilter
  }

  export type QuizQuestionOrderByWithRelationInput = {
    id?: SortOrder
    quizId?: SortOrder
    sectionId?: SortOrderInput | SortOrder
    groupId?: SortOrderInput | SortOrder
    content?: SortOrder
    explanation?: SortOrderInput | SortOrder
    questionType?: SortOrder
    points?: SortOrder
    orderIndex?: SortOrder
    quiz?: QuizOrderByWithRelationInput
    section?: QuizSectionOrderByWithRelationInput
    group?: QuizQuestionGroupOrderByWithRelationInput
    options?: QuizOptionOrderByRelationAggregateInput
    answers?: QuizAnswerOrderByRelationAggregateInput
    medias?: QuizQuestionMediaOrderByRelationAggregateInput
  }

  export type QuizQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    OR?: QuizQuestionWhereInput[]
    NOT?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    quizId?: IntFilter<"QuizQuestion"> | number
    sectionId?: IntNullableFilter<"QuizQuestion"> | number | null
    groupId?: IntNullableFilter<"QuizQuestion"> | number | null
    content?: StringFilter<"QuizQuestion"> | string
    explanation?: StringNullableFilter<"QuizQuestion"> | string | null
    questionType?: StringFilter<"QuizQuestion"> | string
    points?: DecimalFilter<"QuizQuestion"> | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFilter<"QuizQuestion"> | number
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
    section?: XOR<QuizSectionNullableScalarRelationFilter, QuizSectionWhereInput> | null
    group?: XOR<QuizQuestionGroupNullableScalarRelationFilter, QuizQuestionGroupWhereInput> | null
    options?: QuizOptionListRelationFilter
    answers?: QuizAnswerListRelationFilter
    medias?: QuizQuestionMediaListRelationFilter
  }, "id">

  export type QuizQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    quizId?: SortOrder
    sectionId?: SortOrderInput | SortOrder
    groupId?: SortOrderInput | SortOrder
    content?: SortOrder
    explanation?: SortOrderInput | SortOrder
    questionType?: SortOrder
    points?: SortOrder
    orderIndex?: SortOrder
    _count?: QuizQuestionCountOrderByAggregateInput
    _avg?: QuizQuestionAvgOrderByAggregateInput
    _max?: QuizQuestionMaxOrderByAggregateInput
    _min?: QuizQuestionMinOrderByAggregateInput
    _sum?: QuizQuestionSumOrderByAggregateInput
  }

  export type QuizQuestionScalarWhereWithAggregatesInput = {
    AND?: QuizQuestionScalarWhereWithAggregatesInput | QuizQuestionScalarWhereWithAggregatesInput[]
    OR?: QuizQuestionScalarWhereWithAggregatesInput[]
    NOT?: QuizQuestionScalarWhereWithAggregatesInput | QuizQuestionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuizQuestion"> | number
    quizId?: IntWithAggregatesFilter<"QuizQuestion"> | number
    sectionId?: IntNullableWithAggregatesFilter<"QuizQuestion"> | number | null
    groupId?: IntNullableWithAggregatesFilter<"QuizQuestion"> | number | null
    content?: StringWithAggregatesFilter<"QuizQuestion"> | string
    explanation?: StringNullableWithAggregatesFilter<"QuizQuestion"> | string | null
    questionType?: StringWithAggregatesFilter<"QuizQuestion"> | string
    points?: DecimalWithAggregatesFilter<"QuizQuestion"> | Decimal | DecimalJsLike | number | string
    orderIndex?: IntWithAggregatesFilter<"QuizQuestion"> | number
  }

  export type QuizOptionWhereInput = {
    AND?: QuizOptionWhereInput | QuizOptionWhereInput[]
    OR?: QuizOptionWhereInput[]
    NOT?: QuizOptionWhereInput | QuizOptionWhereInput[]
    id?: IntFilter<"QuizOption"> | number
    questionId?: IntFilter<"QuizOption"> | number
    content?: StringFilter<"QuizOption"> | string
    isCorrect?: BoolFilter<"QuizOption"> | boolean
    orderIndex?: IntFilter<"QuizOption"> | number
    question?: XOR<QuizQuestionScalarRelationFilter, QuizQuestionWhereInput>
    answers?: QuizAnswerListRelationFilter
    medias?: QuizOptionMediaListRelationFilter
  }

  export type QuizOptionOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    content?: SortOrder
    isCorrect?: SortOrder
    orderIndex?: SortOrder
    question?: QuizQuestionOrderByWithRelationInput
    answers?: QuizAnswerOrderByRelationAggregateInput
    medias?: QuizOptionMediaOrderByRelationAggregateInput
  }

  export type QuizOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuizOptionWhereInput | QuizOptionWhereInput[]
    OR?: QuizOptionWhereInput[]
    NOT?: QuizOptionWhereInput | QuizOptionWhereInput[]
    questionId?: IntFilter<"QuizOption"> | number
    content?: StringFilter<"QuizOption"> | string
    isCorrect?: BoolFilter<"QuizOption"> | boolean
    orderIndex?: IntFilter<"QuizOption"> | number
    question?: XOR<QuizQuestionScalarRelationFilter, QuizQuestionWhereInput>
    answers?: QuizAnswerListRelationFilter
    medias?: QuizOptionMediaListRelationFilter
  }, "id">

  export type QuizOptionOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    content?: SortOrder
    isCorrect?: SortOrder
    orderIndex?: SortOrder
    _count?: QuizOptionCountOrderByAggregateInput
    _avg?: QuizOptionAvgOrderByAggregateInput
    _max?: QuizOptionMaxOrderByAggregateInput
    _min?: QuizOptionMinOrderByAggregateInput
    _sum?: QuizOptionSumOrderByAggregateInput
  }

  export type QuizOptionScalarWhereWithAggregatesInput = {
    AND?: QuizOptionScalarWhereWithAggregatesInput | QuizOptionScalarWhereWithAggregatesInput[]
    OR?: QuizOptionScalarWhereWithAggregatesInput[]
    NOT?: QuizOptionScalarWhereWithAggregatesInput | QuizOptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuizOption"> | number
    questionId?: IntWithAggregatesFilter<"QuizOption"> | number
    content?: StringWithAggregatesFilter<"QuizOption"> | string
    isCorrect?: BoolWithAggregatesFilter<"QuizOption"> | boolean
    orderIndex?: IntWithAggregatesFilter<"QuizOption"> | number
  }

  export type QuizAttemptWhereInput = {
    AND?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    OR?: QuizAttemptWhereInput[]
    NOT?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    id?: IntFilter<"QuizAttempt"> | number
    quizId?: IntFilter<"QuizAttempt"> | number
    studentId?: IntFilter<"QuizAttempt"> | number
    startedAt?: DateTimeFilter<"QuizAttempt"> | Date | string
    submittedAt?: DateTimeNullableFilter<"QuizAttempt"> | Date | string | null
    status?: StringFilter<"QuizAttempt"> | string
    scoreRaw?: DecimalNullableFilter<"QuizAttempt"> | Decimal | DecimalJsLike | number | string | null
    scoreScaled10?: DecimalNullableFilter<"QuizAttempt"> | Decimal | DecimalJsLike | number | string | null
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
    answers?: QuizAnswerListRelationFilter
  }

  export type QuizAttemptOrderByWithRelationInput = {
    id?: SortOrder
    quizId?: SortOrder
    studentId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    scoreRaw?: SortOrderInput | SortOrder
    scoreScaled10?: SortOrderInput | SortOrder
    quiz?: QuizOrderByWithRelationInput
    student?: UserOrderByWithRelationInput
    answers?: QuizAnswerOrderByRelationAggregateInput
  }

  export type QuizAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    OR?: QuizAttemptWhereInput[]
    NOT?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    quizId?: IntFilter<"QuizAttempt"> | number
    studentId?: IntFilter<"QuizAttempt"> | number
    startedAt?: DateTimeFilter<"QuizAttempt"> | Date | string
    submittedAt?: DateTimeNullableFilter<"QuizAttempt"> | Date | string | null
    status?: StringFilter<"QuizAttempt"> | string
    scoreRaw?: DecimalNullableFilter<"QuizAttempt"> | Decimal | DecimalJsLike | number | string | null
    scoreScaled10?: DecimalNullableFilter<"QuizAttempt"> | Decimal | DecimalJsLike | number | string | null
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
    answers?: QuizAnswerListRelationFilter
  }, "id">

  export type QuizAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    quizId?: SortOrder
    studentId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    scoreRaw?: SortOrderInput | SortOrder
    scoreScaled10?: SortOrderInput | SortOrder
    _count?: QuizAttemptCountOrderByAggregateInput
    _avg?: QuizAttemptAvgOrderByAggregateInput
    _max?: QuizAttemptMaxOrderByAggregateInput
    _min?: QuizAttemptMinOrderByAggregateInput
    _sum?: QuizAttemptSumOrderByAggregateInput
  }

  export type QuizAttemptScalarWhereWithAggregatesInput = {
    AND?: QuizAttemptScalarWhereWithAggregatesInput | QuizAttemptScalarWhereWithAggregatesInput[]
    OR?: QuizAttemptScalarWhereWithAggregatesInput[]
    NOT?: QuizAttemptScalarWhereWithAggregatesInput | QuizAttemptScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuizAttempt"> | number
    quizId?: IntWithAggregatesFilter<"QuizAttempt"> | number
    studentId?: IntWithAggregatesFilter<"QuizAttempt"> | number
    startedAt?: DateTimeWithAggregatesFilter<"QuizAttempt"> | Date | string
    submittedAt?: DateTimeNullableWithAggregatesFilter<"QuizAttempt"> | Date | string | null
    status?: StringWithAggregatesFilter<"QuizAttempt"> | string
    scoreRaw?: DecimalNullableWithAggregatesFilter<"QuizAttempt"> | Decimal | DecimalJsLike | number | string | null
    scoreScaled10?: DecimalNullableWithAggregatesFilter<"QuizAttempt"> | Decimal | DecimalJsLike | number | string | null
  }

  export type QuizAnswerWhereInput = {
    AND?: QuizAnswerWhereInput | QuizAnswerWhereInput[]
    OR?: QuizAnswerWhereInput[]
    NOT?: QuizAnswerWhereInput | QuizAnswerWhereInput[]
    attemptId?: IntFilter<"QuizAnswer"> | number
    questionId?: IntFilter<"QuizAnswer"> | number
    optionId?: IntFilter<"QuizAnswer"> | number
    attempt?: XOR<QuizAttemptScalarRelationFilter, QuizAttemptWhereInput>
    question?: XOR<QuizQuestionScalarRelationFilter, QuizQuestionWhereInput>
    option?: XOR<QuizOptionScalarRelationFilter, QuizOptionWhereInput>
  }

  export type QuizAnswerOrderByWithRelationInput = {
    attemptId?: SortOrder
    questionId?: SortOrder
    optionId?: SortOrder
    attempt?: QuizAttemptOrderByWithRelationInput
    question?: QuizQuestionOrderByWithRelationInput
    option?: QuizOptionOrderByWithRelationInput
  }

  export type QuizAnswerWhereUniqueInput = Prisma.AtLeast<{
    attemptId_questionId_optionId?: QuizAnswerAttemptIdQuestionIdOptionIdCompoundUniqueInput
    AND?: QuizAnswerWhereInput | QuizAnswerWhereInput[]
    OR?: QuizAnswerWhereInput[]
    NOT?: QuizAnswerWhereInput | QuizAnswerWhereInput[]
    attemptId?: IntFilter<"QuizAnswer"> | number
    questionId?: IntFilter<"QuizAnswer"> | number
    optionId?: IntFilter<"QuizAnswer"> | number
    attempt?: XOR<QuizAttemptScalarRelationFilter, QuizAttemptWhereInput>
    question?: XOR<QuizQuestionScalarRelationFilter, QuizQuestionWhereInput>
    option?: XOR<QuizOptionScalarRelationFilter, QuizOptionWhereInput>
  }, "attemptId_questionId_optionId">

  export type QuizAnswerOrderByWithAggregationInput = {
    attemptId?: SortOrder
    questionId?: SortOrder
    optionId?: SortOrder
    _count?: QuizAnswerCountOrderByAggregateInput
    _avg?: QuizAnswerAvgOrderByAggregateInput
    _max?: QuizAnswerMaxOrderByAggregateInput
    _min?: QuizAnswerMinOrderByAggregateInput
    _sum?: QuizAnswerSumOrderByAggregateInput
  }

  export type QuizAnswerScalarWhereWithAggregatesInput = {
    AND?: QuizAnswerScalarWhereWithAggregatesInput | QuizAnswerScalarWhereWithAggregatesInput[]
    OR?: QuizAnswerScalarWhereWithAggregatesInput[]
    NOT?: QuizAnswerScalarWhereWithAggregatesInput | QuizAnswerScalarWhereWithAggregatesInput[]
    attemptId?: IntWithAggregatesFilter<"QuizAnswer"> | number
    questionId?: IntWithAggregatesFilter<"QuizAnswer"> | number
    optionId?: IntWithAggregatesFilter<"QuizAnswer"> | number
  }

  export type QuizQuestionGroupMediaWhereInput = {
    AND?: QuizQuestionGroupMediaWhereInput | QuizQuestionGroupMediaWhereInput[]
    OR?: QuizQuestionGroupMediaWhereInput[]
    NOT?: QuizQuestionGroupMediaWhereInput | QuizQuestionGroupMediaWhereInput[]
    id?: IntFilter<"QuizQuestionGroupMedia"> | number
    groupId?: IntFilter<"QuizQuestionGroupMedia"> | number
    mediaId?: IntFilter<"QuizQuestionGroupMedia"> | number
    createdAt?: DateTimeFilter<"QuizQuestionGroupMedia"> | Date | string
    group?: XOR<QuizQuestionGroupScalarRelationFilter, QuizQuestionGroupWhereInput>
    media?: XOR<MediaScalarRelationFilter, MediaWhereInput>
  }

  export type QuizQuestionGroupMediaOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    mediaId?: SortOrder
    createdAt?: SortOrder
    group?: QuizQuestionGroupOrderByWithRelationInput
    media?: MediaOrderByWithRelationInput
  }

  export type QuizQuestionGroupMediaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    groupId_mediaId?: QuizQuestionGroupMediaGroupIdMediaIdCompoundUniqueInput
    AND?: QuizQuestionGroupMediaWhereInput | QuizQuestionGroupMediaWhereInput[]
    OR?: QuizQuestionGroupMediaWhereInput[]
    NOT?: QuizQuestionGroupMediaWhereInput | QuizQuestionGroupMediaWhereInput[]
    groupId?: IntFilter<"QuizQuestionGroupMedia"> | number
    mediaId?: IntFilter<"QuizQuestionGroupMedia"> | number
    createdAt?: DateTimeFilter<"QuizQuestionGroupMedia"> | Date | string
    group?: XOR<QuizQuestionGroupScalarRelationFilter, QuizQuestionGroupWhereInput>
    media?: XOR<MediaScalarRelationFilter, MediaWhereInput>
  }, "id" | "groupId_mediaId">

  export type QuizQuestionGroupMediaOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    mediaId?: SortOrder
    createdAt?: SortOrder
    _count?: QuizQuestionGroupMediaCountOrderByAggregateInput
    _avg?: QuizQuestionGroupMediaAvgOrderByAggregateInput
    _max?: QuizQuestionGroupMediaMaxOrderByAggregateInput
    _min?: QuizQuestionGroupMediaMinOrderByAggregateInput
    _sum?: QuizQuestionGroupMediaSumOrderByAggregateInput
  }

  export type QuizQuestionGroupMediaScalarWhereWithAggregatesInput = {
    AND?: QuizQuestionGroupMediaScalarWhereWithAggregatesInput | QuizQuestionGroupMediaScalarWhereWithAggregatesInput[]
    OR?: QuizQuestionGroupMediaScalarWhereWithAggregatesInput[]
    NOT?: QuizQuestionGroupMediaScalarWhereWithAggregatesInput | QuizQuestionGroupMediaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuizQuestionGroupMedia"> | number
    groupId?: IntWithAggregatesFilter<"QuizQuestionGroupMedia"> | number
    mediaId?: IntWithAggregatesFilter<"QuizQuestionGroupMedia"> | number
    createdAt?: DateTimeWithAggregatesFilter<"QuizQuestionGroupMedia"> | Date | string
  }

  export type QuizQuestionMediaWhereInput = {
    AND?: QuizQuestionMediaWhereInput | QuizQuestionMediaWhereInput[]
    OR?: QuizQuestionMediaWhereInput[]
    NOT?: QuizQuestionMediaWhereInput | QuizQuestionMediaWhereInput[]
    id?: IntFilter<"QuizQuestionMedia"> | number
    questionId?: IntFilter<"QuizQuestionMedia"> | number
    mediaId?: IntFilter<"QuizQuestionMedia"> | number
    createdAt?: DateTimeFilter<"QuizQuestionMedia"> | Date | string
    question?: XOR<QuizQuestionScalarRelationFilter, QuizQuestionWhereInput>
    media?: XOR<MediaScalarRelationFilter, MediaWhereInput>
  }

  export type QuizQuestionMediaOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    mediaId?: SortOrder
    createdAt?: SortOrder
    question?: QuizQuestionOrderByWithRelationInput
    media?: MediaOrderByWithRelationInput
  }

  export type QuizQuestionMediaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    questionId_mediaId?: QuizQuestionMediaQuestionIdMediaIdCompoundUniqueInput
    AND?: QuizQuestionMediaWhereInput | QuizQuestionMediaWhereInput[]
    OR?: QuizQuestionMediaWhereInput[]
    NOT?: QuizQuestionMediaWhereInput | QuizQuestionMediaWhereInput[]
    questionId?: IntFilter<"QuizQuestionMedia"> | number
    mediaId?: IntFilter<"QuizQuestionMedia"> | number
    createdAt?: DateTimeFilter<"QuizQuestionMedia"> | Date | string
    question?: XOR<QuizQuestionScalarRelationFilter, QuizQuestionWhereInput>
    media?: XOR<MediaScalarRelationFilter, MediaWhereInput>
  }, "id" | "questionId_mediaId">

  export type QuizQuestionMediaOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    mediaId?: SortOrder
    createdAt?: SortOrder
    _count?: QuizQuestionMediaCountOrderByAggregateInput
    _avg?: QuizQuestionMediaAvgOrderByAggregateInput
    _max?: QuizQuestionMediaMaxOrderByAggregateInput
    _min?: QuizQuestionMediaMinOrderByAggregateInput
    _sum?: QuizQuestionMediaSumOrderByAggregateInput
  }

  export type QuizQuestionMediaScalarWhereWithAggregatesInput = {
    AND?: QuizQuestionMediaScalarWhereWithAggregatesInput | QuizQuestionMediaScalarWhereWithAggregatesInput[]
    OR?: QuizQuestionMediaScalarWhereWithAggregatesInput[]
    NOT?: QuizQuestionMediaScalarWhereWithAggregatesInput | QuizQuestionMediaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuizQuestionMedia"> | number
    questionId?: IntWithAggregatesFilter<"QuizQuestionMedia"> | number
    mediaId?: IntWithAggregatesFilter<"QuizQuestionMedia"> | number
    createdAt?: DateTimeWithAggregatesFilter<"QuizQuestionMedia"> | Date | string
  }

  export type QuizOptionMediaWhereInput = {
    AND?: QuizOptionMediaWhereInput | QuizOptionMediaWhereInput[]
    OR?: QuizOptionMediaWhereInput[]
    NOT?: QuizOptionMediaWhereInput | QuizOptionMediaWhereInput[]
    id?: IntFilter<"QuizOptionMedia"> | number
    optionId?: IntFilter<"QuizOptionMedia"> | number
    mediaId?: IntFilter<"QuizOptionMedia"> | number
    createdAt?: DateTimeFilter<"QuizOptionMedia"> | Date | string
    option?: XOR<QuizOptionScalarRelationFilter, QuizOptionWhereInput>
    media?: XOR<MediaScalarRelationFilter, MediaWhereInput>
  }

  export type QuizOptionMediaOrderByWithRelationInput = {
    id?: SortOrder
    optionId?: SortOrder
    mediaId?: SortOrder
    createdAt?: SortOrder
    option?: QuizOptionOrderByWithRelationInput
    media?: MediaOrderByWithRelationInput
  }

  export type QuizOptionMediaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    optionId_mediaId?: QuizOptionMediaOptionIdMediaIdCompoundUniqueInput
    AND?: QuizOptionMediaWhereInput | QuizOptionMediaWhereInput[]
    OR?: QuizOptionMediaWhereInput[]
    NOT?: QuizOptionMediaWhereInput | QuizOptionMediaWhereInput[]
    optionId?: IntFilter<"QuizOptionMedia"> | number
    mediaId?: IntFilter<"QuizOptionMedia"> | number
    createdAt?: DateTimeFilter<"QuizOptionMedia"> | Date | string
    option?: XOR<QuizOptionScalarRelationFilter, QuizOptionWhereInput>
    media?: XOR<MediaScalarRelationFilter, MediaWhereInput>
  }, "id" | "optionId_mediaId">

  export type QuizOptionMediaOrderByWithAggregationInput = {
    id?: SortOrder
    optionId?: SortOrder
    mediaId?: SortOrder
    createdAt?: SortOrder
    _count?: QuizOptionMediaCountOrderByAggregateInput
    _avg?: QuizOptionMediaAvgOrderByAggregateInput
    _max?: QuizOptionMediaMaxOrderByAggregateInput
    _min?: QuizOptionMediaMinOrderByAggregateInput
    _sum?: QuizOptionMediaSumOrderByAggregateInput
  }

  export type QuizOptionMediaScalarWhereWithAggregatesInput = {
    AND?: QuizOptionMediaScalarWhereWithAggregatesInput | QuizOptionMediaScalarWhereWithAggregatesInput[]
    OR?: QuizOptionMediaScalarWhereWithAggregatesInput[]
    NOT?: QuizOptionMediaScalarWhereWithAggregatesInput | QuizOptionMediaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuizOptionMedia"> | number
    optionId?: IntWithAggregatesFilter<"QuizOptionMedia"> | number
    mediaId?: IntWithAggregatesFilter<"QuizOptionMedia"> | number
    createdAt?: DateTimeWithAggregatesFilter<"QuizOptionMedia"> | Date | string
  }

  export type OtpRecordCreateInput = {
    id?: bigint | number
    email: string
    OtpCode: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type OtpRecordUncheckedCreateInput = {
    id?: bigint | number
    email: string
    OtpCode: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type OtpRecordUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    OtpCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpRecordUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    OtpCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpRecordCreateManyInput = {
    id?: bigint | number
    email: string
    OtpCode: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type OtpRecordUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    OtpCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpRecordUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    email?: StringFieldUpdateOperationsInput | string
    OtpCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: bigint | number
    tokenHash: string
    issuedAt?: Date | string
    expiresAt: Date | string
    revokedAt?: Date | string | null
    replacedByHash?: string | null
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: bigint | number
    userId: number
    tokenHash: string
    issuedAt?: Date | string
    expiresAt: Date | string
    revokedAt?: Date | string | null
    replacedByHash?: string | null
  }

  export type RefreshTokenUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tokenHash?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replacedByHash?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenHash?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replacedByHash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RefreshTokenCreateManyInput = {
    id?: bigint | number
    userId: number
    tokenHash: string
    issuedAt?: Date | string
    expiresAt: Date | string
    revokedAt?: Date | string | null
    replacedByHash?: string | null
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tokenHash?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replacedByHash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    userId?: IntFieldUpdateOperationsInput | number
    tokenHash?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replacedByHash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MediaCreateInput = {
    disk: string
    bucket?: string | null
    objectKey: string
    mimeType?: string | null
    sizeBytes?: bigint | number | null
    visibility?: string
    createdAt?: Date | string
    uploader?: UserCreateNestedOneWithoutUploadedMediaInput
    userAvatars?: UserCreateNestedManyWithoutAvatarMediaInput
    classroomCovers?: ClassroomCreateNestedManyWithoutCoverMediaInput
    materials?: MaterialCreateNestedManyWithoutMediaInput
    exerciseAttachments?: ExerciseCreateNestedManyWithoutAttachMediaInput
    exerciseSubmissions?: ExerciseSubmissionCreateNestedManyWithoutMediaInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaCreateNestedManyWithoutMediaInput
    quizQuestionMedias?: QuizQuestionMediaCreateNestedManyWithoutMediaInput
    quizOptionMedias?: QuizOptionMediaCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateInput = {
    id?: number
    disk: string
    bucket?: string | null
    objectKey: string
    mimeType?: string | null
    sizeBytes?: bigint | number | null
    visibility?: string
    uploadedBy?: number | null
    createdAt?: Date | string
    userAvatars?: UserUncheckedCreateNestedManyWithoutAvatarMediaInput
    classroomCovers?: ClassroomUncheckedCreateNestedManyWithoutCoverMediaInput
    materials?: MaterialUncheckedCreateNestedManyWithoutMediaInput
    exerciseAttachments?: ExerciseUncheckedCreateNestedManyWithoutAttachMediaInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutMediaInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaUncheckedCreateNestedManyWithoutMediaInput
    quizQuestionMedias?: QuizQuestionMediaUncheckedCreateNestedManyWithoutMediaInput
    quizOptionMedias?: QuizOptionMediaUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaUpdateInput = {
    disk?: StringFieldUpdateOperationsInput | string
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    objectKey?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneWithoutUploadedMediaNestedInput
    userAvatars?: UserUpdateManyWithoutAvatarMediaNestedInput
    classroomCovers?: ClassroomUpdateManyWithoutCoverMediaNestedInput
    materials?: MaterialUpdateManyWithoutMediaNestedInput
    exerciseAttachments?: ExerciseUpdateManyWithoutAttachMediaNestedInput
    exerciseSubmissions?: ExerciseSubmissionUpdateManyWithoutMediaNestedInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaUpdateManyWithoutMediaNestedInput
    quizQuestionMedias?: QuizQuestionMediaUpdateManyWithoutMediaNestedInput
    quizOptionMedias?: QuizOptionMediaUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    disk?: StringFieldUpdateOperationsInput | string
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    objectKey?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    visibility?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAvatars?: UserUncheckedUpdateManyWithoutAvatarMediaNestedInput
    classroomCovers?: ClassroomUncheckedUpdateManyWithoutCoverMediaNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutMediaNestedInput
    exerciseAttachments?: ExerciseUncheckedUpdateManyWithoutAttachMediaNestedInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedUpdateManyWithoutMediaNestedInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaUncheckedUpdateManyWithoutMediaNestedInput
    quizQuestionMedias?: QuizQuestionMediaUncheckedUpdateManyWithoutMediaNestedInput
    quizOptionMedias?: QuizOptionMediaUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type MediaCreateManyInput = {
    id?: number
    disk: string
    bucket?: string | null
    objectKey: string
    mimeType?: string | null
    sizeBytes?: bigint | number | null
    visibility?: string
    uploadedBy?: number | null
    createdAt?: Date | string
  }

  export type MediaUpdateManyMutationInput = {
    disk?: StringFieldUpdateOperationsInput | string
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    objectKey?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    disk?: StringFieldUpdateOperationsInput | string
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    objectKey?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    visibility?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarMedia?: MediaCreateNestedOneWithoutUserAvatarsInput
    uploadedMedia?: MediaCreateNestedManyWithoutUploaderInput
    taughtClassrooms?: ClassroomCreateNestedManyWithoutTutorInput
    createdClassrooms?: ClassroomCreateNestedManyWithoutCreatorInput
    classroomStudents?: ClassroomStudentCreateNestedManyWithoutStudentInput
    joinRequests?: JoinRequestCreateNestedManyWithoutStudentInput
    uploadedMaterials?: MaterialCreateNestedManyWithoutUploaderInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    exerciseSubmissions?: ExerciseSubmissionCreateNestedManyWithoutStudentInput
    createdQuizzes?: QuizCreateNestedManyWithoutCreatorInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutStudentInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    avatarMediaId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedMedia?: MediaUncheckedCreateNestedManyWithoutUploaderInput
    taughtClassrooms?: ClassroomUncheckedCreateNestedManyWithoutTutorInput
    createdClassrooms?: ClassroomUncheckedCreateNestedManyWithoutCreatorInput
    classroomStudents?: ClassroomStudentUncheckedCreateNestedManyWithoutStudentInput
    joinRequests?: JoinRequestUncheckedCreateNestedManyWithoutStudentInput
    uploadedMaterials?: MaterialUncheckedCreateNestedManyWithoutUploaderInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutStudentInput
    createdQuizzes?: QuizUncheckedCreateNestedManyWithoutCreatorInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutStudentInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarMedia?: MediaUpdateOneWithoutUserAvatarsNestedInput
    uploadedMedia?: MediaUpdateManyWithoutUploaderNestedInput
    taughtClassrooms?: ClassroomUpdateManyWithoutTutorNestedInput
    createdClassrooms?: ClassroomUpdateManyWithoutCreatorNestedInput
    classroomStudents?: ClassroomStudentUpdateManyWithoutStudentNestedInput
    joinRequests?: JoinRequestUpdateManyWithoutStudentNestedInput
    uploadedMaterials?: MaterialUpdateManyWithoutUploaderNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    exerciseSubmissions?: ExerciseSubmissionUpdateManyWithoutStudentNestedInput
    createdQuizzes?: QuizUpdateManyWithoutCreatorNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutStudentNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatarMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedMedia?: MediaUncheckedUpdateManyWithoutUploaderNestedInput
    taughtClassrooms?: ClassroomUncheckedUpdateManyWithoutTutorNestedInput
    createdClassrooms?: ClassroomUncheckedUpdateManyWithoutCreatorNestedInput
    classroomStudents?: ClassroomStudentUncheckedUpdateManyWithoutStudentNestedInput
    joinRequests?: JoinRequestUncheckedUpdateManyWithoutStudentNestedInput
    uploadedMaterials?: MaterialUncheckedUpdateManyWithoutUploaderNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    createdQuizzes?: QuizUncheckedUpdateManyWithoutCreatorNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutStudentNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    avatarMediaId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatarMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomCreateInput = {
    name: string
    description?: string | null
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tutor: UserCreateNestedOneWithoutTaughtClassroomsInput
    creator: UserCreateNestedOneWithoutCreatedClassroomsInput
    coverMedia?: MediaCreateNestedOneWithoutClassroomCoversInput
    classroomStudents?: ClassroomStudentCreateNestedManyWithoutClassroomInput
    joinRequests?: JoinRequestCreateNestedManyWithoutClassroomInput
    lessons?: LessonCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    tutorId: number
    coverMediaId?: number | null
    isArchived?: boolean
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    classroomStudents?: ClassroomStudentUncheckedCreateNestedManyWithoutClassroomInput
    joinRequests?: JoinRequestUncheckedCreateNestedManyWithoutClassroomInput
    lessons?: LessonUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tutor?: UserUpdateOneRequiredWithoutTaughtClassroomsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedClassroomsNestedInput
    coverMedia?: MediaUpdateOneWithoutClassroomCoversNestedInput
    classroomStudents?: ClassroomStudentUpdateManyWithoutClassroomNestedInput
    joinRequests?: JoinRequestUpdateManyWithoutClassroomNestedInput
    lessons?: LessonUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tutorId?: IntFieldUpdateOperationsInput | number
    coverMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classroomStudents?: ClassroomStudentUncheckedUpdateManyWithoutClassroomNestedInput
    joinRequests?: JoinRequestUncheckedUpdateManyWithoutClassroomNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    tutorId: number
    coverMediaId?: number | null
    isArchived?: boolean
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassroomUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tutorId?: IntFieldUpdateOperationsInput | number
    coverMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomStudentCreateInput = {
    joinedAt?: Date | string
    status?: number
    classroom: ClassroomCreateNestedOneWithoutClassroomStudentsInput
    student: UserCreateNestedOneWithoutClassroomStudentsInput
  }

  export type ClassroomStudentUncheckedCreateInput = {
    classroomId: number
    studentId: number
    joinedAt?: Date | string
    status?: number
  }

  export type ClassroomStudentUpdateInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    classroom?: ClassroomUpdateOneRequiredWithoutClassroomStudentsNestedInput
    student?: UserUpdateOneRequiredWithoutClassroomStudentsNestedInput
  }

  export type ClassroomStudentUncheckedUpdateInput = {
    classroomId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type ClassroomStudentCreateManyInput = {
    classroomId: number
    studentId: number
    joinedAt?: Date | string
    status?: number
  }

  export type ClassroomStudentUpdateManyMutationInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type ClassroomStudentUncheckedUpdateManyInput = {
    classroomId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type JoinRequestCreateInput = {
    status?: string
    requestedAt?: Date | string
    handledAt?: Date | string | null
    classroom: ClassroomCreateNestedOneWithoutJoinRequestsInput
    student: UserCreateNestedOneWithoutJoinRequestsInput
  }

  export type JoinRequestUncheckedCreateInput = {
    id?: number
    classroomId: number
    studentId: number
    status?: string
    requestedAt?: Date | string
    handledAt?: Date | string | null
  }

  export type JoinRequestUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classroom?: ClassroomUpdateOneRequiredWithoutJoinRequestsNestedInput
    student?: UserUpdateOneRequiredWithoutJoinRequestsNestedInput
  }

  export type JoinRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JoinRequestCreateManyInput = {
    id?: number
    classroomId: number
    studentId: number
    status?: string
    requestedAt?: Date | string
    handledAt?: Date | string | null
  }

  export type JoinRequestUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JoinRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LessonCreateInput = {
    title: string
    content?: string | null
    lessonType?: $Enums.LessonType
    orderIndex?: number
    publishedAt?: Date | string | null
    classroom: ClassroomCreateNestedOneWithoutLessonsInput
    materials?: MaterialCreateNestedManyWithoutLessonInput
    exercises?: ExerciseCreateNestedManyWithoutLessonInput
    quizzes?: QuizCreateNestedManyWithoutLessonInput
    parent?: LessonCreateNestedOneWithoutSubLessonsInput
    subLessons?: LessonCreateNestedManyWithoutParentInput
  }

  export type LessonUncheckedCreateInput = {
    id?: number
    classroomId: number
    parentId?: number | null
    title: string
    content?: string | null
    lessonType?: $Enums.LessonType
    orderIndex?: number
    publishedAt?: Date | string | null
    materials?: MaterialUncheckedCreateNestedManyWithoutLessonInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutLessonInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutLessonInput
    subLessons?: LessonUncheckedCreateNestedManyWithoutParentInput
  }

  export type LessonUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    lessonType?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    orderIndex?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classroom?: ClassroomUpdateOneRequiredWithoutLessonsNestedInput
    materials?: MaterialUpdateManyWithoutLessonNestedInput
    exercises?: ExerciseUpdateManyWithoutLessonNestedInput
    quizzes?: QuizUpdateManyWithoutLessonNestedInput
    parent?: LessonUpdateOneWithoutSubLessonsNestedInput
    subLessons?: LessonUpdateManyWithoutParentNestedInput
  }

  export type LessonUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    lessonType?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    orderIndex?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    materials?: MaterialUncheckedUpdateManyWithoutLessonNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutLessonNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutLessonNestedInput
    subLessons?: LessonUncheckedUpdateManyWithoutParentNestedInput
  }

  export type LessonCreateManyInput = {
    id?: number
    classroomId: number
    parentId?: number | null
    title: string
    content?: string | null
    lessonType?: $Enums.LessonType
    orderIndex?: number
    publishedAt?: Date | string | null
  }

  export type LessonUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    lessonType?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    orderIndex?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LessonUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    lessonType?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    orderIndex?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MaterialCreateInput = {
    title: string
    uploadedAt?: Date | string
    lesson?: LessonCreateNestedOneWithoutMaterialsInput
    media: MediaCreateNestedOneWithoutMaterialsInput
    uploader: UserCreateNestedOneWithoutUploadedMaterialsInput
  }

  export type MaterialUncheckedCreateInput = {
    id?: number
    lessonId: number
    title: string
    mediaId: number
    uploadedBy: number
    uploadedAt?: Date | string
  }

  export type MaterialUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneWithoutMaterialsNestedInput
    media?: MediaUpdateOneRequiredWithoutMaterialsNestedInput
    uploader?: UserUpdateOneRequiredWithoutUploadedMaterialsNestedInput
  }

  export type MaterialUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    mediaId?: IntFieldUpdateOperationsInput | number
    uploadedBy?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialCreateManyInput = {
    id?: number
    lessonId: number
    title: string
    mediaId: number
    uploadedBy: number
    uploadedAt?: Date | string
  }

  export type MaterialUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    mediaId?: IntFieldUpdateOperationsInput | number
    uploadedBy?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseCreateInput = {
    title: string
    description?: string | null
    dueAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lesson?: LessonCreateNestedOneWithoutExercisesInput
    attachMedia?: MediaCreateNestedOneWithoutExerciseAttachmentsInput
    creator: UserCreateNestedOneWithoutCreatedExercisesInput
    submissions?: ExerciseSubmissionCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateInput = {
    id?: number
    lessonId: number
    title: string
    description?: string | null
    attachMediaId?: number | null
    dueAt?: Date | string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    submissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson?: LessonUpdateOneWithoutExercisesNestedInput
    attachMedia?: MediaUpdateOneWithoutExerciseAttachmentsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedExercisesNestedInput
    submissions?: ExerciseSubmissionUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissions?: ExerciseSubmissionUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseCreateManyInput = {
    id?: number
    lessonId: number
    title: string
    description?: string | null
    attachMediaId?: number | null
    dueAt?: Date | string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ExerciseUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExerciseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExerciseSubmissionCreateInput = {
    submittedAt?: Date | string
    score?: Decimal | DecimalJsLike | number | string | null
    comment?: string | null
    gradedAt?: Date | string | null
    exercise: ExerciseCreateNestedOneWithoutSubmissionsInput
    student: UserCreateNestedOneWithoutExerciseSubmissionsInput
    media: MediaCreateNestedOneWithoutExerciseSubmissionsInput
  }

  export type ExerciseSubmissionUncheckedCreateInput = {
    id?: number
    exerciseId: number
    studentId: number
    mediaId: number
    submittedAt?: Date | string
    score?: Decimal | DecimalJsLike | number | string | null
    comment?: string | null
    gradedAt?: Date | string | null
  }

  export type ExerciseSubmissionUpdateInput = {
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exercise?: ExerciseUpdateOneRequiredWithoutSubmissionsNestedInput
    student?: UserUpdateOneRequiredWithoutExerciseSubmissionsNestedInput
    media?: MediaUpdateOneRequiredWithoutExerciseSubmissionsNestedInput
  }

  export type ExerciseSubmissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    exerciseId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    mediaId?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExerciseSubmissionCreateManyInput = {
    id?: number
    exerciseId: number
    studentId: number
    mediaId: number
    submittedAt?: Date | string
    score?: Decimal | DecimalJsLike | number | string | null
    comment?: string | null
    gradedAt?: Date | string | null
  }

  export type ExerciseSubmissionUpdateManyMutationInput = {
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExerciseSubmissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    exerciseId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    mediaId?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizCreateInput = {
    title: string
    description?: string | null
    timeLimitSec?: number | null
    maxAttempts?: number
    shuffleQuestions?: boolean
    shuffleOptions?: boolean
    gradingMethod?: string
    showAnswersAfter?: string
    dueAt?: Date | string | null
    isPublished?: boolean
    totalPoints?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lesson: LessonCreateNestedOneWithoutQuizzesInput
    creator: UserCreateNestedOneWithoutCreatedQuizzesInput
    sections?: QuizSectionCreateNestedManyWithoutQuizInput
    questionGroups?: QuizQuestionGroupCreateNestedManyWithoutQuizInput
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
    attempts?: QuizAttemptCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateInput = {
    id?: number
    lessonId: number
    title: string
    description?: string | null
    timeLimitSec?: number | null
    maxAttempts?: number
    shuffleQuestions?: boolean
    shuffleOptions?: boolean
    gradingMethod?: string
    showAnswersAfter?: string
    dueAt?: Date | string | null
    isPublished?: boolean
    totalPoints?: Decimal | DecimalJsLike | number | string
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sections?: QuizSectionUncheckedCreateNestedManyWithoutQuizInput
    questionGroups?: QuizQuestionGroupUncheckedCreateNestedManyWithoutQuizInput
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    maxAttempts?: IntFieldUpdateOperationsInput | number
    shuffleQuestions?: BoolFieldUpdateOperationsInput | boolean
    shuffleOptions?: BoolFieldUpdateOperationsInput | boolean
    gradingMethod?: StringFieldUpdateOperationsInput | string
    showAnswersAfter?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson?: LessonUpdateOneRequiredWithoutQuizzesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedQuizzesNestedInput
    sections?: QuizSectionUpdateManyWithoutQuizNestedInput
    questionGroups?: QuizQuestionGroupUpdateManyWithoutQuizNestedInput
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
    attempts?: QuizAttemptUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    maxAttempts?: IntFieldUpdateOperationsInput | number
    shuffleQuestions?: BoolFieldUpdateOperationsInput | boolean
    shuffleOptions?: BoolFieldUpdateOperationsInput | boolean
    gradingMethod?: StringFieldUpdateOperationsInput | string
    showAnswersAfter?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sections?: QuizSectionUncheckedUpdateManyWithoutQuizNestedInput
    questionGroups?: QuizQuestionGroupUncheckedUpdateManyWithoutQuizNestedInput
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
    attempts?: QuizAttemptUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizCreateManyInput = {
    id?: number
    lessonId: number
    title: string
    description?: string | null
    timeLimitSec?: number | null
    maxAttempts?: number
    shuffleQuestions?: boolean
    shuffleOptions?: boolean
    gradingMethod?: string
    showAnswersAfter?: string
    dueAt?: Date | string | null
    isPublished?: boolean
    totalPoints?: Decimal | DecimalJsLike | number | string
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type QuizUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    maxAttempts?: IntFieldUpdateOperationsInput | number
    shuffleQuestions?: BoolFieldUpdateOperationsInput | boolean
    shuffleOptions?: BoolFieldUpdateOperationsInput | boolean
    gradingMethod?: StringFieldUpdateOperationsInput | string
    showAnswersAfter?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    maxAttempts?: IntFieldUpdateOperationsInput | number
    shuffleQuestions?: BoolFieldUpdateOperationsInput | boolean
    shuffleOptions?: BoolFieldUpdateOperationsInput | boolean
    gradingMethod?: StringFieldUpdateOperationsInput | string
    showAnswersAfter?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizSectionCreateInput = {
    title: string
    description?: string | null
    orderIndex?: number
    quiz: QuizCreateNestedOneWithoutSectionsInput
    questionGroups?: QuizQuestionGroupCreateNestedManyWithoutSectionInput
    questions?: QuizQuestionCreateNestedManyWithoutSectionInput
  }

  export type QuizSectionUncheckedCreateInput = {
    id?: number
    quizId: number
    title: string
    description?: string | null
    orderIndex?: number
    questionGroups?: QuizQuestionGroupUncheckedCreateNestedManyWithoutSectionInput
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutSectionInput
  }

  export type QuizSectionUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    quiz?: QuizUpdateOneRequiredWithoutSectionsNestedInput
    questionGroups?: QuizQuestionGroupUpdateManyWithoutSectionNestedInput
    questions?: QuizQuestionUpdateManyWithoutSectionNestedInput
  }

  export type QuizSectionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    questionGroups?: QuizQuestionGroupUncheckedUpdateManyWithoutSectionNestedInput
    questions?: QuizQuestionUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type QuizSectionCreateManyInput = {
    id?: number
    quizId: number
    title: string
    description?: string | null
    orderIndex?: number
  }

  export type QuizSectionUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type QuizSectionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type QuizQuestionGroupCreateInput = {
    title?: string | null
    introText?: string | null
    orderIndex?: number
    shuffleInside?: boolean
    pointsPolicy?: string
    createdAt?: Date | string
    quiz: QuizCreateNestedOneWithoutQuestionGroupsInput
    section?: QuizSectionCreateNestedOneWithoutQuestionGroupsInput
    questions?: QuizQuestionCreateNestedManyWithoutGroupInput
    medias?: QuizQuestionGroupMediaCreateNestedManyWithoutGroupInput
  }

  export type QuizQuestionGroupUncheckedCreateInput = {
    id?: number
    quizId: number
    sectionId?: number | null
    title?: string | null
    introText?: string | null
    orderIndex?: number
    shuffleInside?: boolean
    pointsPolicy?: string
    createdAt?: Date | string
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutGroupInput
    medias?: QuizQuestionGroupMediaUncheckedCreateNestedManyWithoutGroupInput
  }

  export type QuizQuestionGroupUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    introText?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    shuffleInside?: BoolFieldUpdateOperationsInput | boolean
    pointsPolicy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quiz?: QuizUpdateOneRequiredWithoutQuestionGroupsNestedInput
    section?: QuizSectionUpdateOneWithoutQuestionGroupsNestedInput
    questions?: QuizQuestionUpdateManyWithoutGroupNestedInput
    medias?: QuizQuestionGroupMediaUpdateManyWithoutGroupNestedInput
  }

  export type QuizQuestionGroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    sectionId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    introText?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    shuffleInside?: BoolFieldUpdateOperationsInput | boolean
    pointsPolicy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuizQuestionUncheckedUpdateManyWithoutGroupNestedInput
    medias?: QuizQuestionGroupMediaUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type QuizQuestionGroupCreateManyInput = {
    id?: number
    quizId: number
    sectionId?: number | null
    title?: string | null
    introText?: string | null
    orderIndex?: number
    shuffleInside?: boolean
    pointsPolicy?: string
    createdAt?: Date | string
  }

  export type QuizQuestionGroupUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    introText?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    shuffleInside?: BoolFieldUpdateOperationsInput | boolean
    pointsPolicy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionGroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    sectionId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    introText?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    shuffleInside?: BoolFieldUpdateOperationsInput | boolean
    pointsPolicy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionCreateInput = {
    content: string
    explanation?: string | null
    questionType?: string
    points?: Decimal | DecimalJsLike | number | string
    orderIndex?: number
    quiz: QuizCreateNestedOneWithoutQuestionsInput
    section?: QuizSectionCreateNestedOneWithoutQuestionsInput
    group?: QuizQuestionGroupCreateNestedOneWithoutQuestionsInput
    options?: QuizOptionCreateNestedManyWithoutQuestionInput
    answers?: QuizAnswerCreateNestedManyWithoutQuestionInput
    medias?: QuizQuestionMediaCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionUncheckedCreateInput = {
    id?: number
    quizId: number
    sectionId?: number | null
    groupId?: number | null
    content: string
    explanation?: string | null
    questionType?: string
    points?: Decimal | DecimalJsLike | number | string
    orderIndex?: number
    options?: QuizOptionUncheckedCreateNestedManyWithoutQuestionInput
    answers?: QuizAnswerUncheckedCreateNestedManyWithoutQuestionInput
    medias?: QuizQuestionMediaUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: StringFieldUpdateOperationsInput | string
    points?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    quiz?: QuizUpdateOneRequiredWithoutQuestionsNestedInput
    section?: QuizSectionUpdateOneWithoutQuestionsNestedInput
    group?: QuizQuestionGroupUpdateOneWithoutQuestionsNestedInput
    options?: QuizOptionUpdateManyWithoutQuestionNestedInput
    answers?: QuizAnswerUpdateManyWithoutQuestionNestedInput
    medias?: QuizQuestionMediaUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    sectionId?: NullableIntFieldUpdateOperationsInput | number | null
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: StringFieldUpdateOperationsInput | string
    points?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    options?: QuizOptionUncheckedUpdateManyWithoutQuestionNestedInput
    answers?: QuizAnswerUncheckedUpdateManyWithoutQuestionNestedInput
    medias?: QuizQuestionMediaUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionCreateManyInput = {
    id?: number
    quizId: number
    sectionId?: number | null
    groupId?: number | null
    content: string
    explanation?: string | null
    questionType?: string
    points?: Decimal | DecimalJsLike | number | string
    orderIndex?: number
  }

  export type QuizQuestionUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: StringFieldUpdateOperationsInput | string
    points?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type QuizQuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    sectionId?: NullableIntFieldUpdateOperationsInput | number | null
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: StringFieldUpdateOperationsInput | string
    points?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type QuizOptionCreateInput = {
    content: string
    isCorrect?: boolean
    orderIndex?: number
    question: QuizQuestionCreateNestedOneWithoutOptionsInput
    answers?: QuizAnswerCreateNestedManyWithoutOptionInput
    medias?: QuizOptionMediaCreateNestedManyWithoutOptionInput
  }

  export type QuizOptionUncheckedCreateInput = {
    id?: number
    questionId: number
    content: string
    isCorrect?: boolean
    orderIndex?: number
    answers?: QuizAnswerUncheckedCreateNestedManyWithoutOptionInput
    medias?: QuizOptionMediaUncheckedCreateNestedManyWithoutOptionInput
  }

  export type QuizOptionUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
    question?: QuizQuestionUpdateOneRequiredWithoutOptionsNestedInput
    answers?: QuizAnswerUpdateManyWithoutOptionNestedInput
    medias?: QuizOptionMediaUpdateManyWithoutOptionNestedInput
  }

  export type QuizOptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
    answers?: QuizAnswerUncheckedUpdateManyWithoutOptionNestedInput
    medias?: QuizOptionMediaUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type QuizOptionCreateManyInput = {
    id?: number
    questionId: number
    content: string
    isCorrect?: boolean
    orderIndex?: number
  }

  export type QuizOptionUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type QuizOptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type QuizAttemptCreateInput = {
    startedAt?: Date | string
    submittedAt?: Date | string | null
    status?: string
    scoreRaw?: Decimal | DecimalJsLike | number | string | null
    scoreScaled10?: Decimal | DecimalJsLike | number | string | null
    quiz: QuizCreateNestedOneWithoutAttemptsInput
    student: UserCreateNestedOneWithoutQuizAttemptsInput
    answers?: QuizAnswerCreateNestedManyWithoutAttemptInput
  }

  export type QuizAttemptUncheckedCreateInput = {
    id?: number
    quizId: number
    studentId: number
    startedAt?: Date | string
    submittedAt?: Date | string | null
    status?: string
    scoreRaw?: Decimal | DecimalJsLike | number | string | null
    scoreScaled10?: Decimal | DecimalJsLike | number | string | null
    answers?: QuizAnswerUncheckedCreateNestedManyWithoutAttemptInput
  }

  export type QuizAttemptUpdateInput = {
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    scoreRaw?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    scoreScaled10?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quiz?: QuizUpdateOneRequiredWithoutAttemptsNestedInput
    student?: UserUpdateOneRequiredWithoutQuizAttemptsNestedInput
    answers?: QuizAnswerUpdateManyWithoutAttemptNestedInput
  }

  export type QuizAttemptUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    scoreRaw?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    scoreScaled10?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    answers?: QuizAnswerUncheckedUpdateManyWithoutAttemptNestedInput
  }

  export type QuizAttemptCreateManyInput = {
    id?: number
    quizId: number
    studentId: number
    startedAt?: Date | string
    submittedAt?: Date | string | null
    status?: string
    scoreRaw?: Decimal | DecimalJsLike | number | string | null
    scoreScaled10?: Decimal | DecimalJsLike | number | string | null
  }

  export type QuizAttemptUpdateManyMutationInput = {
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    scoreRaw?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    scoreScaled10?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type QuizAttemptUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    scoreRaw?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    scoreScaled10?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type QuizAnswerCreateInput = {
    attempt: QuizAttemptCreateNestedOneWithoutAnswersInput
    question: QuizQuestionCreateNestedOneWithoutAnswersInput
    option: QuizOptionCreateNestedOneWithoutAnswersInput
  }

  export type QuizAnswerUncheckedCreateInput = {
    attemptId: number
    questionId: number
    optionId: number
  }

  export type QuizAnswerUpdateInput = {
    attempt?: QuizAttemptUpdateOneRequiredWithoutAnswersNestedInput
    question?: QuizQuestionUpdateOneRequiredWithoutAnswersNestedInput
    option?: QuizOptionUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type QuizAnswerUncheckedUpdateInput = {
    attemptId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    optionId?: IntFieldUpdateOperationsInput | number
  }

  export type QuizAnswerCreateManyInput = {
    attemptId: number
    questionId: number
    optionId: number
  }

  export type QuizAnswerUpdateManyMutationInput = {

  }

  export type QuizAnswerUncheckedUpdateManyInput = {
    attemptId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    optionId?: IntFieldUpdateOperationsInput | number
  }

  export type QuizQuestionGroupMediaCreateInput = {
    createdAt?: Date | string
    group: QuizQuestionGroupCreateNestedOneWithoutMediasInput
    media: MediaCreateNestedOneWithoutQuizQuestionGroupMediasInput
  }

  export type QuizQuestionGroupMediaUncheckedCreateInput = {
    id?: number
    groupId: number
    mediaId: number
    createdAt?: Date | string
  }

  export type QuizQuestionGroupMediaUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: QuizQuestionGroupUpdateOneRequiredWithoutMediasNestedInput
    media?: MediaUpdateOneRequiredWithoutQuizQuestionGroupMediasNestedInput
  }

  export type QuizQuestionGroupMediaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    mediaId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionGroupMediaCreateManyInput = {
    id?: number
    groupId: number
    mediaId: number
    createdAt?: Date | string
  }

  export type QuizQuestionGroupMediaUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionGroupMediaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    mediaId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionMediaCreateInput = {
    createdAt?: Date | string
    question: QuizQuestionCreateNestedOneWithoutMediasInput
    media: MediaCreateNestedOneWithoutQuizQuestionMediasInput
  }

  export type QuizQuestionMediaUncheckedCreateInput = {
    id?: number
    questionId: number
    mediaId: number
    createdAt?: Date | string
  }

  export type QuizQuestionMediaUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuizQuestionUpdateOneRequiredWithoutMediasNestedInput
    media?: MediaUpdateOneRequiredWithoutQuizQuestionMediasNestedInput
  }

  export type QuizQuestionMediaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    mediaId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionMediaCreateManyInput = {
    id?: number
    questionId: number
    mediaId: number
    createdAt?: Date | string
  }

  export type QuizQuestionMediaUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionMediaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    mediaId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizOptionMediaCreateInput = {
    createdAt?: Date | string
    option: QuizOptionCreateNestedOneWithoutMediasInput
    media: MediaCreateNestedOneWithoutQuizOptionMediasInput
  }

  export type QuizOptionMediaUncheckedCreateInput = {
    id?: number
    optionId: number
    mediaId: number
    createdAt?: Date | string
  }

  export type QuizOptionMediaUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    option?: QuizOptionUpdateOneRequiredWithoutMediasNestedInput
    media?: MediaUpdateOneRequiredWithoutQuizOptionMediasNestedInput
  }

  export type QuizOptionMediaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    optionId?: IntFieldUpdateOperationsInput | number
    mediaId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizOptionMediaCreateManyInput = {
    id?: number
    optionId: number
    mediaId: number
    createdAt?: Date | string
  }

  export type QuizOptionMediaUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizOptionMediaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    optionId?: IntFieldUpdateOperationsInput | number
    mediaId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type OtpRecordCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    OtpCode?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type OtpRecordAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OtpRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    OtpCode?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type OtpRecordMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    OtpCode?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type OtpRecordSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrder
    replacedByHash?: SortOrder
  }

  export type RefreshTokenAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrder
    replacedByHash?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrder
    replacedByHash?: SortOrder
  }

  export type RefreshTokenSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ClassroomListRelationFilter = {
    every?: ClassroomWhereInput
    some?: ClassroomWhereInput
    none?: ClassroomWhereInput
  }

  export type MaterialListRelationFilter = {
    every?: MaterialWhereInput
    some?: MaterialWhereInput
    none?: MaterialWhereInput
  }

  export type ExerciseListRelationFilter = {
    every?: ExerciseWhereInput
    some?: ExerciseWhereInput
    none?: ExerciseWhereInput
  }

  export type ExerciseSubmissionListRelationFilter = {
    every?: ExerciseSubmissionWhereInput
    some?: ExerciseSubmissionWhereInput
    none?: ExerciseSubmissionWhereInput
  }

  export type QuizQuestionGroupMediaListRelationFilter = {
    every?: QuizQuestionGroupMediaWhereInput
    some?: QuizQuestionGroupMediaWhereInput
    none?: QuizQuestionGroupMediaWhereInput
  }

  export type QuizQuestionMediaListRelationFilter = {
    every?: QuizQuestionMediaWhereInput
    some?: QuizQuestionMediaWhereInput
    none?: QuizQuestionMediaWhereInput
  }

  export type QuizOptionMediaListRelationFilter = {
    every?: QuizOptionMediaWhereInput
    some?: QuizOptionMediaWhereInput
    none?: QuizOptionMediaWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassroomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExerciseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExerciseSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizQuestionGroupMediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizQuestionMediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizOptionMediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaBucketObjectKeyCompoundUniqueInput = {
    bucket: string
    objectKey: string
  }

  export type MediaCountOrderByAggregateInput = {
    id?: SortOrder
    disk?: SortOrder
    bucket?: SortOrder
    objectKey?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    visibility?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaAvgOrderByAggregateInput = {
    id?: SortOrder
    sizeBytes?: SortOrder
    uploadedBy?: SortOrder
  }

  export type MediaMaxOrderByAggregateInput = {
    id?: SortOrder
    disk?: SortOrder
    bucket?: SortOrder
    objectKey?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    visibility?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaMinOrderByAggregateInput = {
    id?: SortOrder
    disk?: SortOrder
    bucket?: SortOrder
    objectKey?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    visibility?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaSumOrderByAggregateInput = {
    id?: SortOrder
    sizeBytes?: SortOrder
    uploadedBy?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type MediaNullableScalarRelationFilter = {
    is?: MediaWhereInput | null
    isNot?: MediaWhereInput | null
  }

  export type MediaListRelationFilter = {
    every?: MediaWhereInput
    some?: MediaWhereInput
    none?: MediaWhereInput
  }

  export type ClassroomStudentListRelationFilter = {
    every?: ClassroomStudentWhereInput
    some?: ClassroomStudentWhereInput
    none?: ClassroomStudentWhereInput
  }

  export type JoinRequestListRelationFilter = {
    every?: JoinRequestWhereInput
    some?: JoinRequestWhereInput
    none?: JoinRequestWhereInput
  }

  export type QuizListRelationFilter = {
    every?: QuizWhereInput
    some?: QuizWhereInput
    none?: QuizWhereInput
  }

  export type QuizAttemptListRelationFilter = {
    every?: QuizAttemptWhereInput
    some?: QuizAttemptWhereInput
    none?: QuizAttemptWhereInput
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type MediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassroomStudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JoinRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    avatarMediaId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    avatarMediaId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    avatarMediaId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    avatarMediaId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    avatarMediaId?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type LessonListRelationFilter = {
    every?: LessonWhereInput
    some?: LessonWhereInput
    none?: LessonWhereInput
  }

  export type LessonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassroomCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tutorId?: SortOrder
    coverMediaId?: SortOrder
    isArchived?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassroomAvgOrderByAggregateInput = {
    id?: SortOrder
    tutorId?: SortOrder
    coverMediaId?: SortOrder
    createdBy?: SortOrder
  }

  export type ClassroomMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tutorId?: SortOrder
    coverMediaId?: SortOrder
    isArchived?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassroomMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tutorId?: SortOrder
    coverMediaId?: SortOrder
    isArchived?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassroomSumOrderByAggregateInput = {
    id?: SortOrder
    tutorId?: SortOrder
    coverMediaId?: SortOrder
    createdBy?: SortOrder
  }

  export type ClassroomScalarRelationFilter = {
    is?: ClassroomWhereInput
    isNot?: ClassroomWhereInput
  }

  export type ClassroomStudentClassroomIdStudentIdCompoundUniqueInput = {
    classroomId: number
    studentId: number
  }

  export type ClassroomStudentCountOrderByAggregateInput = {
    classroomId?: SortOrder
    studentId?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
  }

  export type ClassroomStudentAvgOrderByAggregateInput = {
    classroomId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
  }

  export type ClassroomStudentMaxOrderByAggregateInput = {
    classroomId?: SortOrder
    studentId?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
  }

  export type ClassroomStudentMinOrderByAggregateInput = {
    classroomId?: SortOrder
    studentId?: SortOrder
    joinedAt?: SortOrder
    status?: SortOrder
  }

  export type ClassroomStudentSumOrderByAggregateInput = {
    classroomId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
  }

  export type JoinRequestCountOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    handledAt?: SortOrder
  }

  export type JoinRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    studentId?: SortOrder
  }

  export type JoinRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    handledAt?: SortOrder
  }

  export type JoinRequestMinOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    requestedAt?: SortOrder
    handledAt?: SortOrder
  }

  export type JoinRequestSumOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    studentId?: SortOrder
  }

  export type EnumLessonTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonType | EnumLessonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonTypeFilter<$PrismaModel> | $Enums.LessonType
  }

  export type LessonNullableScalarRelationFilter = {
    is?: LessonWhereInput | null
    isNot?: LessonWhereInput | null
  }

  export type LessonCountOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    parentId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    lessonType?: SortOrder
    orderIndex?: SortOrder
    publishedAt?: SortOrder
  }

  export type LessonAvgOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    parentId?: SortOrder
    orderIndex?: SortOrder
  }

  export type LessonMaxOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    parentId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    lessonType?: SortOrder
    orderIndex?: SortOrder
    publishedAt?: SortOrder
  }

  export type LessonMinOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    parentId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    lessonType?: SortOrder
    orderIndex?: SortOrder
    publishedAt?: SortOrder
  }

  export type LessonSumOrderByAggregateInput = {
    id?: SortOrder
    classroomId?: SortOrder
    parentId?: SortOrder
    orderIndex?: SortOrder
  }

  export type EnumLessonTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonType | EnumLessonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonTypeWithAggregatesFilter<$PrismaModel> | $Enums.LessonType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLessonTypeFilter<$PrismaModel>
    _max?: NestedEnumLessonTypeFilter<$PrismaModel>
  }

  export type MediaScalarRelationFilter = {
    is?: MediaWhereInput
    isNot?: MediaWhereInput
  }

  export type MaterialCountOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    title?: SortOrder
    mediaId?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
  }

  export type MaterialAvgOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    mediaId?: SortOrder
    uploadedBy?: SortOrder
  }

  export type MaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    title?: SortOrder
    mediaId?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
  }

  export type MaterialMinOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    title?: SortOrder
    mediaId?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
  }

  export type MaterialSumOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    mediaId?: SortOrder
    uploadedBy?: SortOrder
  }

  export type ExerciseCountOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    attachMediaId?: SortOrder
    dueAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ExerciseAvgOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    attachMediaId?: SortOrder
    createdBy?: SortOrder
  }

  export type ExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    attachMediaId?: SortOrder
    dueAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ExerciseMinOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    attachMediaId?: SortOrder
    dueAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ExerciseSumOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    attachMediaId?: SortOrder
    createdBy?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ExerciseScalarRelationFilter = {
    is?: ExerciseWhereInput
    isNot?: ExerciseWhereInput
  }

  export type ExerciseSubmissionExerciseIdStudentIdCompoundUniqueInput = {
    exerciseId: number
    studentId: number
  }

  export type ExerciseSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    studentId?: SortOrder
    mediaId?: SortOrder
    submittedAt?: SortOrder
    score?: SortOrder
    comment?: SortOrder
    gradedAt?: SortOrder
  }

  export type ExerciseSubmissionAvgOrderByAggregateInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    studentId?: SortOrder
    mediaId?: SortOrder
    score?: SortOrder
  }

  export type ExerciseSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    studentId?: SortOrder
    mediaId?: SortOrder
    submittedAt?: SortOrder
    score?: SortOrder
    comment?: SortOrder
    gradedAt?: SortOrder
  }

  export type ExerciseSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    studentId?: SortOrder
    mediaId?: SortOrder
    submittedAt?: SortOrder
    score?: SortOrder
    comment?: SortOrder
    gradedAt?: SortOrder
  }

  export type ExerciseSubmissionSumOrderByAggregateInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    studentId?: SortOrder
    mediaId?: SortOrder
    score?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type LessonScalarRelationFilter = {
    is?: LessonWhereInput
    isNot?: LessonWhereInput
  }

  export type QuizSectionListRelationFilter = {
    every?: QuizSectionWhereInput
    some?: QuizSectionWhereInput
    none?: QuizSectionWhereInput
  }

  export type QuizQuestionGroupListRelationFilter = {
    every?: QuizQuestionGroupWhereInput
    some?: QuizQuestionGroupWhereInput
    none?: QuizQuestionGroupWhereInput
  }

  export type QuizQuestionListRelationFilter = {
    every?: QuizQuestionWhereInput
    some?: QuizQuestionWhereInput
    none?: QuizQuestionWhereInput
  }

  export type QuizSectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizQuestionGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizCountOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    timeLimitSec?: SortOrder
    maxAttempts?: SortOrder
    shuffleQuestions?: SortOrder
    shuffleOptions?: SortOrder
    gradingMethod?: SortOrder
    showAnswersAfter?: SortOrder
    dueAt?: SortOrder
    isPublished?: SortOrder
    totalPoints?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type QuizAvgOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    timeLimitSec?: SortOrder
    maxAttempts?: SortOrder
    totalPoints?: SortOrder
    createdBy?: SortOrder
  }

  export type QuizMaxOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    timeLimitSec?: SortOrder
    maxAttempts?: SortOrder
    shuffleQuestions?: SortOrder
    shuffleOptions?: SortOrder
    gradingMethod?: SortOrder
    showAnswersAfter?: SortOrder
    dueAt?: SortOrder
    isPublished?: SortOrder
    totalPoints?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type QuizMinOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    timeLimitSec?: SortOrder
    maxAttempts?: SortOrder
    shuffleQuestions?: SortOrder
    shuffleOptions?: SortOrder
    gradingMethod?: SortOrder
    showAnswersAfter?: SortOrder
    dueAt?: SortOrder
    isPublished?: SortOrder
    totalPoints?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type QuizSumOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    timeLimitSec?: SortOrder
    maxAttempts?: SortOrder
    totalPoints?: SortOrder
    createdBy?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type QuizScalarRelationFilter = {
    is?: QuizWhereInput
    isNot?: QuizWhereInput
  }

  export type QuizSectionCountOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    orderIndex?: SortOrder
  }

  export type QuizSectionAvgOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    orderIndex?: SortOrder
  }

  export type QuizSectionMaxOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    orderIndex?: SortOrder
  }

  export type QuizSectionMinOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    orderIndex?: SortOrder
  }

  export type QuizSectionSumOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    orderIndex?: SortOrder
  }

  export type QuizSectionNullableScalarRelationFilter = {
    is?: QuizSectionWhereInput | null
    isNot?: QuizSectionWhereInput | null
  }

  export type QuizQuestionGroupCountOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    sectionId?: SortOrder
    title?: SortOrder
    introText?: SortOrder
    orderIndex?: SortOrder
    shuffleInside?: SortOrder
    pointsPolicy?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizQuestionGroupAvgOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    sectionId?: SortOrder
    orderIndex?: SortOrder
  }

  export type QuizQuestionGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    sectionId?: SortOrder
    title?: SortOrder
    introText?: SortOrder
    orderIndex?: SortOrder
    shuffleInside?: SortOrder
    pointsPolicy?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizQuestionGroupMinOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    sectionId?: SortOrder
    title?: SortOrder
    introText?: SortOrder
    orderIndex?: SortOrder
    shuffleInside?: SortOrder
    pointsPolicy?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizQuestionGroupSumOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    sectionId?: SortOrder
    orderIndex?: SortOrder
  }

  export type QuizQuestionGroupNullableScalarRelationFilter = {
    is?: QuizQuestionGroupWhereInput | null
    isNot?: QuizQuestionGroupWhereInput | null
  }

  export type QuizOptionListRelationFilter = {
    every?: QuizOptionWhereInput
    some?: QuizOptionWhereInput
    none?: QuizOptionWhereInput
  }

  export type QuizAnswerListRelationFilter = {
    every?: QuizAnswerWhereInput
    some?: QuizAnswerWhereInput
    none?: QuizAnswerWhereInput
  }

  export type QuizOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    sectionId?: SortOrder
    groupId?: SortOrder
    content?: SortOrder
    explanation?: SortOrder
    questionType?: SortOrder
    points?: SortOrder
    orderIndex?: SortOrder
  }

  export type QuizQuestionAvgOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    sectionId?: SortOrder
    groupId?: SortOrder
    points?: SortOrder
    orderIndex?: SortOrder
  }

  export type QuizQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    sectionId?: SortOrder
    groupId?: SortOrder
    content?: SortOrder
    explanation?: SortOrder
    questionType?: SortOrder
    points?: SortOrder
    orderIndex?: SortOrder
  }

  export type QuizQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    sectionId?: SortOrder
    groupId?: SortOrder
    content?: SortOrder
    explanation?: SortOrder
    questionType?: SortOrder
    points?: SortOrder
    orderIndex?: SortOrder
  }

  export type QuizQuestionSumOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    sectionId?: SortOrder
    groupId?: SortOrder
    points?: SortOrder
    orderIndex?: SortOrder
  }

  export type QuizQuestionScalarRelationFilter = {
    is?: QuizQuestionWhereInput
    isNot?: QuizQuestionWhereInput
  }

  export type QuizOptionCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    content?: SortOrder
    isCorrect?: SortOrder
    orderIndex?: SortOrder
  }

  export type QuizOptionAvgOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    orderIndex?: SortOrder
  }

  export type QuizOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    content?: SortOrder
    isCorrect?: SortOrder
    orderIndex?: SortOrder
  }

  export type QuizOptionMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    content?: SortOrder
    isCorrect?: SortOrder
    orderIndex?: SortOrder
  }

  export type QuizOptionSumOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    orderIndex?: SortOrder
  }

  export type QuizAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    studentId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrder
    status?: SortOrder
    scoreRaw?: SortOrder
    scoreScaled10?: SortOrder
  }

  export type QuizAttemptAvgOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    studentId?: SortOrder
    scoreRaw?: SortOrder
    scoreScaled10?: SortOrder
  }

  export type QuizAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    studentId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrder
    status?: SortOrder
    scoreRaw?: SortOrder
    scoreScaled10?: SortOrder
  }

  export type QuizAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    studentId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrder
    status?: SortOrder
    scoreRaw?: SortOrder
    scoreScaled10?: SortOrder
  }

  export type QuizAttemptSumOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    studentId?: SortOrder
    scoreRaw?: SortOrder
    scoreScaled10?: SortOrder
  }

  export type QuizAttemptScalarRelationFilter = {
    is?: QuizAttemptWhereInput
    isNot?: QuizAttemptWhereInput
  }

  export type QuizOptionScalarRelationFilter = {
    is?: QuizOptionWhereInput
    isNot?: QuizOptionWhereInput
  }

  export type QuizAnswerAttemptIdQuestionIdOptionIdCompoundUniqueInput = {
    attemptId: number
    questionId: number
    optionId: number
  }

  export type QuizAnswerCountOrderByAggregateInput = {
    attemptId?: SortOrder
    questionId?: SortOrder
    optionId?: SortOrder
  }

  export type QuizAnswerAvgOrderByAggregateInput = {
    attemptId?: SortOrder
    questionId?: SortOrder
    optionId?: SortOrder
  }

  export type QuizAnswerMaxOrderByAggregateInput = {
    attemptId?: SortOrder
    questionId?: SortOrder
    optionId?: SortOrder
  }

  export type QuizAnswerMinOrderByAggregateInput = {
    attemptId?: SortOrder
    questionId?: SortOrder
    optionId?: SortOrder
  }

  export type QuizAnswerSumOrderByAggregateInput = {
    attemptId?: SortOrder
    questionId?: SortOrder
    optionId?: SortOrder
  }

  export type QuizQuestionGroupScalarRelationFilter = {
    is?: QuizQuestionGroupWhereInput
    isNot?: QuizQuestionGroupWhereInput
  }

  export type QuizQuestionGroupMediaGroupIdMediaIdCompoundUniqueInput = {
    groupId: number
    mediaId: number
  }

  export type QuizQuestionGroupMediaCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    mediaId?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizQuestionGroupMediaAvgOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    mediaId?: SortOrder
  }

  export type QuizQuestionGroupMediaMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    mediaId?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizQuestionGroupMediaMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    mediaId?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizQuestionGroupMediaSumOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    mediaId?: SortOrder
  }

  export type QuizQuestionMediaQuestionIdMediaIdCompoundUniqueInput = {
    questionId: number
    mediaId: number
  }

  export type QuizQuestionMediaCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    mediaId?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizQuestionMediaAvgOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    mediaId?: SortOrder
  }

  export type QuizQuestionMediaMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    mediaId?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizQuestionMediaMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    mediaId?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizQuestionMediaSumOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    mediaId?: SortOrder
  }

  export type QuizOptionMediaOptionIdMediaIdCompoundUniqueInput = {
    optionId: number
    mediaId: number
  }

  export type QuizOptionMediaCountOrderByAggregateInput = {
    id?: SortOrder
    optionId?: SortOrder
    mediaId?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizOptionMediaAvgOrderByAggregateInput = {
    id?: SortOrder
    optionId?: SortOrder
    mediaId?: SortOrder
  }

  export type QuizOptionMediaMaxOrderByAggregateInput = {
    id?: SortOrder
    optionId?: SortOrder
    mediaId?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizOptionMediaMinOrderByAggregateInput = {
    id?: SortOrder
    optionId?: SortOrder
    mediaId?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizOptionMediaSumOrderByAggregateInput = {
    id?: SortOrder
    optionId?: SortOrder
    mediaId?: SortOrder
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutUploadedMediaInput = {
    create?: XOR<UserCreateWithoutUploadedMediaInput, UserUncheckedCreateWithoutUploadedMediaInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedMediaInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutAvatarMediaInput = {
    create?: XOR<UserCreateWithoutAvatarMediaInput, UserUncheckedCreateWithoutAvatarMediaInput> | UserCreateWithoutAvatarMediaInput[] | UserUncheckedCreateWithoutAvatarMediaInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAvatarMediaInput | UserCreateOrConnectWithoutAvatarMediaInput[]
    createMany?: UserCreateManyAvatarMediaInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ClassroomCreateNestedManyWithoutCoverMediaInput = {
    create?: XOR<ClassroomCreateWithoutCoverMediaInput, ClassroomUncheckedCreateWithoutCoverMediaInput> | ClassroomCreateWithoutCoverMediaInput[] | ClassroomUncheckedCreateWithoutCoverMediaInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutCoverMediaInput | ClassroomCreateOrConnectWithoutCoverMediaInput[]
    createMany?: ClassroomCreateManyCoverMediaInputEnvelope
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
  }

  export type MaterialCreateNestedManyWithoutMediaInput = {
    create?: XOR<MaterialCreateWithoutMediaInput, MaterialUncheckedCreateWithoutMediaInput> | MaterialCreateWithoutMediaInput[] | MaterialUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutMediaInput | MaterialCreateOrConnectWithoutMediaInput[]
    createMany?: MaterialCreateManyMediaInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type ExerciseCreateNestedManyWithoutAttachMediaInput = {
    create?: XOR<ExerciseCreateWithoutAttachMediaInput, ExerciseUncheckedCreateWithoutAttachMediaInput> | ExerciseCreateWithoutAttachMediaInput[] | ExerciseUncheckedCreateWithoutAttachMediaInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutAttachMediaInput | ExerciseCreateOrConnectWithoutAttachMediaInput[]
    createMany?: ExerciseCreateManyAttachMediaInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type ExerciseSubmissionCreateNestedManyWithoutMediaInput = {
    create?: XOR<ExerciseSubmissionCreateWithoutMediaInput, ExerciseSubmissionUncheckedCreateWithoutMediaInput> | ExerciseSubmissionCreateWithoutMediaInput[] | ExerciseSubmissionUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: ExerciseSubmissionCreateOrConnectWithoutMediaInput | ExerciseSubmissionCreateOrConnectWithoutMediaInput[]
    createMany?: ExerciseSubmissionCreateManyMediaInputEnvelope
    connect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
  }

  export type QuizQuestionGroupMediaCreateNestedManyWithoutMediaInput = {
    create?: XOR<QuizQuestionGroupMediaCreateWithoutMediaInput, QuizQuestionGroupMediaUncheckedCreateWithoutMediaInput> | QuizQuestionGroupMediaCreateWithoutMediaInput[] | QuizQuestionGroupMediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: QuizQuestionGroupMediaCreateOrConnectWithoutMediaInput | QuizQuestionGroupMediaCreateOrConnectWithoutMediaInput[]
    createMany?: QuizQuestionGroupMediaCreateManyMediaInputEnvelope
    connect?: QuizQuestionGroupMediaWhereUniqueInput | QuizQuestionGroupMediaWhereUniqueInput[]
  }

  export type QuizQuestionMediaCreateNestedManyWithoutMediaInput = {
    create?: XOR<QuizQuestionMediaCreateWithoutMediaInput, QuizQuestionMediaUncheckedCreateWithoutMediaInput> | QuizQuestionMediaCreateWithoutMediaInput[] | QuizQuestionMediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: QuizQuestionMediaCreateOrConnectWithoutMediaInput | QuizQuestionMediaCreateOrConnectWithoutMediaInput[]
    createMany?: QuizQuestionMediaCreateManyMediaInputEnvelope
    connect?: QuizQuestionMediaWhereUniqueInput | QuizQuestionMediaWhereUniqueInput[]
  }

  export type QuizOptionMediaCreateNestedManyWithoutMediaInput = {
    create?: XOR<QuizOptionMediaCreateWithoutMediaInput, QuizOptionMediaUncheckedCreateWithoutMediaInput> | QuizOptionMediaCreateWithoutMediaInput[] | QuizOptionMediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: QuizOptionMediaCreateOrConnectWithoutMediaInput | QuizOptionMediaCreateOrConnectWithoutMediaInput[]
    createMany?: QuizOptionMediaCreateManyMediaInputEnvelope
    connect?: QuizOptionMediaWhereUniqueInput | QuizOptionMediaWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutAvatarMediaInput = {
    create?: XOR<UserCreateWithoutAvatarMediaInput, UserUncheckedCreateWithoutAvatarMediaInput> | UserCreateWithoutAvatarMediaInput[] | UserUncheckedCreateWithoutAvatarMediaInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAvatarMediaInput | UserCreateOrConnectWithoutAvatarMediaInput[]
    createMany?: UserCreateManyAvatarMediaInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ClassroomUncheckedCreateNestedManyWithoutCoverMediaInput = {
    create?: XOR<ClassroomCreateWithoutCoverMediaInput, ClassroomUncheckedCreateWithoutCoverMediaInput> | ClassroomCreateWithoutCoverMediaInput[] | ClassroomUncheckedCreateWithoutCoverMediaInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutCoverMediaInput | ClassroomCreateOrConnectWithoutCoverMediaInput[]
    createMany?: ClassroomCreateManyCoverMediaInputEnvelope
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
  }

  export type MaterialUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<MaterialCreateWithoutMediaInput, MaterialUncheckedCreateWithoutMediaInput> | MaterialCreateWithoutMediaInput[] | MaterialUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutMediaInput | MaterialCreateOrConnectWithoutMediaInput[]
    createMany?: MaterialCreateManyMediaInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type ExerciseUncheckedCreateNestedManyWithoutAttachMediaInput = {
    create?: XOR<ExerciseCreateWithoutAttachMediaInput, ExerciseUncheckedCreateWithoutAttachMediaInput> | ExerciseCreateWithoutAttachMediaInput[] | ExerciseUncheckedCreateWithoutAttachMediaInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutAttachMediaInput | ExerciseCreateOrConnectWithoutAttachMediaInput[]
    createMany?: ExerciseCreateManyAttachMediaInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type ExerciseSubmissionUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<ExerciseSubmissionCreateWithoutMediaInput, ExerciseSubmissionUncheckedCreateWithoutMediaInput> | ExerciseSubmissionCreateWithoutMediaInput[] | ExerciseSubmissionUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: ExerciseSubmissionCreateOrConnectWithoutMediaInput | ExerciseSubmissionCreateOrConnectWithoutMediaInput[]
    createMany?: ExerciseSubmissionCreateManyMediaInputEnvelope
    connect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
  }

  export type QuizQuestionGroupMediaUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<QuizQuestionGroupMediaCreateWithoutMediaInput, QuizQuestionGroupMediaUncheckedCreateWithoutMediaInput> | QuizQuestionGroupMediaCreateWithoutMediaInput[] | QuizQuestionGroupMediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: QuizQuestionGroupMediaCreateOrConnectWithoutMediaInput | QuizQuestionGroupMediaCreateOrConnectWithoutMediaInput[]
    createMany?: QuizQuestionGroupMediaCreateManyMediaInputEnvelope
    connect?: QuizQuestionGroupMediaWhereUniqueInput | QuizQuestionGroupMediaWhereUniqueInput[]
  }

  export type QuizQuestionMediaUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<QuizQuestionMediaCreateWithoutMediaInput, QuizQuestionMediaUncheckedCreateWithoutMediaInput> | QuizQuestionMediaCreateWithoutMediaInput[] | QuizQuestionMediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: QuizQuestionMediaCreateOrConnectWithoutMediaInput | QuizQuestionMediaCreateOrConnectWithoutMediaInput[]
    createMany?: QuizQuestionMediaCreateManyMediaInputEnvelope
    connect?: QuizQuestionMediaWhereUniqueInput | QuizQuestionMediaWhereUniqueInput[]
  }

  export type QuizOptionMediaUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<QuizOptionMediaCreateWithoutMediaInput, QuizOptionMediaUncheckedCreateWithoutMediaInput> | QuizOptionMediaCreateWithoutMediaInput[] | QuizOptionMediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: QuizOptionMediaCreateOrConnectWithoutMediaInput | QuizOptionMediaCreateOrConnectWithoutMediaInput[]
    createMany?: QuizOptionMediaCreateManyMediaInputEnvelope
    connect?: QuizOptionMediaWhereUniqueInput | QuizOptionMediaWhereUniqueInput[]
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type UserUpdateOneWithoutUploadedMediaNestedInput = {
    create?: XOR<UserCreateWithoutUploadedMediaInput, UserUncheckedCreateWithoutUploadedMediaInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedMediaInput
    upsert?: UserUpsertWithoutUploadedMediaInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedMediaInput, UserUpdateWithoutUploadedMediaInput>, UserUncheckedUpdateWithoutUploadedMediaInput>
  }

  export type UserUpdateManyWithoutAvatarMediaNestedInput = {
    create?: XOR<UserCreateWithoutAvatarMediaInput, UserUncheckedCreateWithoutAvatarMediaInput> | UserCreateWithoutAvatarMediaInput[] | UserUncheckedCreateWithoutAvatarMediaInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAvatarMediaInput | UserCreateOrConnectWithoutAvatarMediaInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAvatarMediaInput | UserUpsertWithWhereUniqueWithoutAvatarMediaInput[]
    createMany?: UserCreateManyAvatarMediaInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAvatarMediaInput | UserUpdateWithWhereUniqueWithoutAvatarMediaInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAvatarMediaInput | UserUpdateManyWithWhereWithoutAvatarMediaInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ClassroomUpdateManyWithoutCoverMediaNestedInput = {
    create?: XOR<ClassroomCreateWithoutCoverMediaInput, ClassroomUncheckedCreateWithoutCoverMediaInput> | ClassroomCreateWithoutCoverMediaInput[] | ClassroomUncheckedCreateWithoutCoverMediaInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutCoverMediaInput | ClassroomCreateOrConnectWithoutCoverMediaInput[]
    upsert?: ClassroomUpsertWithWhereUniqueWithoutCoverMediaInput | ClassroomUpsertWithWhereUniqueWithoutCoverMediaInput[]
    createMany?: ClassroomCreateManyCoverMediaInputEnvelope
    set?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    disconnect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    delete?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    update?: ClassroomUpdateWithWhereUniqueWithoutCoverMediaInput | ClassroomUpdateWithWhereUniqueWithoutCoverMediaInput[]
    updateMany?: ClassroomUpdateManyWithWhereWithoutCoverMediaInput | ClassroomUpdateManyWithWhereWithoutCoverMediaInput[]
    deleteMany?: ClassroomScalarWhereInput | ClassroomScalarWhereInput[]
  }

  export type MaterialUpdateManyWithoutMediaNestedInput = {
    create?: XOR<MaterialCreateWithoutMediaInput, MaterialUncheckedCreateWithoutMediaInput> | MaterialCreateWithoutMediaInput[] | MaterialUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutMediaInput | MaterialCreateOrConnectWithoutMediaInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutMediaInput | MaterialUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: MaterialCreateManyMediaInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutMediaInput | MaterialUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutMediaInput | MaterialUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type ExerciseUpdateManyWithoutAttachMediaNestedInput = {
    create?: XOR<ExerciseCreateWithoutAttachMediaInput, ExerciseUncheckedCreateWithoutAttachMediaInput> | ExerciseCreateWithoutAttachMediaInput[] | ExerciseUncheckedCreateWithoutAttachMediaInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutAttachMediaInput | ExerciseCreateOrConnectWithoutAttachMediaInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutAttachMediaInput | ExerciseUpsertWithWhereUniqueWithoutAttachMediaInput[]
    createMany?: ExerciseCreateManyAttachMediaInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutAttachMediaInput | ExerciseUpdateWithWhereUniqueWithoutAttachMediaInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutAttachMediaInput | ExerciseUpdateManyWithWhereWithoutAttachMediaInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type ExerciseSubmissionUpdateManyWithoutMediaNestedInput = {
    create?: XOR<ExerciseSubmissionCreateWithoutMediaInput, ExerciseSubmissionUncheckedCreateWithoutMediaInput> | ExerciseSubmissionCreateWithoutMediaInput[] | ExerciseSubmissionUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: ExerciseSubmissionCreateOrConnectWithoutMediaInput | ExerciseSubmissionCreateOrConnectWithoutMediaInput[]
    upsert?: ExerciseSubmissionUpsertWithWhereUniqueWithoutMediaInput | ExerciseSubmissionUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: ExerciseSubmissionCreateManyMediaInputEnvelope
    set?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    disconnect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    delete?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    connect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    update?: ExerciseSubmissionUpdateWithWhereUniqueWithoutMediaInput | ExerciseSubmissionUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: ExerciseSubmissionUpdateManyWithWhereWithoutMediaInput | ExerciseSubmissionUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: ExerciseSubmissionScalarWhereInput | ExerciseSubmissionScalarWhereInput[]
  }

  export type QuizQuestionGroupMediaUpdateManyWithoutMediaNestedInput = {
    create?: XOR<QuizQuestionGroupMediaCreateWithoutMediaInput, QuizQuestionGroupMediaUncheckedCreateWithoutMediaInput> | QuizQuestionGroupMediaCreateWithoutMediaInput[] | QuizQuestionGroupMediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: QuizQuestionGroupMediaCreateOrConnectWithoutMediaInput | QuizQuestionGroupMediaCreateOrConnectWithoutMediaInput[]
    upsert?: QuizQuestionGroupMediaUpsertWithWhereUniqueWithoutMediaInput | QuizQuestionGroupMediaUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: QuizQuestionGroupMediaCreateManyMediaInputEnvelope
    set?: QuizQuestionGroupMediaWhereUniqueInput | QuizQuestionGroupMediaWhereUniqueInput[]
    disconnect?: QuizQuestionGroupMediaWhereUniqueInput | QuizQuestionGroupMediaWhereUniqueInput[]
    delete?: QuizQuestionGroupMediaWhereUniqueInput | QuizQuestionGroupMediaWhereUniqueInput[]
    connect?: QuizQuestionGroupMediaWhereUniqueInput | QuizQuestionGroupMediaWhereUniqueInput[]
    update?: QuizQuestionGroupMediaUpdateWithWhereUniqueWithoutMediaInput | QuizQuestionGroupMediaUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: QuizQuestionGroupMediaUpdateManyWithWhereWithoutMediaInput | QuizQuestionGroupMediaUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: QuizQuestionGroupMediaScalarWhereInput | QuizQuestionGroupMediaScalarWhereInput[]
  }

  export type QuizQuestionMediaUpdateManyWithoutMediaNestedInput = {
    create?: XOR<QuizQuestionMediaCreateWithoutMediaInput, QuizQuestionMediaUncheckedCreateWithoutMediaInput> | QuizQuestionMediaCreateWithoutMediaInput[] | QuizQuestionMediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: QuizQuestionMediaCreateOrConnectWithoutMediaInput | QuizQuestionMediaCreateOrConnectWithoutMediaInput[]
    upsert?: QuizQuestionMediaUpsertWithWhereUniqueWithoutMediaInput | QuizQuestionMediaUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: QuizQuestionMediaCreateManyMediaInputEnvelope
    set?: QuizQuestionMediaWhereUniqueInput | QuizQuestionMediaWhereUniqueInput[]
    disconnect?: QuizQuestionMediaWhereUniqueInput | QuizQuestionMediaWhereUniqueInput[]
    delete?: QuizQuestionMediaWhereUniqueInput | QuizQuestionMediaWhereUniqueInput[]
    connect?: QuizQuestionMediaWhereUniqueInput | QuizQuestionMediaWhereUniqueInput[]
    update?: QuizQuestionMediaUpdateWithWhereUniqueWithoutMediaInput | QuizQuestionMediaUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: QuizQuestionMediaUpdateManyWithWhereWithoutMediaInput | QuizQuestionMediaUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: QuizQuestionMediaScalarWhereInput | QuizQuestionMediaScalarWhereInput[]
  }

  export type QuizOptionMediaUpdateManyWithoutMediaNestedInput = {
    create?: XOR<QuizOptionMediaCreateWithoutMediaInput, QuizOptionMediaUncheckedCreateWithoutMediaInput> | QuizOptionMediaCreateWithoutMediaInput[] | QuizOptionMediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: QuizOptionMediaCreateOrConnectWithoutMediaInput | QuizOptionMediaCreateOrConnectWithoutMediaInput[]
    upsert?: QuizOptionMediaUpsertWithWhereUniqueWithoutMediaInput | QuizOptionMediaUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: QuizOptionMediaCreateManyMediaInputEnvelope
    set?: QuizOptionMediaWhereUniqueInput | QuizOptionMediaWhereUniqueInput[]
    disconnect?: QuizOptionMediaWhereUniqueInput | QuizOptionMediaWhereUniqueInput[]
    delete?: QuizOptionMediaWhereUniqueInput | QuizOptionMediaWhereUniqueInput[]
    connect?: QuizOptionMediaWhereUniqueInput | QuizOptionMediaWhereUniqueInput[]
    update?: QuizOptionMediaUpdateWithWhereUniqueWithoutMediaInput | QuizOptionMediaUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: QuizOptionMediaUpdateManyWithWhereWithoutMediaInput | QuizOptionMediaUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: QuizOptionMediaScalarWhereInput | QuizOptionMediaScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUncheckedUpdateManyWithoutAvatarMediaNestedInput = {
    create?: XOR<UserCreateWithoutAvatarMediaInput, UserUncheckedCreateWithoutAvatarMediaInput> | UserCreateWithoutAvatarMediaInput[] | UserUncheckedCreateWithoutAvatarMediaInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAvatarMediaInput | UserCreateOrConnectWithoutAvatarMediaInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAvatarMediaInput | UserUpsertWithWhereUniqueWithoutAvatarMediaInput[]
    createMany?: UserCreateManyAvatarMediaInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAvatarMediaInput | UserUpdateWithWhereUniqueWithoutAvatarMediaInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAvatarMediaInput | UserUpdateManyWithWhereWithoutAvatarMediaInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ClassroomUncheckedUpdateManyWithoutCoverMediaNestedInput = {
    create?: XOR<ClassroomCreateWithoutCoverMediaInput, ClassroomUncheckedCreateWithoutCoverMediaInput> | ClassroomCreateWithoutCoverMediaInput[] | ClassroomUncheckedCreateWithoutCoverMediaInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutCoverMediaInput | ClassroomCreateOrConnectWithoutCoverMediaInput[]
    upsert?: ClassroomUpsertWithWhereUniqueWithoutCoverMediaInput | ClassroomUpsertWithWhereUniqueWithoutCoverMediaInput[]
    createMany?: ClassroomCreateManyCoverMediaInputEnvelope
    set?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    disconnect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    delete?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    update?: ClassroomUpdateWithWhereUniqueWithoutCoverMediaInput | ClassroomUpdateWithWhereUniqueWithoutCoverMediaInput[]
    updateMany?: ClassroomUpdateManyWithWhereWithoutCoverMediaInput | ClassroomUpdateManyWithWhereWithoutCoverMediaInput[]
    deleteMany?: ClassroomScalarWhereInput | ClassroomScalarWhereInput[]
  }

  export type MaterialUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<MaterialCreateWithoutMediaInput, MaterialUncheckedCreateWithoutMediaInput> | MaterialCreateWithoutMediaInput[] | MaterialUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutMediaInput | MaterialCreateOrConnectWithoutMediaInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutMediaInput | MaterialUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: MaterialCreateManyMediaInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutMediaInput | MaterialUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutMediaInput | MaterialUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type ExerciseUncheckedUpdateManyWithoutAttachMediaNestedInput = {
    create?: XOR<ExerciseCreateWithoutAttachMediaInput, ExerciseUncheckedCreateWithoutAttachMediaInput> | ExerciseCreateWithoutAttachMediaInput[] | ExerciseUncheckedCreateWithoutAttachMediaInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutAttachMediaInput | ExerciseCreateOrConnectWithoutAttachMediaInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutAttachMediaInput | ExerciseUpsertWithWhereUniqueWithoutAttachMediaInput[]
    createMany?: ExerciseCreateManyAttachMediaInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutAttachMediaInput | ExerciseUpdateWithWhereUniqueWithoutAttachMediaInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutAttachMediaInput | ExerciseUpdateManyWithWhereWithoutAttachMediaInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type ExerciseSubmissionUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<ExerciseSubmissionCreateWithoutMediaInput, ExerciseSubmissionUncheckedCreateWithoutMediaInput> | ExerciseSubmissionCreateWithoutMediaInput[] | ExerciseSubmissionUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: ExerciseSubmissionCreateOrConnectWithoutMediaInput | ExerciseSubmissionCreateOrConnectWithoutMediaInput[]
    upsert?: ExerciseSubmissionUpsertWithWhereUniqueWithoutMediaInput | ExerciseSubmissionUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: ExerciseSubmissionCreateManyMediaInputEnvelope
    set?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    disconnect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    delete?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    connect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    update?: ExerciseSubmissionUpdateWithWhereUniqueWithoutMediaInput | ExerciseSubmissionUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: ExerciseSubmissionUpdateManyWithWhereWithoutMediaInput | ExerciseSubmissionUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: ExerciseSubmissionScalarWhereInput | ExerciseSubmissionScalarWhereInput[]
  }

  export type QuizQuestionGroupMediaUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<QuizQuestionGroupMediaCreateWithoutMediaInput, QuizQuestionGroupMediaUncheckedCreateWithoutMediaInput> | QuizQuestionGroupMediaCreateWithoutMediaInput[] | QuizQuestionGroupMediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: QuizQuestionGroupMediaCreateOrConnectWithoutMediaInput | QuizQuestionGroupMediaCreateOrConnectWithoutMediaInput[]
    upsert?: QuizQuestionGroupMediaUpsertWithWhereUniqueWithoutMediaInput | QuizQuestionGroupMediaUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: QuizQuestionGroupMediaCreateManyMediaInputEnvelope
    set?: QuizQuestionGroupMediaWhereUniqueInput | QuizQuestionGroupMediaWhereUniqueInput[]
    disconnect?: QuizQuestionGroupMediaWhereUniqueInput | QuizQuestionGroupMediaWhereUniqueInput[]
    delete?: QuizQuestionGroupMediaWhereUniqueInput | QuizQuestionGroupMediaWhereUniqueInput[]
    connect?: QuizQuestionGroupMediaWhereUniqueInput | QuizQuestionGroupMediaWhereUniqueInput[]
    update?: QuizQuestionGroupMediaUpdateWithWhereUniqueWithoutMediaInput | QuizQuestionGroupMediaUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: QuizQuestionGroupMediaUpdateManyWithWhereWithoutMediaInput | QuizQuestionGroupMediaUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: QuizQuestionGroupMediaScalarWhereInput | QuizQuestionGroupMediaScalarWhereInput[]
  }

  export type QuizQuestionMediaUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<QuizQuestionMediaCreateWithoutMediaInput, QuizQuestionMediaUncheckedCreateWithoutMediaInput> | QuizQuestionMediaCreateWithoutMediaInput[] | QuizQuestionMediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: QuizQuestionMediaCreateOrConnectWithoutMediaInput | QuizQuestionMediaCreateOrConnectWithoutMediaInput[]
    upsert?: QuizQuestionMediaUpsertWithWhereUniqueWithoutMediaInput | QuizQuestionMediaUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: QuizQuestionMediaCreateManyMediaInputEnvelope
    set?: QuizQuestionMediaWhereUniqueInput | QuizQuestionMediaWhereUniqueInput[]
    disconnect?: QuizQuestionMediaWhereUniqueInput | QuizQuestionMediaWhereUniqueInput[]
    delete?: QuizQuestionMediaWhereUniqueInput | QuizQuestionMediaWhereUniqueInput[]
    connect?: QuizQuestionMediaWhereUniqueInput | QuizQuestionMediaWhereUniqueInput[]
    update?: QuizQuestionMediaUpdateWithWhereUniqueWithoutMediaInput | QuizQuestionMediaUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: QuizQuestionMediaUpdateManyWithWhereWithoutMediaInput | QuizQuestionMediaUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: QuizQuestionMediaScalarWhereInput | QuizQuestionMediaScalarWhereInput[]
  }

  export type QuizOptionMediaUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<QuizOptionMediaCreateWithoutMediaInput, QuizOptionMediaUncheckedCreateWithoutMediaInput> | QuizOptionMediaCreateWithoutMediaInput[] | QuizOptionMediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: QuizOptionMediaCreateOrConnectWithoutMediaInput | QuizOptionMediaCreateOrConnectWithoutMediaInput[]
    upsert?: QuizOptionMediaUpsertWithWhereUniqueWithoutMediaInput | QuizOptionMediaUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: QuizOptionMediaCreateManyMediaInputEnvelope
    set?: QuizOptionMediaWhereUniqueInput | QuizOptionMediaWhereUniqueInput[]
    disconnect?: QuizOptionMediaWhereUniqueInput | QuizOptionMediaWhereUniqueInput[]
    delete?: QuizOptionMediaWhereUniqueInput | QuizOptionMediaWhereUniqueInput[]
    connect?: QuizOptionMediaWhereUniqueInput | QuizOptionMediaWhereUniqueInput[]
    update?: QuizOptionMediaUpdateWithWhereUniqueWithoutMediaInput | QuizOptionMediaUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: QuizOptionMediaUpdateManyWithWhereWithoutMediaInput | QuizOptionMediaUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: QuizOptionMediaScalarWhereInput | QuizOptionMediaScalarWhereInput[]
  }

  export type MediaCreateNestedOneWithoutUserAvatarsInput = {
    create?: XOR<MediaCreateWithoutUserAvatarsInput, MediaUncheckedCreateWithoutUserAvatarsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutUserAvatarsInput
    connect?: MediaWhereUniqueInput
  }

  export type MediaCreateNestedManyWithoutUploaderInput = {
    create?: XOR<MediaCreateWithoutUploaderInput, MediaUncheckedCreateWithoutUploaderInput> | MediaCreateWithoutUploaderInput[] | MediaUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutUploaderInput | MediaCreateOrConnectWithoutUploaderInput[]
    createMany?: MediaCreateManyUploaderInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type ClassroomCreateNestedManyWithoutTutorInput = {
    create?: XOR<ClassroomCreateWithoutTutorInput, ClassroomUncheckedCreateWithoutTutorInput> | ClassroomCreateWithoutTutorInput[] | ClassroomUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutTutorInput | ClassroomCreateOrConnectWithoutTutorInput[]
    createMany?: ClassroomCreateManyTutorInputEnvelope
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
  }

  export type ClassroomCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ClassroomCreateWithoutCreatorInput, ClassroomUncheckedCreateWithoutCreatorInput> | ClassroomCreateWithoutCreatorInput[] | ClassroomUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutCreatorInput | ClassroomCreateOrConnectWithoutCreatorInput[]
    createMany?: ClassroomCreateManyCreatorInputEnvelope
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
  }

  export type ClassroomStudentCreateNestedManyWithoutStudentInput = {
    create?: XOR<ClassroomStudentCreateWithoutStudentInput, ClassroomStudentUncheckedCreateWithoutStudentInput> | ClassroomStudentCreateWithoutStudentInput[] | ClassroomStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ClassroomStudentCreateOrConnectWithoutStudentInput | ClassroomStudentCreateOrConnectWithoutStudentInput[]
    createMany?: ClassroomStudentCreateManyStudentInputEnvelope
    connect?: ClassroomStudentWhereUniqueInput | ClassroomStudentWhereUniqueInput[]
  }

  export type JoinRequestCreateNestedManyWithoutStudentInput = {
    create?: XOR<JoinRequestCreateWithoutStudentInput, JoinRequestUncheckedCreateWithoutStudentInput> | JoinRequestCreateWithoutStudentInput[] | JoinRequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: JoinRequestCreateOrConnectWithoutStudentInput | JoinRequestCreateOrConnectWithoutStudentInput[]
    createMany?: JoinRequestCreateManyStudentInputEnvelope
    connect?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
  }

  export type MaterialCreateNestedManyWithoutUploaderInput = {
    create?: XOR<MaterialCreateWithoutUploaderInput, MaterialUncheckedCreateWithoutUploaderInput> | MaterialCreateWithoutUploaderInput[] | MaterialUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutUploaderInput | MaterialCreateOrConnectWithoutUploaderInput[]
    createMany?: MaterialCreateManyUploaderInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type ExerciseCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ExerciseCreateWithoutCreatorInput, ExerciseUncheckedCreateWithoutCreatorInput> | ExerciseCreateWithoutCreatorInput[] | ExerciseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutCreatorInput | ExerciseCreateOrConnectWithoutCreatorInput[]
    createMany?: ExerciseCreateManyCreatorInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type ExerciseSubmissionCreateNestedManyWithoutStudentInput = {
    create?: XOR<ExerciseSubmissionCreateWithoutStudentInput, ExerciseSubmissionUncheckedCreateWithoutStudentInput> | ExerciseSubmissionCreateWithoutStudentInput[] | ExerciseSubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ExerciseSubmissionCreateOrConnectWithoutStudentInput | ExerciseSubmissionCreateOrConnectWithoutStudentInput[]
    createMany?: ExerciseSubmissionCreateManyStudentInputEnvelope
    connect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
  }

  export type QuizCreateNestedManyWithoutCreatorInput = {
    create?: XOR<QuizCreateWithoutCreatorInput, QuizUncheckedCreateWithoutCreatorInput> | QuizCreateWithoutCreatorInput[] | QuizUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutCreatorInput | QuizCreateOrConnectWithoutCreatorInput[]
    createMany?: QuizCreateManyCreatorInputEnvelope
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type QuizAttemptCreateNestedManyWithoutStudentInput = {
    create?: XOR<QuizAttemptCreateWithoutStudentInput, QuizAttemptUncheckedCreateWithoutStudentInput> | QuizAttemptCreateWithoutStudentInput[] | QuizAttemptUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutStudentInput | QuizAttemptCreateOrConnectWithoutStudentInput[]
    createMany?: QuizAttemptCreateManyStudentInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type MediaUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<MediaCreateWithoutUploaderInput, MediaUncheckedCreateWithoutUploaderInput> | MediaCreateWithoutUploaderInput[] | MediaUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutUploaderInput | MediaCreateOrConnectWithoutUploaderInput[]
    createMany?: MediaCreateManyUploaderInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type ClassroomUncheckedCreateNestedManyWithoutTutorInput = {
    create?: XOR<ClassroomCreateWithoutTutorInput, ClassroomUncheckedCreateWithoutTutorInput> | ClassroomCreateWithoutTutorInput[] | ClassroomUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutTutorInput | ClassroomCreateOrConnectWithoutTutorInput[]
    createMany?: ClassroomCreateManyTutorInputEnvelope
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
  }

  export type ClassroomUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ClassroomCreateWithoutCreatorInput, ClassroomUncheckedCreateWithoutCreatorInput> | ClassroomCreateWithoutCreatorInput[] | ClassroomUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutCreatorInput | ClassroomCreateOrConnectWithoutCreatorInput[]
    createMany?: ClassroomCreateManyCreatorInputEnvelope
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
  }

  export type ClassroomStudentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<ClassroomStudentCreateWithoutStudentInput, ClassroomStudentUncheckedCreateWithoutStudentInput> | ClassroomStudentCreateWithoutStudentInput[] | ClassroomStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ClassroomStudentCreateOrConnectWithoutStudentInput | ClassroomStudentCreateOrConnectWithoutStudentInput[]
    createMany?: ClassroomStudentCreateManyStudentInputEnvelope
    connect?: ClassroomStudentWhereUniqueInput | ClassroomStudentWhereUniqueInput[]
  }

  export type JoinRequestUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<JoinRequestCreateWithoutStudentInput, JoinRequestUncheckedCreateWithoutStudentInput> | JoinRequestCreateWithoutStudentInput[] | JoinRequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: JoinRequestCreateOrConnectWithoutStudentInput | JoinRequestCreateOrConnectWithoutStudentInput[]
    createMany?: JoinRequestCreateManyStudentInputEnvelope
    connect?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
  }

  export type MaterialUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<MaterialCreateWithoutUploaderInput, MaterialUncheckedCreateWithoutUploaderInput> | MaterialCreateWithoutUploaderInput[] | MaterialUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutUploaderInput | MaterialCreateOrConnectWithoutUploaderInput[]
    createMany?: MaterialCreateManyUploaderInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type ExerciseUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ExerciseCreateWithoutCreatorInput, ExerciseUncheckedCreateWithoutCreatorInput> | ExerciseCreateWithoutCreatorInput[] | ExerciseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutCreatorInput | ExerciseCreateOrConnectWithoutCreatorInput[]
    createMany?: ExerciseCreateManyCreatorInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type ExerciseSubmissionUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<ExerciseSubmissionCreateWithoutStudentInput, ExerciseSubmissionUncheckedCreateWithoutStudentInput> | ExerciseSubmissionCreateWithoutStudentInput[] | ExerciseSubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ExerciseSubmissionCreateOrConnectWithoutStudentInput | ExerciseSubmissionCreateOrConnectWithoutStudentInput[]
    createMany?: ExerciseSubmissionCreateManyStudentInputEnvelope
    connect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
  }

  export type QuizUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<QuizCreateWithoutCreatorInput, QuizUncheckedCreateWithoutCreatorInput> | QuizCreateWithoutCreatorInput[] | QuizUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutCreatorInput | QuizCreateOrConnectWithoutCreatorInput[]
    createMany?: QuizCreateManyCreatorInputEnvelope
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type QuizAttemptUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<QuizAttemptCreateWithoutStudentInput, QuizAttemptUncheckedCreateWithoutStudentInput> | QuizAttemptCreateWithoutStudentInput[] | QuizAttemptUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutStudentInput | QuizAttemptCreateOrConnectWithoutStudentInput[]
    createMany?: QuizAttemptCreateManyStudentInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type MediaUpdateOneWithoutUserAvatarsNestedInput = {
    create?: XOR<MediaCreateWithoutUserAvatarsInput, MediaUncheckedCreateWithoutUserAvatarsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutUserAvatarsInput
    upsert?: MediaUpsertWithoutUserAvatarsInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutUserAvatarsInput, MediaUpdateWithoutUserAvatarsInput>, MediaUncheckedUpdateWithoutUserAvatarsInput>
  }

  export type MediaUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<MediaCreateWithoutUploaderInput, MediaUncheckedCreateWithoutUploaderInput> | MediaCreateWithoutUploaderInput[] | MediaUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutUploaderInput | MediaCreateOrConnectWithoutUploaderInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutUploaderInput | MediaUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: MediaCreateManyUploaderInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutUploaderInput | MediaUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutUploaderInput | MediaUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type ClassroomUpdateManyWithoutTutorNestedInput = {
    create?: XOR<ClassroomCreateWithoutTutorInput, ClassroomUncheckedCreateWithoutTutorInput> | ClassroomCreateWithoutTutorInput[] | ClassroomUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutTutorInput | ClassroomCreateOrConnectWithoutTutorInput[]
    upsert?: ClassroomUpsertWithWhereUniqueWithoutTutorInput | ClassroomUpsertWithWhereUniqueWithoutTutorInput[]
    createMany?: ClassroomCreateManyTutorInputEnvelope
    set?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    disconnect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    delete?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    update?: ClassroomUpdateWithWhereUniqueWithoutTutorInput | ClassroomUpdateWithWhereUniqueWithoutTutorInput[]
    updateMany?: ClassroomUpdateManyWithWhereWithoutTutorInput | ClassroomUpdateManyWithWhereWithoutTutorInput[]
    deleteMany?: ClassroomScalarWhereInput | ClassroomScalarWhereInput[]
  }

  export type ClassroomUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ClassroomCreateWithoutCreatorInput, ClassroomUncheckedCreateWithoutCreatorInput> | ClassroomCreateWithoutCreatorInput[] | ClassroomUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutCreatorInput | ClassroomCreateOrConnectWithoutCreatorInput[]
    upsert?: ClassroomUpsertWithWhereUniqueWithoutCreatorInput | ClassroomUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ClassroomCreateManyCreatorInputEnvelope
    set?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    disconnect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    delete?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    update?: ClassroomUpdateWithWhereUniqueWithoutCreatorInput | ClassroomUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ClassroomUpdateManyWithWhereWithoutCreatorInput | ClassroomUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ClassroomScalarWhereInput | ClassroomScalarWhereInput[]
  }

  export type ClassroomStudentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ClassroomStudentCreateWithoutStudentInput, ClassroomStudentUncheckedCreateWithoutStudentInput> | ClassroomStudentCreateWithoutStudentInput[] | ClassroomStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ClassroomStudentCreateOrConnectWithoutStudentInput | ClassroomStudentCreateOrConnectWithoutStudentInput[]
    upsert?: ClassroomStudentUpsertWithWhereUniqueWithoutStudentInput | ClassroomStudentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ClassroomStudentCreateManyStudentInputEnvelope
    set?: ClassroomStudentWhereUniqueInput | ClassroomStudentWhereUniqueInput[]
    disconnect?: ClassroomStudentWhereUniqueInput | ClassroomStudentWhereUniqueInput[]
    delete?: ClassroomStudentWhereUniqueInput | ClassroomStudentWhereUniqueInput[]
    connect?: ClassroomStudentWhereUniqueInput | ClassroomStudentWhereUniqueInput[]
    update?: ClassroomStudentUpdateWithWhereUniqueWithoutStudentInput | ClassroomStudentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ClassroomStudentUpdateManyWithWhereWithoutStudentInput | ClassroomStudentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ClassroomStudentScalarWhereInput | ClassroomStudentScalarWhereInput[]
  }

  export type JoinRequestUpdateManyWithoutStudentNestedInput = {
    create?: XOR<JoinRequestCreateWithoutStudentInput, JoinRequestUncheckedCreateWithoutStudentInput> | JoinRequestCreateWithoutStudentInput[] | JoinRequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: JoinRequestCreateOrConnectWithoutStudentInput | JoinRequestCreateOrConnectWithoutStudentInput[]
    upsert?: JoinRequestUpsertWithWhereUniqueWithoutStudentInput | JoinRequestUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: JoinRequestCreateManyStudentInputEnvelope
    set?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
    disconnect?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
    delete?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
    connect?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
    update?: JoinRequestUpdateWithWhereUniqueWithoutStudentInput | JoinRequestUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: JoinRequestUpdateManyWithWhereWithoutStudentInput | JoinRequestUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: JoinRequestScalarWhereInput | JoinRequestScalarWhereInput[]
  }

  export type MaterialUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<MaterialCreateWithoutUploaderInput, MaterialUncheckedCreateWithoutUploaderInput> | MaterialCreateWithoutUploaderInput[] | MaterialUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutUploaderInput | MaterialCreateOrConnectWithoutUploaderInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutUploaderInput | MaterialUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: MaterialCreateManyUploaderInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutUploaderInput | MaterialUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutUploaderInput | MaterialUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type ExerciseUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ExerciseCreateWithoutCreatorInput, ExerciseUncheckedCreateWithoutCreatorInput> | ExerciseCreateWithoutCreatorInput[] | ExerciseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutCreatorInput | ExerciseCreateOrConnectWithoutCreatorInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutCreatorInput | ExerciseUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ExerciseCreateManyCreatorInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutCreatorInput | ExerciseUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutCreatorInput | ExerciseUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type ExerciseSubmissionUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ExerciseSubmissionCreateWithoutStudentInput, ExerciseSubmissionUncheckedCreateWithoutStudentInput> | ExerciseSubmissionCreateWithoutStudentInput[] | ExerciseSubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ExerciseSubmissionCreateOrConnectWithoutStudentInput | ExerciseSubmissionCreateOrConnectWithoutStudentInput[]
    upsert?: ExerciseSubmissionUpsertWithWhereUniqueWithoutStudentInput | ExerciseSubmissionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ExerciseSubmissionCreateManyStudentInputEnvelope
    set?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    disconnect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    delete?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    connect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    update?: ExerciseSubmissionUpdateWithWhereUniqueWithoutStudentInput | ExerciseSubmissionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ExerciseSubmissionUpdateManyWithWhereWithoutStudentInput | ExerciseSubmissionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ExerciseSubmissionScalarWhereInput | ExerciseSubmissionScalarWhereInput[]
  }

  export type QuizUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<QuizCreateWithoutCreatorInput, QuizUncheckedCreateWithoutCreatorInput> | QuizCreateWithoutCreatorInput[] | QuizUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutCreatorInput | QuizCreateOrConnectWithoutCreatorInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutCreatorInput | QuizUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: QuizCreateManyCreatorInputEnvelope
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutCreatorInput | QuizUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutCreatorInput | QuizUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type QuizAttemptUpdateManyWithoutStudentNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutStudentInput, QuizAttemptUncheckedCreateWithoutStudentInput> | QuizAttemptCreateWithoutStudentInput[] | QuizAttemptUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutStudentInput | QuizAttemptCreateOrConnectWithoutStudentInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutStudentInput | QuizAttemptUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: QuizAttemptCreateManyStudentInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutStudentInput | QuizAttemptUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutStudentInput | QuizAttemptUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type MediaUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<MediaCreateWithoutUploaderInput, MediaUncheckedCreateWithoutUploaderInput> | MediaCreateWithoutUploaderInput[] | MediaUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutUploaderInput | MediaCreateOrConnectWithoutUploaderInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutUploaderInput | MediaUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: MediaCreateManyUploaderInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutUploaderInput | MediaUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutUploaderInput | MediaUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type ClassroomUncheckedUpdateManyWithoutTutorNestedInput = {
    create?: XOR<ClassroomCreateWithoutTutorInput, ClassroomUncheckedCreateWithoutTutorInput> | ClassroomCreateWithoutTutorInput[] | ClassroomUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutTutorInput | ClassroomCreateOrConnectWithoutTutorInput[]
    upsert?: ClassroomUpsertWithWhereUniqueWithoutTutorInput | ClassroomUpsertWithWhereUniqueWithoutTutorInput[]
    createMany?: ClassroomCreateManyTutorInputEnvelope
    set?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    disconnect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    delete?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    update?: ClassroomUpdateWithWhereUniqueWithoutTutorInput | ClassroomUpdateWithWhereUniqueWithoutTutorInput[]
    updateMany?: ClassroomUpdateManyWithWhereWithoutTutorInput | ClassroomUpdateManyWithWhereWithoutTutorInput[]
    deleteMany?: ClassroomScalarWhereInput | ClassroomScalarWhereInput[]
  }

  export type ClassroomUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ClassroomCreateWithoutCreatorInput, ClassroomUncheckedCreateWithoutCreatorInput> | ClassroomCreateWithoutCreatorInput[] | ClassroomUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutCreatorInput | ClassroomCreateOrConnectWithoutCreatorInput[]
    upsert?: ClassroomUpsertWithWhereUniqueWithoutCreatorInput | ClassroomUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ClassroomCreateManyCreatorInputEnvelope
    set?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    disconnect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    delete?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    update?: ClassroomUpdateWithWhereUniqueWithoutCreatorInput | ClassroomUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ClassroomUpdateManyWithWhereWithoutCreatorInput | ClassroomUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ClassroomScalarWhereInput | ClassroomScalarWhereInput[]
  }

  export type ClassroomStudentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ClassroomStudentCreateWithoutStudentInput, ClassroomStudentUncheckedCreateWithoutStudentInput> | ClassroomStudentCreateWithoutStudentInput[] | ClassroomStudentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ClassroomStudentCreateOrConnectWithoutStudentInput | ClassroomStudentCreateOrConnectWithoutStudentInput[]
    upsert?: ClassroomStudentUpsertWithWhereUniqueWithoutStudentInput | ClassroomStudentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ClassroomStudentCreateManyStudentInputEnvelope
    set?: ClassroomStudentWhereUniqueInput | ClassroomStudentWhereUniqueInput[]
    disconnect?: ClassroomStudentWhereUniqueInput | ClassroomStudentWhereUniqueInput[]
    delete?: ClassroomStudentWhereUniqueInput | ClassroomStudentWhereUniqueInput[]
    connect?: ClassroomStudentWhereUniqueInput | ClassroomStudentWhereUniqueInput[]
    update?: ClassroomStudentUpdateWithWhereUniqueWithoutStudentInput | ClassroomStudentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ClassroomStudentUpdateManyWithWhereWithoutStudentInput | ClassroomStudentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ClassroomStudentScalarWhereInput | ClassroomStudentScalarWhereInput[]
  }

  export type JoinRequestUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<JoinRequestCreateWithoutStudentInput, JoinRequestUncheckedCreateWithoutStudentInput> | JoinRequestCreateWithoutStudentInput[] | JoinRequestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: JoinRequestCreateOrConnectWithoutStudentInput | JoinRequestCreateOrConnectWithoutStudentInput[]
    upsert?: JoinRequestUpsertWithWhereUniqueWithoutStudentInput | JoinRequestUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: JoinRequestCreateManyStudentInputEnvelope
    set?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
    disconnect?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
    delete?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
    connect?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
    update?: JoinRequestUpdateWithWhereUniqueWithoutStudentInput | JoinRequestUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: JoinRequestUpdateManyWithWhereWithoutStudentInput | JoinRequestUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: JoinRequestScalarWhereInput | JoinRequestScalarWhereInput[]
  }

  export type MaterialUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<MaterialCreateWithoutUploaderInput, MaterialUncheckedCreateWithoutUploaderInput> | MaterialCreateWithoutUploaderInput[] | MaterialUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutUploaderInput | MaterialCreateOrConnectWithoutUploaderInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutUploaderInput | MaterialUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: MaterialCreateManyUploaderInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutUploaderInput | MaterialUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutUploaderInput | MaterialUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type ExerciseUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ExerciseCreateWithoutCreatorInput, ExerciseUncheckedCreateWithoutCreatorInput> | ExerciseCreateWithoutCreatorInput[] | ExerciseUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutCreatorInput | ExerciseCreateOrConnectWithoutCreatorInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutCreatorInput | ExerciseUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ExerciseCreateManyCreatorInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutCreatorInput | ExerciseUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutCreatorInput | ExerciseUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type ExerciseSubmissionUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ExerciseSubmissionCreateWithoutStudentInput, ExerciseSubmissionUncheckedCreateWithoutStudentInput> | ExerciseSubmissionCreateWithoutStudentInput[] | ExerciseSubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ExerciseSubmissionCreateOrConnectWithoutStudentInput | ExerciseSubmissionCreateOrConnectWithoutStudentInput[]
    upsert?: ExerciseSubmissionUpsertWithWhereUniqueWithoutStudentInput | ExerciseSubmissionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ExerciseSubmissionCreateManyStudentInputEnvelope
    set?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    disconnect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    delete?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    connect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    update?: ExerciseSubmissionUpdateWithWhereUniqueWithoutStudentInput | ExerciseSubmissionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ExerciseSubmissionUpdateManyWithWhereWithoutStudentInput | ExerciseSubmissionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ExerciseSubmissionScalarWhereInput | ExerciseSubmissionScalarWhereInput[]
  }

  export type QuizUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<QuizCreateWithoutCreatorInput, QuizUncheckedCreateWithoutCreatorInput> | QuizCreateWithoutCreatorInput[] | QuizUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutCreatorInput | QuizCreateOrConnectWithoutCreatorInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutCreatorInput | QuizUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: QuizCreateManyCreatorInputEnvelope
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutCreatorInput | QuizUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutCreatorInput | QuizUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type QuizAttemptUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutStudentInput, QuizAttemptUncheckedCreateWithoutStudentInput> | QuizAttemptCreateWithoutStudentInput[] | QuizAttemptUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutStudentInput | QuizAttemptCreateOrConnectWithoutStudentInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutStudentInput | QuizAttemptUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: QuizAttemptCreateManyStudentInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutStudentInput | QuizAttemptUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutStudentInput | QuizAttemptUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTaughtClassroomsInput = {
    create?: XOR<UserCreateWithoutTaughtClassroomsInput, UserUncheckedCreateWithoutTaughtClassroomsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaughtClassroomsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedClassroomsInput = {
    create?: XOR<UserCreateWithoutCreatedClassroomsInput, UserUncheckedCreateWithoutCreatedClassroomsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedClassroomsInput
    connect?: UserWhereUniqueInput
  }

  export type MediaCreateNestedOneWithoutClassroomCoversInput = {
    create?: XOR<MediaCreateWithoutClassroomCoversInput, MediaUncheckedCreateWithoutClassroomCoversInput>
    connectOrCreate?: MediaCreateOrConnectWithoutClassroomCoversInput
    connect?: MediaWhereUniqueInput
  }

  export type ClassroomStudentCreateNestedManyWithoutClassroomInput = {
    create?: XOR<ClassroomStudentCreateWithoutClassroomInput, ClassroomStudentUncheckedCreateWithoutClassroomInput> | ClassroomStudentCreateWithoutClassroomInput[] | ClassroomStudentUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: ClassroomStudentCreateOrConnectWithoutClassroomInput | ClassroomStudentCreateOrConnectWithoutClassroomInput[]
    createMany?: ClassroomStudentCreateManyClassroomInputEnvelope
    connect?: ClassroomStudentWhereUniqueInput | ClassroomStudentWhereUniqueInput[]
  }

  export type JoinRequestCreateNestedManyWithoutClassroomInput = {
    create?: XOR<JoinRequestCreateWithoutClassroomInput, JoinRequestUncheckedCreateWithoutClassroomInput> | JoinRequestCreateWithoutClassroomInput[] | JoinRequestUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: JoinRequestCreateOrConnectWithoutClassroomInput | JoinRequestCreateOrConnectWithoutClassroomInput[]
    createMany?: JoinRequestCreateManyClassroomInputEnvelope
    connect?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
  }

  export type LessonCreateNestedManyWithoutClassroomInput = {
    create?: XOR<LessonCreateWithoutClassroomInput, LessonUncheckedCreateWithoutClassroomInput> | LessonCreateWithoutClassroomInput[] | LessonUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutClassroomInput | LessonCreateOrConnectWithoutClassroomInput[]
    createMany?: LessonCreateManyClassroomInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type ClassroomStudentUncheckedCreateNestedManyWithoutClassroomInput = {
    create?: XOR<ClassroomStudentCreateWithoutClassroomInput, ClassroomStudentUncheckedCreateWithoutClassroomInput> | ClassroomStudentCreateWithoutClassroomInput[] | ClassroomStudentUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: ClassroomStudentCreateOrConnectWithoutClassroomInput | ClassroomStudentCreateOrConnectWithoutClassroomInput[]
    createMany?: ClassroomStudentCreateManyClassroomInputEnvelope
    connect?: ClassroomStudentWhereUniqueInput | ClassroomStudentWhereUniqueInput[]
  }

  export type JoinRequestUncheckedCreateNestedManyWithoutClassroomInput = {
    create?: XOR<JoinRequestCreateWithoutClassroomInput, JoinRequestUncheckedCreateWithoutClassroomInput> | JoinRequestCreateWithoutClassroomInput[] | JoinRequestUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: JoinRequestCreateOrConnectWithoutClassroomInput | JoinRequestCreateOrConnectWithoutClassroomInput[]
    createMany?: JoinRequestCreateManyClassroomInputEnvelope
    connect?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
  }

  export type LessonUncheckedCreateNestedManyWithoutClassroomInput = {
    create?: XOR<LessonCreateWithoutClassroomInput, LessonUncheckedCreateWithoutClassroomInput> | LessonCreateWithoutClassroomInput[] | LessonUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutClassroomInput | LessonCreateOrConnectWithoutClassroomInput[]
    createMany?: LessonCreateManyClassroomInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutTaughtClassroomsNestedInput = {
    create?: XOR<UserCreateWithoutTaughtClassroomsInput, UserUncheckedCreateWithoutTaughtClassroomsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaughtClassroomsInput
    upsert?: UserUpsertWithoutTaughtClassroomsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTaughtClassroomsInput, UserUpdateWithoutTaughtClassroomsInput>, UserUncheckedUpdateWithoutTaughtClassroomsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedClassroomsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedClassroomsInput, UserUncheckedCreateWithoutCreatedClassroomsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedClassroomsInput
    upsert?: UserUpsertWithoutCreatedClassroomsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedClassroomsInput, UserUpdateWithoutCreatedClassroomsInput>, UserUncheckedUpdateWithoutCreatedClassroomsInput>
  }

  export type MediaUpdateOneWithoutClassroomCoversNestedInput = {
    create?: XOR<MediaCreateWithoutClassroomCoversInput, MediaUncheckedCreateWithoutClassroomCoversInput>
    connectOrCreate?: MediaCreateOrConnectWithoutClassroomCoversInput
    upsert?: MediaUpsertWithoutClassroomCoversInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutClassroomCoversInput, MediaUpdateWithoutClassroomCoversInput>, MediaUncheckedUpdateWithoutClassroomCoversInput>
  }

  export type ClassroomStudentUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<ClassroomStudentCreateWithoutClassroomInput, ClassroomStudentUncheckedCreateWithoutClassroomInput> | ClassroomStudentCreateWithoutClassroomInput[] | ClassroomStudentUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: ClassroomStudentCreateOrConnectWithoutClassroomInput | ClassroomStudentCreateOrConnectWithoutClassroomInput[]
    upsert?: ClassroomStudentUpsertWithWhereUniqueWithoutClassroomInput | ClassroomStudentUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: ClassroomStudentCreateManyClassroomInputEnvelope
    set?: ClassroomStudentWhereUniqueInput | ClassroomStudentWhereUniqueInput[]
    disconnect?: ClassroomStudentWhereUniqueInput | ClassroomStudentWhereUniqueInput[]
    delete?: ClassroomStudentWhereUniqueInput | ClassroomStudentWhereUniqueInput[]
    connect?: ClassroomStudentWhereUniqueInput | ClassroomStudentWhereUniqueInput[]
    update?: ClassroomStudentUpdateWithWhereUniqueWithoutClassroomInput | ClassroomStudentUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: ClassroomStudentUpdateManyWithWhereWithoutClassroomInput | ClassroomStudentUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: ClassroomStudentScalarWhereInput | ClassroomStudentScalarWhereInput[]
  }

  export type JoinRequestUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<JoinRequestCreateWithoutClassroomInput, JoinRequestUncheckedCreateWithoutClassroomInput> | JoinRequestCreateWithoutClassroomInput[] | JoinRequestUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: JoinRequestCreateOrConnectWithoutClassroomInput | JoinRequestCreateOrConnectWithoutClassroomInput[]
    upsert?: JoinRequestUpsertWithWhereUniqueWithoutClassroomInput | JoinRequestUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: JoinRequestCreateManyClassroomInputEnvelope
    set?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
    disconnect?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
    delete?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
    connect?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
    update?: JoinRequestUpdateWithWhereUniqueWithoutClassroomInput | JoinRequestUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: JoinRequestUpdateManyWithWhereWithoutClassroomInput | JoinRequestUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: JoinRequestScalarWhereInput | JoinRequestScalarWhereInput[]
  }

  export type LessonUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<LessonCreateWithoutClassroomInput, LessonUncheckedCreateWithoutClassroomInput> | LessonCreateWithoutClassroomInput[] | LessonUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutClassroomInput | LessonCreateOrConnectWithoutClassroomInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutClassroomInput | LessonUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: LessonCreateManyClassroomInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutClassroomInput | LessonUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutClassroomInput | LessonUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type ClassroomStudentUncheckedUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<ClassroomStudentCreateWithoutClassroomInput, ClassroomStudentUncheckedCreateWithoutClassroomInput> | ClassroomStudentCreateWithoutClassroomInput[] | ClassroomStudentUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: ClassroomStudentCreateOrConnectWithoutClassroomInput | ClassroomStudentCreateOrConnectWithoutClassroomInput[]
    upsert?: ClassroomStudentUpsertWithWhereUniqueWithoutClassroomInput | ClassroomStudentUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: ClassroomStudentCreateManyClassroomInputEnvelope
    set?: ClassroomStudentWhereUniqueInput | ClassroomStudentWhereUniqueInput[]
    disconnect?: ClassroomStudentWhereUniqueInput | ClassroomStudentWhereUniqueInput[]
    delete?: ClassroomStudentWhereUniqueInput | ClassroomStudentWhereUniqueInput[]
    connect?: ClassroomStudentWhereUniqueInput | ClassroomStudentWhereUniqueInput[]
    update?: ClassroomStudentUpdateWithWhereUniqueWithoutClassroomInput | ClassroomStudentUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: ClassroomStudentUpdateManyWithWhereWithoutClassroomInput | ClassroomStudentUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: ClassroomStudentScalarWhereInput | ClassroomStudentScalarWhereInput[]
  }

  export type JoinRequestUncheckedUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<JoinRequestCreateWithoutClassroomInput, JoinRequestUncheckedCreateWithoutClassroomInput> | JoinRequestCreateWithoutClassroomInput[] | JoinRequestUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: JoinRequestCreateOrConnectWithoutClassroomInput | JoinRequestCreateOrConnectWithoutClassroomInput[]
    upsert?: JoinRequestUpsertWithWhereUniqueWithoutClassroomInput | JoinRequestUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: JoinRequestCreateManyClassroomInputEnvelope
    set?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
    disconnect?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
    delete?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
    connect?: JoinRequestWhereUniqueInput | JoinRequestWhereUniqueInput[]
    update?: JoinRequestUpdateWithWhereUniqueWithoutClassroomInput | JoinRequestUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: JoinRequestUpdateManyWithWhereWithoutClassroomInput | JoinRequestUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: JoinRequestScalarWhereInput | JoinRequestScalarWhereInput[]
  }

  export type LessonUncheckedUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<LessonCreateWithoutClassroomInput, LessonUncheckedCreateWithoutClassroomInput> | LessonCreateWithoutClassroomInput[] | LessonUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutClassroomInput | LessonCreateOrConnectWithoutClassroomInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutClassroomInput | LessonUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: LessonCreateManyClassroomInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutClassroomInput | LessonUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutClassroomInput | LessonUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type ClassroomCreateNestedOneWithoutClassroomStudentsInput = {
    create?: XOR<ClassroomCreateWithoutClassroomStudentsInput, ClassroomUncheckedCreateWithoutClassroomStudentsInput>
    connectOrCreate?: ClassroomCreateOrConnectWithoutClassroomStudentsInput
    connect?: ClassroomWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClassroomStudentsInput = {
    create?: XOR<UserCreateWithoutClassroomStudentsInput, UserUncheckedCreateWithoutClassroomStudentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassroomStudentsInput
    connect?: UserWhereUniqueInput
  }

  export type ClassroomUpdateOneRequiredWithoutClassroomStudentsNestedInput = {
    create?: XOR<ClassroomCreateWithoutClassroomStudentsInput, ClassroomUncheckedCreateWithoutClassroomStudentsInput>
    connectOrCreate?: ClassroomCreateOrConnectWithoutClassroomStudentsInput
    upsert?: ClassroomUpsertWithoutClassroomStudentsInput
    connect?: ClassroomWhereUniqueInput
    update?: XOR<XOR<ClassroomUpdateToOneWithWhereWithoutClassroomStudentsInput, ClassroomUpdateWithoutClassroomStudentsInput>, ClassroomUncheckedUpdateWithoutClassroomStudentsInput>
  }

  export type UserUpdateOneRequiredWithoutClassroomStudentsNestedInput = {
    create?: XOR<UserCreateWithoutClassroomStudentsInput, UserUncheckedCreateWithoutClassroomStudentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassroomStudentsInput
    upsert?: UserUpsertWithoutClassroomStudentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClassroomStudentsInput, UserUpdateWithoutClassroomStudentsInput>, UserUncheckedUpdateWithoutClassroomStudentsInput>
  }

  export type ClassroomCreateNestedOneWithoutJoinRequestsInput = {
    create?: XOR<ClassroomCreateWithoutJoinRequestsInput, ClassroomUncheckedCreateWithoutJoinRequestsInput>
    connectOrCreate?: ClassroomCreateOrConnectWithoutJoinRequestsInput
    connect?: ClassroomWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutJoinRequestsInput = {
    create?: XOR<UserCreateWithoutJoinRequestsInput, UserUncheckedCreateWithoutJoinRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutJoinRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type ClassroomUpdateOneRequiredWithoutJoinRequestsNestedInput = {
    create?: XOR<ClassroomCreateWithoutJoinRequestsInput, ClassroomUncheckedCreateWithoutJoinRequestsInput>
    connectOrCreate?: ClassroomCreateOrConnectWithoutJoinRequestsInput
    upsert?: ClassroomUpsertWithoutJoinRequestsInput
    connect?: ClassroomWhereUniqueInput
    update?: XOR<XOR<ClassroomUpdateToOneWithWhereWithoutJoinRequestsInput, ClassroomUpdateWithoutJoinRequestsInput>, ClassroomUncheckedUpdateWithoutJoinRequestsInput>
  }

  export type UserUpdateOneRequiredWithoutJoinRequestsNestedInput = {
    create?: XOR<UserCreateWithoutJoinRequestsInput, UserUncheckedCreateWithoutJoinRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutJoinRequestsInput
    upsert?: UserUpsertWithoutJoinRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutJoinRequestsInput, UserUpdateWithoutJoinRequestsInput>, UserUncheckedUpdateWithoutJoinRequestsInput>
  }

  export type ClassroomCreateNestedOneWithoutLessonsInput = {
    create?: XOR<ClassroomCreateWithoutLessonsInput, ClassroomUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: ClassroomCreateOrConnectWithoutLessonsInput
    connect?: ClassroomWhereUniqueInput
  }

  export type MaterialCreateNestedManyWithoutLessonInput = {
    create?: XOR<MaterialCreateWithoutLessonInput, MaterialUncheckedCreateWithoutLessonInput> | MaterialCreateWithoutLessonInput[] | MaterialUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutLessonInput | MaterialCreateOrConnectWithoutLessonInput[]
    createMany?: MaterialCreateManyLessonInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type ExerciseCreateNestedManyWithoutLessonInput = {
    create?: XOR<ExerciseCreateWithoutLessonInput, ExerciseUncheckedCreateWithoutLessonInput> | ExerciseCreateWithoutLessonInput[] | ExerciseUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutLessonInput | ExerciseCreateOrConnectWithoutLessonInput[]
    createMany?: ExerciseCreateManyLessonInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type QuizCreateNestedManyWithoutLessonInput = {
    create?: XOR<QuizCreateWithoutLessonInput, QuizUncheckedCreateWithoutLessonInput> | QuizCreateWithoutLessonInput[] | QuizUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutLessonInput | QuizCreateOrConnectWithoutLessonInput[]
    createMany?: QuizCreateManyLessonInputEnvelope
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type LessonCreateNestedOneWithoutSubLessonsInput = {
    create?: XOR<LessonCreateWithoutSubLessonsInput, LessonUncheckedCreateWithoutSubLessonsInput>
    connectOrCreate?: LessonCreateOrConnectWithoutSubLessonsInput
    connect?: LessonWhereUniqueInput
  }

  export type LessonCreateNestedManyWithoutParentInput = {
    create?: XOR<LessonCreateWithoutParentInput, LessonUncheckedCreateWithoutParentInput> | LessonCreateWithoutParentInput[] | LessonUncheckedCreateWithoutParentInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutParentInput | LessonCreateOrConnectWithoutParentInput[]
    createMany?: LessonCreateManyParentInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type MaterialUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<MaterialCreateWithoutLessonInput, MaterialUncheckedCreateWithoutLessonInput> | MaterialCreateWithoutLessonInput[] | MaterialUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutLessonInput | MaterialCreateOrConnectWithoutLessonInput[]
    createMany?: MaterialCreateManyLessonInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type ExerciseUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<ExerciseCreateWithoutLessonInput, ExerciseUncheckedCreateWithoutLessonInput> | ExerciseCreateWithoutLessonInput[] | ExerciseUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutLessonInput | ExerciseCreateOrConnectWithoutLessonInput[]
    createMany?: ExerciseCreateManyLessonInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type QuizUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<QuizCreateWithoutLessonInput, QuizUncheckedCreateWithoutLessonInput> | QuizCreateWithoutLessonInput[] | QuizUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutLessonInput | QuizCreateOrConnectWithoutLessonInput[]
    createMany?: QuizCreateManyLessonInputEnvelope
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type LessonUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<LessonCreateWithoutParentInput, LessonUncheckedCreateWithoutParentInput> | LessonCreateWithoutParentInput[] | LessonUncheckedCreateWithoutParentInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutParentInput | LessonCreateOrConnectWithoutParentInput[]
    createMany?: LessonCreateManyParentInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type EnumLessonTypeFieldUpdateOperationsInput = {
    set?: $Enums.LessonType
  }

  export type ClassroomUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<ClassroomCreateWithoutLessonsInput, ClassroomUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: ClassroomCreateOrConnectWithoutLessonsInput
    upsert?: ClassroomUpsertWithoutLessonsInput
    connect?: ClassroomWhereUniqueInput
    update?: XOR<XOR<ClassroomUpdateToOneWithWhereWithoutLessonsInput, ClassroomUpdateWithoutLessonsInput>, ClassroomUncheckedUpdateWithoutLessonsInput>
  }

  export type MaterialUpdateManyWithoutLessonNestedInput = {
    create?: XOR<MaterialCreateWithoutLessonInput, MaterialUncheckedCreateWithoutLessonInput> | MaterialCreateWithoutLessonInput[] | MaterialUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutLessonInput | MaterialCreateOrConnectWithoutLessonInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutLessonInput | MaterialUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: MaterialCreateManyLessonInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutLessonInput | MaterialUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutLessonInput | MaterialUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type ExerciseUpdateManyWithoutLessonNestedInput = {
    create?: XOR<ExerciseCreateWithoutLessonInput, ExerciseUncheckedCreateWithoutLessonInput> | ExerciseCreateWithoutLessonInput[] | ExerciseUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutLessonInput | ExerciseCreateOrConnectWithoutLessonInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutLessonInput | ExerciseUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: ExerciseCreateManyLessonInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutLessonInput | ExerciseUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutLessonInput | ExerciseUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type QuizUpdateManyWithoutLessonNestedInput = {
    create?: XOR<QuizCreateWithoutLessonInput, QuizUncheckedCreateWithoutLessonInput> | QuizCreateWithoutLessonInput[] | QuizUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutLessonInput | QuizCreateOrConnectWithoutLessonInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutLessonInput | QuizUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: QuizCreateManyLessonInputEnvelope
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutLessonInput | QuizUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutLessonInput | QuizUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type LessonUpdateOneWithoutSubLessonsNestedInput = {
    create?: XOR<LessonCreateWithoutSubLessonsInput, LessonUncheckedCreateWithoutSubLessonsInput>
    connectOrCreate?: LessonCreateOrConnectWithoutSubLessonsInput
    upsert?: LessonUpsertWithoutSubLessonsInput
    disconnect?: LessonWhereInput | boolean
    delete?: LessonWhereInput | boolean
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutSubLessonsInput, LessonUpdateWithoutSubLessonsInput>, LessonUncheckedUpdateWithoutSubLessonsInput>
  }

  export type LessonUpdateManyWithoutParentNestedInput = {
    create?: XOR<LessonCreateWithoutParentInput, LessonUncheckedCreateWithoutParentInput> | LessonCreateWithoutParentInput[] | LessonUncheckedCreateWithoutParentInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutParentInput | LessonCreateOrConnectWithoutParentInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutParentInput | LessonUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: LessonCreateManyParentInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutParentInput | LessonUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutParentInput | LessonUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type MaterialUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<MaterialCreateWithoutLessonInput, MaterialUncheckedCreateWithoutLessonInput> | MaterialCreateWithoutLessonInput[] | MaterialUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutLessonInput | MaterialCreateOrConnectWithoutLessonInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutLessonInput | MaterialUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: MaterialCreateManyLessonInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutLessonInput | MaterialUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutLessonInput | MaterialUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type ExerciseUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<ExerciseCreateWithoutLessonInput, ExerciseUncheckedCreateWithoutLessonInput> | ExerciseCreateWithoutLessonInput[] | ExerciseUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutLessonInput | ExerciseCreateOrConnectWithoutLessonInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutLessonInput | ExerciseUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: ExerciseCreateManyLessonInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutLessonInput | ExerciseUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutLessonInput | ExerciseUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type QuizUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<QuizCreateWithoutLessonInput, QuizUncheckedCreateWithoutLessonInput> | QuizCreateWithoutLessonInput[] | QuizUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutLessonInput | QuizCreateOrConnectWithoutLessonInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutLessonInput | QuizUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: QuizCreateManyLessonInputEnvelope
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutLessonInput | QuizUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutLessonInput | QuizUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type LessonUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<LessonCreateWithoutParentInput, LessonUncheckedCreateWithoutParentInput> | LessonCreateWithoutParentInput[] | LessonUncheckedCreateWithoutParentInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutParentInput | LessonCreateOrConnectWithoutParentInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutParentInput | LessonUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: LessonCreateManyParentInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutParentInput | LessonUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutParentInput | LessonUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type LessonCreateNestedOneWithoutMaterialsInput = {
    create?: XOR<LessonCreateWithoutMaterialsInput, LessonUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: LessonCreateOrConnectWithoutMaterialsInput
    connect?: LessonWhereUniqueInput
  }

  export type MediaCreateNestedOneWithoutMaterialsInput = {
    create?: XOR<MediaCreateWithoutMaterialsInput, MediaUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutMaterialsInput
    connect?: MediaWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUploadedMaterialsInput = {
    create?: XOR<UserCreateWithoutUploadedMaterialsInput, UserUncheckedCreateWithoutUploadedMaterialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedMaterialsInput
    connect?: UserWhereUniqueInput
  }

  export type LessonUpdateOneWithoutMaterialsNestedInput = {
    create?: XOR<LessonCreateWithoutMaterialsInput, LessonUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: LessonCreateOrConnectWithoutMaterialsInput
    upsert?: LessonUpsertWithoutMaterialsInput
    disconnect?: LessonWhereInput | boolean
    delete?: LessonWhereInput | boolean
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutMaterialsInput, LessonUpdateWithoutMaterialsInput>, LessonUncheckedUpdateWithoutMaterialsInput>
  }

  export type MediaUpdateOneRequiredWithoutMaterialsNestedInput = {
    create?: XOR<MediaCreateWithoutMaterialsInput, MediaUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutMaterialsInput
    upsert?: MediaUpsertWithoutMaterialsInput
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutMaterialsInput, MediaUpdateWithoutMaterialsInput>, MediaUncheckedUpdateWithoutMaterialsInput>
  }

  export type UserUpdateOneRequiredWithoutUploadedMaterialsNestedInput = {
    create?: XOR<UserCreateWithoutUploadedMaterialsInput, UserUncheckedCreateWithoutUploadedMaterialsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedMaterialsInput
    upsert?: UserUpsertWithoutUploadedMaterialsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedMaterialsInput, UserUpdateWithoutUploadedMaterialsInput>, UserUncheckedUpdateWithoutUploadedMaterialsInput>
  }

  export type LessonCreateNestedOneWithoutExercisesInput = {
    create?: XOR<LessonCreateWithoutExercisesInput, LessonUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: LessonCreateOrConnectWithoutExercisesInput
    connect?: LessonWhereUniqueInput
  }

  export type MediaCreateNestedOneWithoutExerciseAttachmentsInput = {
    create?: XOR<MediaCreateWithoutExerciseAttachmentsInput, MediaUncheckedCreateWithoutExerciseAttachmentsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutExerciseAttachmentsInput
    connect?: MediaWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedExercisesInput = {
    create?: XOR<UserCreateWithoutCreatedExercisesInput, UserUncheckedCreateWithoutCreatedExercisesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedExercisesInput
    connect?: UserWhereUniqueInput
  }

  export type ExerciseSubmissionCreateNestedManyWithoutExerciseInput = {
    create?: XOR<ExerciseSubmissionCreateWithoutExerciseInput, ExerciseSubmissionUncheckedCreateWithoutExerciseInput> | ExerciseSubmissionCreateWithoutExerciseInput[] | ExerciseSubmissionUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExerciseSubmissionCreateOrConnectWithoutExerciseInput | ExerciseSubmissionCreateOrConnectWithoutExerciseInput[]
    createMany?: ExerciseSubmissionCreateManyExerciseInputEnvelope
    connect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
  }

  export type ExerciseSubmissionUncheckedCreateNestedManyWithoutExerciseInput = {
    create?: XOR<ExerciseSubmissionCreateWithoutExerciseInput, ExerciseSubmissionUncheckedCreateWithoutExerciseInput> | ExerciseSubmissionCreateWithoutExerciseInput[] | ExerciseSubmissionUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExerciseSubmissionCreateOrConnectWithoutExerciseInput | ExerciseSubmissionCreateOrConnectWithoutExerciseInput[]
    createMany?: ExerciseSubmissionCreateManyExerciseInputEnvelope
    connect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
  }

  export type LessonUpdateOneWithoutExercisesNestedInput = {
    create?: XOR<LessonCreateWithoutExercisesInput, LessonUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: LessonCreateOrConnectWithoutExercisesInput
    upsert?: LessonUpsertWithoutExercisesInput
    disconnect?: LessonWhereInput | boolean
    delete?: LessonWhereInput | boolean
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutExercisesInput, LessonUpdateWithoutExercisesInput>, LessonUncheckedUpdateWithoutExercisesInput>
  }

  export type MediaUpdateOneWithoutExerciseAttachmentsNestedInput = {
    create?: XOR<MediaCreateWithoutExerciseAttachmentsInput, MediaUncheckedCreateWithoutExerciseAttachmentsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutExerciseAttachmentsInput
    upsert?: MediaUpsertWithoutExerciseAttachmentsInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutExerciseAttachmentsInput, MediaUpdateWithoutExerciseAttachmentsInput>, MediaUncheckedUpdateWithoutExerciseAttachmentsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedExercisesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedExercisesInput, UserUncheckedCreateWithoutCreatedExercisesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedExercisesInput
    upsert?: UserUpsertWithoutCreatedExercisesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedExercisesInput, UserUpdateWithoutCreatedExercisesInput>, UserUncheckedUpdateWithoutCreatedExercisesInput>
  }

  export type ExerciseSubmissionUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<ExerciseSubmissionCreateWithoutExerciseInput, ExerciseSubmissionUncheckedCreateWithoutExerciseInput> | ExerciseSubmissionCreateWithoutExerciseInput[] | ExerciseSubmissionUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExerciseSubmissionCreateOrConnectWithoutExerciseInput | ExerciseSubmissionCreateOrConnectWithoutExerciseInput[]
    upsert?: ExerciseSubmissionUpsertWithWhereUniqueWithoutExerciseInput | ExerciseSubmissionUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: ExerciseSubmissionCreateManyExerciseInputEnvelope
    set?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    disconnect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    delete?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    connect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    update?: ExerciseSubmissionUpdateWithWhereUniqueWithoutExerciseInput | ExerciseSubmissionUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: ExerciseSubmissionUpdateManyWithWhereWithoutExerciseInput | ExerciseSubmissionUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: ExerciseSubmissionScalarWhereInput | ExerciseSubmissionScalarWhereInput[]
  }

  export type ExerciseSubmissionUncheckedUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<ExerciseSubmissionCreateWithoutExerciseInput, ExerciseSubmissionUncheckedCreateWithoutExerciseInput> | ExerciseSubmissionCreateWithoutExerciseInput[] | ExerciseSubmissionUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: ExerciseSubmissionCreateOrConnectWithoutExerciseInput | ExerciseSubmissionCreateOrConnectWithoutExerciseInput[]
    upsert?: ExerciseSubmissionUpsertWithWhereUniqueWithoutExerciseInput | ExerciseSubmissionUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: ExerciseSubmissionCreateManyExerciseInputEnvelope
    set?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    disconnect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    delete?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    connect?: ExerciseSubmissionWhereUniqueInput | ExerciseSubmissionWhereUniqueInput[]
    update?: ExerciseSubmissionUpdateWithWhereUniqueWithoutExerciseInput | ExerciseSubmissionUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: ExerciseSubmissionUpdateManyWithWhereWithoutExerciseInput | ExerciseSubmissionUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: ExerciseSubmissionScalarWhereInput | ExerciseSubmissionScalarWhereInput[]
  }

  export type ExerciseCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<ExerciseCreateWithoutSubmissionsInput, ExerciseUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutSubmissionsInput
    connect?: ExerciseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutExerciseSubmissionsInput = {
    create?: XOR<UserCreateWithoutExerciseSubmissionsInput, UserUncheckedCreateWithoutExerciseSubmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExerciseSubmissionsInput
    connect?: UserWhereUniqueInput
  }

  export type MediaCreateNestedOneWithoutExerciseSubmissionsInput = {
    create?: XOR<MediaCreateWithoutExerciseSubmissionsInput, MediaUncheckedCreateWithoutExerciseSubmissionsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutExerciseSubmissionsInput
    connect?: MediaWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ExerciseUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<ExerciseCreateWithoutSubmissionsInput, ExerciseUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutSubmissionsInput
    upsert?: ExerciseUpsertWithoutSubmissionsInput
    connect?: ExerciseWhereUniqueInput
    update?: XOR<XOR<ExerciseUpdateToOneWithWhereWithoutSubmissionsInput, ExerciseUpdateWithoutSubmissionsInput>, ExerciseUncheckedUpdateWithoutSubmissionsInput>
  }

  export type UserUpdateOneRequiredWithoutExerciseSubmissionsNestedInput = {
    create?: XOR<UserCreateWithoutExerciseSubmissionsInput, UserUncheckedCreateWithoutExerciseSubmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExerciseSubmissionsInput
    upsert?: UserUpsertWithoutExerciseSubmissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExerciseSubmissionsInput, UserUpdateWithoutExerciseSubmissionsInput>, UserUncheckedUpdateWithoutExerciseSubmissionsInput>
  }

  export type MediaUpdateOneRequiredWithoutExerciseSubmissionsNestedInput = {
    create?: XOR<MediaCreateWithoutExerciseSubmissionsInput, MediaUncheckedCreateWithoutExerciseSubmissionsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutExerciseSubmissionsInput
    upsert?: MediaUpsertWithoutExerciseSubmissionsInput
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutExerciseSubmissionsInput, MediaUpdateWithoutExerciseSubmissionsInput>, MediaUncheckedUpdateWithoutExerciseSubmissionsInput>
  }

  export type LessonCreateNestedOneWithoutQuizzesInput = {
    create?: XOR<LessonCreateWithoutQuizzesInput, LessonUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: LessonCreateOrConnectWithoutQuizzesInput
    connect?: LessonWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedQuizzesInput = {
    create?: XOR<UserCreateWithoutCreatedQuizzesInput, UserUncheckedCreateWithoutCreatedQuizzesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedQuizzesInput
    connect?: UserWhereUniqueInput
  }

  export type QuizSectionCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizSectionCreateWithoutQuizInput, QuizSectionUncheckedCreateWithoutQuizInput> | QuizSectionCreateWithoutQuizInput[] | QuizSectionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizSectionCreateOrConnectWithoutQuizInput | QuizSectionCreateOrConnectWithoutQuizInput[]
    createMany?: QuizSectionCreateManyQuizInputEnvelope
    connect?: QuizSectionWhereUniqueInput | QuizSectionWhereUniqueInput[]
  }

  export type QuizQuestionGroupCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizQuestionGroupCreateWithoutQuizInput, QuizQuestionGroupUncheckedCreateWithoutQuizInput> | QuizQuestionGroupCreateWithoutQuizInput[] | QuizQuestionGroupUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionGroupCreateOrConnectWithoutQuizInput | QuizQuestionGroupCreateOrConnectWithoutQuizInput[]
    createMany?: QuizQuestionGroupCreateManyQuizInputEnvelope
    connect?: QuizQuestionGroupWhereUniqueInput | QuizQuestionGroupWhereUniqueInput[]
  }

  export type QuizQuestionCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
  }

  export type QuizAttemptCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput> | QuizAttemptCreateWithoutQuizInput[] | QuizAttemptUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutQuizInput | QuizAttemptCreateOrConnectWithoutQuizInput[]
    createMany?: QuizAttemptCreateManyQuizInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type QuizSectionUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizSectionCreateWithoutQuizInput, QuizSectionUncheckedCreateWithoutQuizInput> | QuizSectionCreateWithoutQuizInput[] | QuizSectionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizSectionCreateOrConnectWithoutQuizInput | QuizSectionCreateOrConnectWithoutQuizInput[]
    createMany?: QuizSectionCreateManyQuizInputEnvelope
    connect?: QuizSectionWhereUniqueInput | QuizSectionWhereUniqueInput[]
  }

  export type QuizQuestionGroupUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizQuestionGroupCreateWithoutQuizInput, QuizQuestionGroupUncheckedCreateWithoutQuizInput> | QuizQuestionGroupCreateWithoutQuizInput[] | QuizQuestionGroupUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionGroupCreateOrConnectWithoutQuizInput | QuizQuestionGroupCreateOrConnectWithoutQuizInput[]
    createMany?: QuizQuestionGroupCreateManyQuizInputEnvelope
    connect?: QuizQuestionGroupWhereUniqueInput | QuizQuestionGroupWhereUniqueInput[]
  }

  export type QuizQuestionUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
  }

  export type QuizAttemptUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput> | QuizAttemptCreateWithoutQuizInput[] | QuizAttemptUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutQuizInput | QuizAttemptCreateOrConnectWithoutQuizInput[]
    createMany?: QuizAttemptCreateManyQuizInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type LessonUpdateOneRequiredWithoutQuizzesNestedInput = {
    create?: XOR<LessonCreateWithoutQuizzesInput, LessonUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: LessonCreateOrConnectWithoutQuizzesInput
    upsert?: LessonUpsertWithoutQuizzesInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutQuizzesInput, LessonUpdateWithoutQuizzesInput>, LessonUncheckedUpdateWithoutQuizzesInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedQuizzesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedQuizzesInput, UserUncheckedCreateWithoutCreatedQuizzesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedQuizzesInput
    upsert?: UserUpsertWithoutCreatedQuizzesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedQuizzesInput, UserUpdateWithoutCreatedQuizzesInput>, UserUncheckedUpdateWithoutCreatedQuizzesInput>
  }

  export type QuizSectionUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizSectionCreateWithoutQuizInput, QuizSectionUncheckedCreateWithoutQuizInput> | QuizSectionCreateWithoutQuizInput[] | QuizSectionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizSectionCreateOrConnectWithoutQuizInput | QuizSectionCreateOrConnectWithoutQuizInput[]
    upsert?: QuizSectionUpsertWithWhereUniqueWithoutQuizInput | QuizSectionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizSectionCreateManyQuizInputEnvelope
    set?: QuizSectionWhereUniqueInput | QuizSectionWhereUniqueInput[]
    disconnect?: QuizSectionWhereUniqueInput | QuizSectionWhereUniqueInput[]
    delete?: QuizSectionWhereUniqueInput | QuizSectionWhereUniqueInput[]
    connect?: QuizSectionWhereUniqueInput | QuizSectionWhereUniqueInput[]
    update?: QuizSectionUpdateWithWhereUniqueWithoutQuizInput | QuizSectionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizSectionUpdateManyWithWhereWithoutQuizInput | QuizSectionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizSectionScalarWhereInput | QuizSectionScalarWhereInput[]
  }

  export type QuizQuestionGroupUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizQuestionGroupCreateWithoutQuizInput, QuizQuestionGroupUncheckedCreateWithoutQuizInput> | QuizQuestionGroupCreateWithoutQuizInput[] | QuizQuestionGroupUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionGroupCreateOrConnectWithoutQuizInput | QuizQuestionGroupCreateOrConnectWithoutQuizInput[]
    upsert?: QuizQuestionGroupUpsertWithWhereUniqueWithoutQuizInput | QuizQuestionGroupUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizQuestionGroupCreateManyQuizInputEnvelope
    set?: QuizQuestionGroupWhereUniqueInput | QuizQuestionGroupWhereUniqueInput[]
    disconnect?: QuizQuestionGroupWhereUniqueInput | QuizQuestionGroupWhereUniqueInput[]
    delete?: QuizQuestionGroupWhereUniqueInput | QuizQuestionGroupWhereUniqueInput[]
    connect?: QuizQuestionGroupWhereUniqueInput | QuizQuestionGroupWhereUniqueInput[]
    update?: QuizQuestionGroupUpdateWithWhereUniqueWithoutQuizInput | QuizQuestionGroupUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizQuestionGroupUpdateManyWithWhereWithoutQuizInput | QuizQuestionGroupUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizQuestionGroupScalarWhereInput | QuizQuestionGroupScalarWhereInput[]
  }

  export type QuizQuestionUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    upsert?: QuizQuestionUpsertWithWhereUniqueWithoutQuizInput | QuizQuestionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    set?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    disconnect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    delete?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    update?: QuizQuestionUpdateWithWhereUniqueWithoutQuizInput | QuizQuestionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizQuestionUpdateManyWithWhereWithoutQuizInput | QuizQuestionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
  }

  export type QuizAttemptUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput> | QuizAttemptCreateWithoutQuizInput[] | QuizAttemptUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutQuizInput | QuizAttemptCreateOrConnectWithoutQuizInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutQuizInput | QuizAttemptUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizAttemptCreateManyQuizInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutQuizInput | QuizAttemptUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutQuizInput | QuizAttemptUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type QuizSectionUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizSectionCreateWithoutQuizInput, QuizSectionUncheckedCreateWithoutQuizInput> | QuizSectionCreateWithoutQuizInput[] | QuizSectionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizSectionCreateOrConnectWithoutQuizInput | QuizSectionCreateOrConnectWithoutQuizInput[]
    upsert?: QuizSectionUpsertWithWhereUniqueWithoutQuizInput | QuizSectionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizSectionCreateManyQuizInputEnvelope
    set?: QuizSectionWhereUniqueInput | QuizSectionWhereUniqueInput[]
    disconnect?: QuizSectionWhereUniqueInput | QuizSectionWhereUniqueInput[]
    delete?: QuizSectionWhereUniqueInput | QuizSectionWhereUniqueInput[]
    connect?: QuizSectionWhereUniqueInput | QuizSectionWhereUniqueInput[]
    update?: QuizSectionUpdateWithWhereUniqueWithoutQuizInput | QuizSectionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizSectionUpdateManyWithWhereWithoutQuizInput | QuizSectionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizSectionScalarWhereInput | QuizSectionScalarWhereInput[]
  }

  export type QuizQuestionGroupUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizQuestionGroupCreateWithoutQuizInput, QuizQuestionGroupUncheckedCreateWithoutQuizInput> | QuizQuestionGroupCreateWithoutQuizInput[] | QuizQuestionGroupUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionGroupCreateOrConnectWithoutQuizInput | QuizQuestionGroupCreateOrConnectWithoutQuizInput[]
    upsert?: QuizQuestionGroupUpsertWithWhereUniqueWithoutQuizInput | QuizQuestionGroupUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizQuestionGroupCreateManyQuizInputEnvelope
    set?: QuizQuestionGroupWhereUniqueInput | QuizQuestionGroupWhereUniqueInput[]
    disconnect?: QuizQuestionGroupWhereUniqueInput | QuizQuestionGroupWhereUniqueInput[]
    delete?: QuizQuestionGroupWhereUniqueInput | QuizQuestionGroupWhereUniqueInput[]
    connect?: QuizQuestionGroupWhereUniqueInput | QuizQuestionGroupWhereUniqueInput[]
    update?: QuizQuestionGroupUpdateWithWhereUniqueWithoutQuizInput | QuizQuestionGroupUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizQuestionGroupUpdateManyWithWhereWithoutQuizInput | QuizQuestionGroupUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizQuestionGroupScalarWhereInput | QuizQuestionGroupScalarWhereInput[]
  }

  export type QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    upsert?: QuizQuestionUpsertWithWhereUniqueWithoutQuizInput | QuizQuestionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    set?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    disconnect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    delete?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    update?: QuizQuestionUpdateWithWhereUniqueWithoutQuizInput | QuizQuestionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizQuestionUpdateManyWithWhereWithoutQuizInput | QuizQuestionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
  }

  export type QuizAttemptUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput> | QuizAttemptCreateWithoutQuizInput[] | QuizAttemptUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutQuizInput | QuizAttemptCreateOrConnectWithoutQuizInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutQuizInput | QuizAttemptUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizAttemptCreateManyQuizInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutQuizInput | QuizAttemptUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutQuizInput | QuizAttemptUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type QuizCreateNestedOneWithoutSectionsInput = {
    create?: XOR<QuizCreateWithoutSectionsInput, QuizUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutSectionsInput
    connect?: QuizWhereUniqueInput
  }

  export type QuizQuestionGroupCreateNestedManyWithoutSectionInput = {
    create?: XOR<QuizQuestionGroupCreateWithoutSectionInput, QuizQuestionGroupUncheckedCreateWithoutSectionInput> | QuizQuestionGroupCreateWithoutSectionInput[] | QuizQuestionGroupUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: QuizQuestionGroupCreateOrConnectWithoutSectionInput | QuizQuestionGroupCreateOrConnectWithoutSectionInput[]
    createMany?: QuizQuestionGroupCreateManySectionInputEnvelope
    connect?: QuizQuestionGroupWhereUniqueInput | QuizQuestionGroupWhereUniqueInput[]
  }

  export type QuizQuestionCreateNestedManyWithoutSectionInput = {
    create?: XOR<QuizQuestionCreateWithoutSectionInput, QuizQuestionUncheckedCreateWithoutSectionInput> | QuizQuestionCreateWithoutSectionInput[] | QuizQuestionUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutSectionInput | QuizQuestionCreateOrConnectWithoutSectionInput[]
    createMany?: QuizQuestionCreateManySectionInputEnvelope
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
  }

  export type QuizQuestionGroupUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<QuizQuestionGroupCreateWithoutSectionInput, QuizQuestionGroupUncheckedCreateWithoutSectionInput> | QuizQuestionGroupCreateWithoutSectionInput[] | QuizQuestionGroupUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: QuizQuestionGroupCreateOrConnectWithoutSectionInput | QuizQuestionGroupCreateOrConnectWithoutSectionInput[]
    createMany?: QuizQuestionGroupCreateManySectionInputEnvelope
    connect?: QuizQuestionGroupWhereUniqueInput | QuizQuestionGroupWhereUniqueInput[]
  }

  export type QuizQuestionUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<QuizQuestionCreateWithoutSectionInput, QuizQuestionUncheckedCreateWithoutSectionInput> | QuizQuestionCreateWithoutSectionInput[] | QuizQuestionUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutSectionInput | QuizQuestionCreateOrConnectWithoutSectionInput[]
    createMany?: QuizQuestionCreateManySectionInputEnvelope
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
  }

  export type QuizUpdateOneRequiredWithoutSectionsNestedInput = {
    create?: XOR<QuizCreateWithoutSectionsInput, QuizUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutSectionsInput
    upsert?: QuizUpsertWithoutSectionsInput
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutSectionsInput, QuizUpdateWithoutSectionsInput>, QuizUncheckedUpdateWithoutSectionsInput>
  }

  export type QuizQuestionGroupUpdateManyWithoutSectionNestedInput = {
    create?: XOR<QuizQuestionGroupCreateWithoutSectionInput, QuizQuestionGroupUncheckedCreateWithoutSectionInput> | QuizQuestionGroupCreateWithoutSectionInput[] | QuizQuestionGroupUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: QuizQuestionGroupCreateOrConnectWithoutSectionInput | QuizQuestionGroupCreateOrConnectWithoutSectionInput[]
    upsert?: QuizQuestionGroupUpsertWithWhereUniqueWithoutSectionInput | QuizQuestionGroupUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: QuizQuestionGroupCreateManySectionInputEnvelope
    set?: QuizQuestionGroupWhereUniqueInput | QuizQuestionGroupWhereUniqueInput[]
    disconnect?: QuizQuestionGroupWhereUniqueInput | QuizQuestionGroupWhereUniqueInput[]
    delete?: QuizQuestionGroupWhereUniqueInput | QuizQuestionGroupWhereUniqueInput[]
    connect?: QuizQuestionGroupWhereUniqueInput | QuizQuestionGroupWhereUniqueInput[]
    update?: QuizQuestionGroupUpdateWithWhereUniqueWithoutSectionInput | QuizQuestionGroupUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: QuizQuestionGroupUpdateManyWithWhereWithoutSectionInput | QuizQuestionGroupUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: QuizQuestionGroupScalarWhereInput | QuizQuestionGroupScalarWhereInput[]
  }

  export type QuizQuestionUpdateManyWithoutSectionNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutSectionInput, QuizQuestionUncheckedCreateWithoutSectionInput> | QuizQuestionCreateWithoutSectionInput[] | QuizQuestionUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutSectionInput | QuizQuestionCreateOrConnectWithoutSectionInput[]
    upsert?: QuizQuestionUpsertWithWhereUniqueWithoutSectionInput | QuizQuestionUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: QuizQuestionCreateManySectionInputEnvelope
    set?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    disconnect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    delete?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    update?: QuizQuestionUpdateWithWhereUniqueWithoutSectionInput | QuizQuestionUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: QuizQuestionUpdateManyWithWhereWithoutSectionInput | QuizQuestionUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
  }

  export type QuizQuestionGroupUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<QuizQuestionGroupCreateWithoutSectionInput, QuizQuestionGroupUncheckedCreateWithoutSectionInput> | QuizQuestionGroupCreateWithoutSectionInput[] | QuizQuestionGroupUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: QuizQuestionGroupCreateOrConnectWithoutSectionInput | QuizQuestionGroupCreateOrConnectWithoutSectionInput[]
    upsert?: QuizQuestionGroupUpsertWithWhereUniqueWithoutSectionInput | QuizQuestionGroupUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: QuizQuestionGroupCreateManySectionInputEnvelope
    set?: QuizQuestionGroupWhereUniqueInput | QuizQuestionGroupWhereUniqueInput[]
    disconnect?: QuizQuestionGroupWhereUniqueInput | QuizQuestionGroupWhereUniqueInput[]
    delete?: QuizQuestionGroupWhereUniqueInput | QuizQuestionGroupWhereUniqueInput[]
    connect?: QuizQuestionGroupWhereUniqueInput | QuizQuestionGroupWhereUniqueInput[]
    update?: QuizQuestionGroupUpdateWithWhereUniqueWithoutSectionInput | QuizQuestionGroupUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: QuizQuestionGroupUpdateManyWithWhereWithoutSectionInput | QuizQuestionGroupUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: QuizQuestionGroupScalarWhereInput | QuizQuestionGroupScalarWhereInput[]
  }

  export type QuizQuestionUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutSectionInput, QuizQuestionUncheckedCreateWithoutSectionInput> | QuizQuestionCreateWithoutSectionInput[] | QuizQuestionUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutSectionInput | QuizQuestionCreateOrConnectWithoutSectionInput[]
    upsert?: QuizQuestionUpsertWithWhereUniqueWithoutSectionInput | QuizQuestionUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: QuizQuestionCreateManySectionInputEnvelope
    set?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    disconnect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    delete?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    update?: QuizQuestionUpdateWithWhereUniqueWithoutSectionInput | QuizQuestionUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: QuizQuestionUpdateManyWithWhereWithoutSectionInput | QuizQuestionUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
  }

  export type QuizCreateNestedOneWithoutQuestionGroupsInput = {
    create?: XOR<QuizCreateWithoutQuestionGroupsInput, QuizUncheckedCreateWithoutQuestionGroupsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutQuestionGroupsInput
    connect?: QuizWhereUniqueInput
  }

  export type QuizSectionCreateNestedOneWithoutQuestionGroupsInput = {
    create?: XOR<QuizSectionCreateWithoutQuestionGroupsInput, QuizSectionUncheckedCreateWithoutQuestionGroupsInput>
    connectOrCreate?: QuizSectionCreateOrConnectWithoutQuestionGroupsInput
    connect?: QuizSectionWhereUniqueInput
  }

  export type QuizQuestionCreateNestedManyWithoutGroupInput = {
    create?: XOR<QuizQuestionCreateWithoutGroupInput, QuizQuestionUncheckedCreateWithoutGroupInput> | QuizQuestionCreateWithoutGroupInput[] | QuizQuestionUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutGroupInput | QuizQuestionCreateOrConnectWithoutGroupInput[]
    createMany?: QuizQuestionCreateManyGroupInputEnvelope
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
  }

  export type QuizQuestionGroupMediaCreateNestedManyWithoutGroupInput = {
    create?: XOR<QuizQuestionGroupMediaCreateWithoutGroupInput, QuizQuestionGroupMediaUncheckedCreateWithoutGroupInput> | QuizQuestionGroupMediaCreateWithoutGroupInput[] | QuizQuestionGroupMediaUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: QuizQuestionGroupMediaCreateOrConnectWithoutGroupInput | QuizQuestionGroupMediaCreateOrConnectWithoutGroupInput[]
    createMany?: QuizQuestionGroupMediaCreateManyGroupInputEnvelope
    connect?: QuizQuestionGroupMediaWhereUniqueInput | QuizQuestionGroupMediaWhereUniqueInput[]
  }

  export type QuizQuestionUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<QuizQuestionCreateWithoutGroupInput, QuizQuestionUncheckedCreateWithoutGroupInput> | QuizQuestionCreateWithoutGroupInput[] | QuizQuestionUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutGroupInput | QuizQuestionCreateOrConnectWithoutGroupInput[]
    createMany?: QuizQuestionCreateManyGroupInputEnvelope
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
  }

  export type QuizQuestionGroupMediaUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<QuizQuestionGroupMediaCreateWithoutGroupInput, QuizQuestionGroupMediaUncheckedCreateWithoutGroupInput> | QuizQuestionGroupMediaCreateWithoutGroupInput[] | QuizQuestionGroupMediaUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: QuizQuestionGroupMediaCreateOrConnectWithoutGroupInput | QuizQuestionGroupMediaCreateOrConnectWithoutGroupInput[]
    createMany?: QuizQuestionGroupMediaCreateManyGroupInputEnvelope
    connect?: QuizQuestionGroupMediaWhereUniqueInput | QuizQuestionGroupMediaWhereUniqueInput[]
  }

  export type QuizUpdateOneRequiredWithoutQuestionGroupsNestedInput = {
    create?: XOR<QuizCreateWithoutQuestionGroupsInput, QuizUncheckedCreateWithoutQuestionGroupsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutQuestionGroupsInput
    upsert?: QuizUpsertWithoutQuestionGroupsInput
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutQuestionGroupsInput, QuizUpdateWithoutQuestionGroupsInput>, QuizUncheckedUpdateWithoutQuestionGroupsInput>
  }

  export type QuizSectionUpdateOneWithoutQuestionGroupsNestedInput = {
    create?: XOR<QuizSectionCreateWithoutQuestionGroupsInput, QuizSectionUncheckedCreateWithoutQuestionGroupsInput>
    connectOrCreate?: QuizSectionCreateOrConnectWithoutQuestionGroupsInput
    upsert?: QuizSectionUpsertWithoutQuestionGroupsInput
    disconnect?: QuizSectionWhereInput | boolean
    delete?: QuizSectionWhereInput | boolean
    connect?: QuizSectionWhereUniqueInput
    update?: XOR<XOR<QuizSectionUpdateToOneWithWhereWithoutQuestionGroupsInput, QuizSectionUpdateWithoutQuestionGroupsInput>, QuizSectionUncheckedUpdateWithoutQuestionGroupsInput>
  }

  export type QuizQuestionUpdateManyWithoutGroupNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutGroupInput, QuizQuestionUncheckedCreateWithoutGroupInput> | QuizQuestionCreateWithoutGroupInput[] | QuizQuestionUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutGroupInput | QuizQuestionCreateOrConnectWithoutGroupInput[]
    upsert?: QuizQuestionUpsertWithWhereUniqueWithoutGroupInput | QuizQuestionUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: QuizQuestionCreateManyGroupInputEnvelope
    set?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    disconnect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    delete?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    update?: QuizQuestionUpdateWithWhereUniqueWithoutGroupInput | QuizQuestionUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: QuizQuestionUpdateManyWithWhereWithoutGroupInput | QuizQuestionUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
  }

  export type QuizQuestionGroupMediaUpdateManyWithoutGroupNestedInput = {
    create?: XOR<QuizQuestionGroupMediaCreateWithoutGroupInput, QuizQuestionGroupMediaUncheckedCreateWithoutGroupInput> | QuizQuestionGroupMediaCreateWithoutGroupInput[] | QuizQuestionGroupMediaUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: QuizQuestionGroupMediaCreateOrConnectWithoutGroupInput | QuizQuestionGroupMediaCreateOrConnectWithoutGroupInput[]
    upsert?: QuizQuestionGroupMediaUpsertWithWhereUniqueWithoutGroupInput | QuizQuestionGroupMediaUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: QuizQuestionGroupMediaCreateManyGroupInputEnvelope
    set?: QuizQuestionGroupMediaWhereUniqueInput | QuizQuestionGroupMediaWhereUniqueInput[]
    disconnect?: QuizQuestionGroupMediaWhereUniqueInput | QuizQuestionGroupMediaWhereUniqueInput[]
    delete?: QuizQuestionGroupMediaWhereUniqueInput | QuizQuestionGroupMediaWhereUniqueInput[]
    connect?: QuizQuestionGroupMediaWhereUniqueInput | QuizQuestionGroupMediaWhereUniqueInput[]
    update?: QuizQuestionGroupMediaUpdateWithWhereUniqueWithoutGroupInput | QuizQuestionGroupMediaUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: QuizQuestionGroupMediaUpdateManyWithWhereWithoutGroupInput | QuizQuestionGroupMediaUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: QuizQuestionGroupMediaScalarWhereInput | QuizQuestionGroupMediaScalarWhereInput[]
  }

  export type QuizQuestionUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutGroupInput, QuizQuestionUncheckedCreateWithoutGroupInput> | QuizQuestionCreateWithoutGroupInput[] | QuizQuestionUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutGroupInput | QuizQuestionCreateOrConnectWithoutGroupInput[]
    upsert?: QuizQuestionUpsertWithWhereUniqueWithoutGroupInput | QuizQuestionUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: QuizQuestionCreateManyGroupInputEnvelope
    set?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    disconnect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    delete?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    update?: QuizQuestionUpdateWithWhereUniqueWithoutGroupInput | QuizQuestionUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: QuizQuestionUpdateManyWithWhereWithoutGroupInput | QuizQuestionUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
  }

  export type QuizQuestionGroupMediaUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<QuizQuestionGroupMediaCreateWithoutGroupInput, QuizQuestionGroupMediaUncheckedCreateWithoutGroupInput> | QuizQuestionGroupMediaCreateWithoutGroupInput[] | QuizQuestionGroupMediaUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: QuizQuestionGroupMediaCreateOrConnectWithoutGroupInput | QuizQuestionGroupMediaCreateOrConnectWithoutGroupInput[]
    upsert?: QuizQuestionGroupMediaUpsertWithWhereUniqueWithoutGroupInput | QuizQuestionGroupMediaUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: QuizQuestionGroupMediaCreateManyGroupInputEnvelope
    set?: QuizQuestionGroupMediaWhereUniqueInput | QuizQuestionGroupMediaWhereUniqueInput[]
    disconnect?: QuizQuestionGroupMediaWhereUniqueInput | QuizQuestionGroupMediaWhereUniqueInput[]
    delete?: QuizQuestionGroupMediaWhereUniqueInput | QuizQuestionGroupMediaWhereUniqueInput[]
    connect?: QuizQuestionGroupMediaWhereUniqueInput | QuizQuestionGroupMediaWhereUniqueInput[]
    update?: QuizQuestionGroupMediaUpdateWithWhereUniqueWithoutGroupInput | QuizQuestionGroupMediaUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: QuizQuestionGroupMediaUpdateManyWithWhereWithoutGroupInput | QuizQuestionGroupMediaUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: QuizQuestionGroupMediaScalarWhereInput | QuizQuestionGroupMediaScalarWhereInput[]
  }

  export type QuizCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutQuestionsInput
    connect?: QuizWhereUniqueInput
  }

  export type QuizSectionCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<QuizSectionCreateWithoutQuestionsInput, QuizSectionUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizSectionCreateOrConnectWithoutQuestionsInput
    connect?: QuizSectionWhereUniqueInput
  }

  export type QuizQuestionGroupCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<QuizQuestionGroupCreateWithoutQuestionsInput, QuizQuestionGroupUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizQuestionGroupCreateOrConnectWithoutQuestionsInput
    connect?: QuizQuestionGroupWhereUniqueInput
  }

  export type QuizOptionCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuizOptionCreateWithoutQuestionInput, QuizOptionUncheckedCreateWithoutQuestionInput> | QuizOptionCreateWithoutQuestionInput[] | QuizOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizOptionCreateOrConnectWithoutQuestionInput | QuizOptionCreateOrConnectWithoutQuestionInput[]
    createMany?: QuizOptionCreateManyQuestionInputEnvelope
    connect?: QuizOptionWhereUniqueInput | QuizOptionWhereUniqueInput[]
  }

  export type QuizAnswerCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuizAnswerCreateWithoutQuestionInput, QuizAnswerUncheckedCreateWithoutQuestionInput> | QuizAnswerCreateWithoutQuestionInput[] | QuizAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutQuestionInput | QuizAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: QuizAnswerCreateManyQuestionInputEnvelope
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
  }

  export type QuizQuestionMediaCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuizQuestionMediaCreateWithoutQuestionInput, QuizQuestionMediaUncheckedCreateWithoutQuestionInput> | QuizQuestionMediaCreateWithoutQuestionInput[] | QuizQuestionMediaUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizQuestionMediaCreateOrConnectWithoutQuestionInput | QuizQuestionMediaCreateOrConnectWithoutQuestionInput[]
    createMany?: QuizQuestionMediaCreateManyQuestionInputEnvelope
    connect?: QuizQuestionMediaWhereUniqueInput | QuizQuestionMediaWhereUniqueInput[]
  }

  export type QuizOptionUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuizOptionCreateWithoutQuestionInput, QuizOptionUncheckedCreateWithoutQuestionInput> | QuizOptionCreateWithoutQuestionInput[] | QuizOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizOptionCreateOrConnectWithoutQuestionInput | QuizOptionCreateOrConnectWithoutQuestionInput[]
    createMany?: QuizOptionCreateManyQuestionInputEnvelope
    connect?: QuizOptionWhereUniqueInput | QuizOptionWhereUniqueInput[]
  }

  export type QuizAnswerUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuizAnswerCreateWithoutQuestionInput, QuizAnswerUncheckedCreateWithoutQuestionInput> | QuizAnswerCreateWithoutQuestionInput[] | QuizAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutQuestionInput | QuizAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: QuizAnswerCreateManyQuestionInputEnvelope
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
  }

  export type QuizQuestionMediaUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuizQuestionMediaCreateWithoutQuestionInput, QuizQuestionMediaUncheckedCreateWithoutQuestionInput> | QuizQuestionMediaCreateWithoutQuestionInput[] | QuizQuestionMediaUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizQuestionMediaCreateOrConnectWithoutQuestionInput | QuizQuestionMediaCreateOrConnectWithoutQuestionInput[]
    createMany?: QuizQuestionMediaCreateManyQuestionInputEnvelope
    connect?: QuizQuestionMediaWhereUniqueInput | QuizQuestionMediaWhereUniqueInput[]
  }

  export type QuizUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutQuestionsInput
    upsert?: QuizUpsertWithoutQuestionsInput
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutQuestionsInput, QuizUpdateWithoutQuestionsInput>, QuizUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuizSectionUpdateOneWithoutQuestionsNestedInput = {
    create?: XOR<QuizSectionCreateWithoutQuestionsInput, QuizSectionUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizSectionCreateOrConnectWithoutQuestionsInput
    upsert?: QuizSectionUpsertWithoutQuestionsInput
    disconnect?: QuizSectionWhereInput | boolean
    delete?: QuizSectionWhereInput | boolean
    connect?: QuizSectionWhereUniqueInput
    update?: XOR<XOR<QuizSectionUpdateToOneWithWhereWithoutQuestionsInput, QuizSectionUpdateWithoutQuestionsInput>, QuizSectionUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuizQuestionGroupUpdateOneWithoutQuestionsNestedInput = {
    create?: XOR<QuizQuestionGroupCreateWithoutQuestionsInput, QuizQuestionGroupUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizQuestionGroupCreateOrConnectWithoutQuestionsInput
    upsert?: QuizQuestionGroupUpsertWithoutQuestionsInput
    disconnect?: QuizQuestionGroupWhereInput | boolean
    delete?: QuizQuestionGroupWhereInput | boolean
    connect?: QuizQuestionGroupWhereUniqueInput
    update?: XOR<XOR<QuizQuestionGroupUpdateToOneWithWhereWithoutQuestionsInput, QuizQuestionGroupUpdateWithoutQuestionsInput>, QuizQuestionGroupUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuizOptionUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuizOptionCreateWithoutQuestionInput, QuizOptionUncheckedCreateWithoutQuestionInput> | QuizOptionCreateWithoutQuestionInput[] | QuizOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizOptionCreateOrConnectWithoutQuestionInput | QuizOptionCreateOrConnectWithoutQuestionInput[]
    upsert?: QuizOptionUpsertWithWhereUniqueWithoutQuestionInput | QuizOptionUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuizOptionCreateManyQuestionInputEnvelope
    set?: QuizOptionWhereUniqueInput | QuizOptionWhereUniqueInput[]
    disconnect?: QuizOptionWhereUniqueInput | QuizOptionWhereUniqueInput[]
    delete?: QuizOptionWhereUniqueInput | QuizOptionWhereUniqueInput[]
    connect?: QuizOptionWhereUniqueInput | QuizOptionWhereUniqueInput[]
    update?: QuizOptionUpdateWithWhereUniqueWithoutQuestionInput | QuizOptionUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuizOptionUpdateManyWithWhereWithoutQuestionInput | QuizOptionUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuizOptionScalarWhereInput | QuizOptionScalarWhereInput[]
  }

  export type QuizAnswerUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuizAnswerCreateWithoutQuestionInput, QuizAnswerUncheckedCreateWithoutQuestionInput> | QuizAnswerCreateWithoutQuestionInput[] | QuizAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutQuestionInput | QuizAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: QuizAnswerUpsertWithWhereUniqueWithoutQuestionInput | QuizAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuizAnswerCreateManyQuestionInputEnvelope
    set?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    disconnect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    delete?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    update?: QuizAnswerUpdateWithWhereUniqueWithoutQuestionInput | QuizAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuizAnswerUpdateManyWithWhereWithoutQuestionInput | QuizAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuizAnswerScalarWhereInput | QuizAnswerScalarWhereInput[]
  }

  export type QuizQuestionMediaUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuizQuestionMediaCreateWithoutQuestionInput, QuizQuestionMediaUncheckedCreateWithoutQuestionInput> | QuizQuestionMediaCreateWithoutQuestionInput[] | QuizQuestionMediaUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizQuestionMediaCreateOrConnectWithoutQuestionInput | QuizQuestionMediaCreateOrConnectWithoutQuestionInput[]
    upsert?: QuizQuestionMediaUpsertWithWhereUniqueWithoutQuestionInput | QuizQuestionMediaUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuizQuestionMediaCreateManyQuestionInputEnvelope
    set?: QuizQuestionMediaWhereUniqueInput | QuizQuestionMediaWhereUniqueInput[]
    disconnect?: QuizQuestionMediaWhereUniqueInput | QuizQuestionMediaWhereUniqueInput[]
    delete?: QuizQuestionMediaWhereUniqueInput | QuizQuestionMediaWhereUniqueInput[]
    connect?: QuizQuestionMediaWhereUniqueInput | QuizQuestionMediaWhereUniqueInput[]
    update?: QuizQuestionMediaUpdateWithWhereUniqueWithoutQuestionInput | QuizQuestionMediaUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuizQuestionMediaUpdateManyWithWhereWithoutQuestionInput | QuizQuestionMediaUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuizQuestionMediaScalarWhereInput | QuizQuestionMediaScalarWhereInput[]
  }

  export type QuizOptionUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuizOptionCreateWithoutQuestionInput, QuizOptionUncheckedCreateWithoutQuestionInput> | QuizOptionCreateWithoutQuestionInput[] | QuizOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizOptionCreateOrConnectWithoutQuestionInput | QuizOptionCreateOrConnectWithoutQuestionInput[]
    upsert?: QuizOptionUpsertWithWhereUniqueWithoutQuestionInput | QuizOptionUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuizOptionCreateManyQuestionInputEnvelope
    set?: QuizOptionWhereUniqueInput | QuizOptionWhereUniqueInput[]
    disconnect?: QuizOptionWhereUniqueInput | QuizOptionWhereUniqueInput[]
    delete?: QuizOptionWhereUniqueInput | QuizOptionWhereUniqueInput[]
    connect?: QuizOptionWhereUniqueInput | QuizOptionWhereUniqueInput[]
    update?: QuizOptionUpdateWithWhereUniqueWithoutQuestionInput | QuizOptionUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuizOptionUpdateManyWithWhereWithoutQuestionInput | QuizOptionUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuizOptionScalarWhereInput | QuizOptionScalarWhereInput[]
  }

  export type QuizAnswerUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuizAnswerCreateWithoutQuestionInput, QuizAnswerUncheckedCreateWithoutQuestionInput> | QuizAnswerCreateWithoutQuestionInput[] | QuizAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutQuestionInput | QuizAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: QuizAnswerUpsertWithWhereUniqueWithoutQuestionInput | QuizAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuizAnswerCreateManyQuestionInputEnvelope
    set?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    disconnect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    delete?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    update?: QuizAnswerUpdateWithWhereUniqueWithoutQuestionInput | QuizAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuizAnswerUpdateManyWithWhereWithoutQuestionInput | QuizAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuizAnswerScalarWhereInput | QuizAnswerScalarWhereInput[]
  }

  export type QuizQuestionMediaUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuizQuestionMediaCreateWithoutQuestionInput, QuizQuestionMediaUncheckedCreateWithoutQuestionInput> | QuizQuestionMediaCreateWithoutQuestionInput[] | QuizQuestionMediaUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizQuestionMediaCreateOrConnectWithoutQuestionInput | QuizQuestionMediaCreateOrConnectWithoutQuestionInput[]
    upsert?: QuizQuestionMediaUpsertWithWhereUniqueWithoutQuestionInput | QuizQuestionMediaUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuizQuestionMediaCreateManyQuestionInputEnvelope
    set?: QuizQuestionMediaWhereUniqueInput | QuizQuestionMediaWhereUniqueInput[]
    disconnect?: QuizQuestionMediaWhereUniqueInput | QuizQuestionMediaWhereUniqueInput[]
    delete?: QuizQuestionMediaWhereUniqueInput | QuizQuestionMediaWhereUniqueInput[]
    connect?: QuizQuestionMediaWhereUniqueInput | QuizQuestionMediaWhereUniqueInput[]
    update?: QuizQuestionMediaUpdateWithWhereUniqueWithoutQuestionInput | QuizQuestionMediaUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuizQuestionMediaUpdateManyWithWhereWithoutQuestionInput | QuizQuestionMediaUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuizQuestionMediaScalarWhereInput | QuizQuestionMediaScalarWhereInput[]
  }

  export type QuizQuestionCreateNestedOneWithoutOptionsInput = {
    create?: XOR<QuizQuestionCreateWithoutOptionsInput, QuizQuestionUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutOptionsInput
    connect?: QuizQuestionWhereUniqueInput
  }

  export type QuizAnswerCreateNestedManyWithoutOptionInput = {
    create?: XOR<QuizAnswerCreateWithoutOptionInput, QuizAnswerUncheckedCreateWithoutOptionInput> | QuizAnswerCreateWithoutOptionInput[] | QuizAnswerUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutOptionInput | QuizAnswerCreateOrConnectWithoutOptionInput[]
    createMany?: QuizAnswerCreateManyOptionInputEnvelope
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
  }

  export type QuizOptionMediaCreateNestedManyWithoutOptionInput = {
    create?: XOR<QuizOptionMediaCreateWithoutOptionInput, QuizOptionMediaUncheckedCreateWithoutOptionInput> | QuizOptionMediaCreateWithoutOptionInput[] | QuizOptionMediaUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: QuizOptionMediaCreateOrConnectWithoutOptionInput | QuizOptionMediaCreateOrConnectWithoutOptionInput[]
    createMany?: QuizOptionMediaCreateManyOptionInputEnvelope
    connect?: QuizOptionMediaWhereUniqueInput | QuizOptionMediaWhereUniqueInput[]
  }

  export type QuizAnswerUncheckedCreateNestedManyWithoutOptionInput = {
    create?: XOR<QuizAnswerCreateWithoutOptionInput, QuizAnswerUncheckedCreateWithoutOptionInput> | QuizAnswerCreateWithoutOptionInput[] | QuizAnswerUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutOptionInput | QuizAnswerCreateOrConnectWithoutOptionInput[]
    createMany?: QuizAnswerCreateManyOptionInputEnvelope
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
  }

  export type QuizOptionMediaUncheckedCreateNestedManyWithoutOptionInput = {
    create?: XOR<QuizOptionMediaCreateWithoutOptionInput, QuizOptionMediaUncheckedCreateWithoutOptionInput> | QuizOptionMediaCreateWithoutOptionInput[] | QuizOptionMediaUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: QuizOptionMediaCreateOrConnectWithoutOptionInput | QuizOptionMediaCreateOrConnectWithoutOptionInput[]
    createMany?: QuizOptionMediaCreateManyOptionInputEnvelope
    connect?: QuizOptionMediaWhereUniqueInput | QuizOptionMediaWhereUniqueInput[]
  }

  export type QuizQuestionUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutOptionsInput, QuizQuestionUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutOptionsInput
    upsert?: QuizQuestionUpsertWithoutOptionsInput
    connect?: QuizQuestionWhereUniqueInput
    update?: XOR<XOR<QuizQuestionUpdateToOneWithWhereWithoutOptionsInput, QuizQuestionUpdateWithoutOptionsInput>, QuizQuestionUncheckedUpdateWithoutOptionsInput>
  }

  export type QuizAnswerUpdateManyWithoutOptionNestedInput = {
    create?: XOR<QuizAnswerCreateWithoutOptionInput, QuizAnswerUncheckedCreateWithoutOptionInput> | QuizAnswerCreateWithoutOptionInput[] | QuizAnswerUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutOptionInput | QuizAnswerCreateOrConnectWithoutOptionInput[]
    upsert?: QuizAnswerUpsertWithWhereUniqueWithoutOptionInput | QuizAnswerUpsertWithWhereUniqueWithoutOptionInput[]
    createMany?: QuizAnswerCreateManyOptionInputEnvelope
    set?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    disconnect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    delete?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    update?: QuizAnswerUpdateWithWhereUniqueWithoutOptionInput | QuizAnswerUpdateWithWhereUniqueWithoutOptionInput[]
    updateMany?: QuizAnswerUpdateManyWithWhereWithoutOptionInput | QuizAnswerUpdateManyWithWhereWithoutOptionInput[]
    deleteMany?: QuizAnswerScalarWhereInput | QuizAnswerScalarWhereInput[]
  }

  export type QuizOptionMediaUpdateManyWithoutOptionNestedInput = {
    create?: XOR<QuizOptionMediaCreateWithoutOptionInput, QuizOptionMediaUncheckedCreateWithoutOptionInput> | QuizOptionMediaCreateWithoutOptionInput[] | QuizOptionMediaUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: QuizOptionMediaCreateOrConnectWithoutOptionInput | QuizOptionMediaCreateOrConnectWithoutOptionInput[]
    upsert?: QuizOptionMediaUpsertWithWhereUniqueWithoutOptionInput | QuizOptionMediaUpsertWithWhereUniqueWithoutOptionInput[]
    createMany?: QuizOptionMediaCreateManyOptionInputEnvelope
    set?: QuizOptionMediaWhereUniqueInput | QuizOptionMediaWhereUniqueInput[]
    disconnect?: QuizOptionMediaWhereUniqueInput | QuizOptionMediaWhereUniqueInput[]
    delete?: QuizOptionMediaWhereUniqueInput | QuizOptionMediaWhereUniqueInput[]
    connect?: QuizOptionMediaWhereUniqueInput | QuizOptionMediaWhereUniqueInput[]
    update?: QuizOptionMediaUpdateWithWhereUniqueWithoutOptionInput | QuizOptionMediaUpdateWithWhereUniqueWithoutOptionInput[]
    updateMany?: QuizOptionMediaUpdateManyWithWhereWithoutOptionInput | QuizOptionMediaUpdateManyWithWhereWithoutOptionInput[]
    deleteMany?: QuizOptionMediaScalarWhereInput | QuizOptionMediaScalarWhereInput[]
  }

  export type QuizAnswerUncheckedUpdateManyWithoutOptionNestedInput = {
    create?: XOR<QuizAnswerCreateWithoutOptionInput, QuizAnswerUncheckedCreateWithoutOptionInput> | QuizAnswerCreateWithoutOptionInput[] | QuizAnswerUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutOptionInput | QuizAnswerCreateOrConnectWithoutOptionInput[]
    upsert?: QuizAnswerUpsertWithWhereUniqueWithoutOptionInput | QuizAnswerUpsertWithWhereUniqueWithoutOptionInput[]
    createMany?: QuizAnswerCreateManyOptionInputEnvelope
    set?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    disconnect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    delete?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    update?: QuizAnswerUpdateWithWhereUniqueWithoutOptionInput | QuizAnswerUpdateWithWhereUniqueWithoutOptionInput[]
    updateMany?: QuizAnswerUpdateManyWithWhereWithoutOptionInput | QuizAnswerUpdateManyWithWhereWithoutOptionInput[]
    deleteMany?: QuizAnswerScalarWhereInput | QuizAnswerScalarWhereInput[]
  }

  export type QuizOptionMediaUncheckedUpdateManyWithoutOptionNestedInput = {
    create?: XOR<QuizOptionMediaCreateWithoutOptionInput, QuizOptionMediaUncheckedCreateWithoutOptionInput> | QuizOptionMediaCreateWithoutOptionInput[] | QuizOptionMediaUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: QuizOptionMediaCreateOrConnectWithoutOptionInput | QuizOptionMediaCreateOrConnectWithoutOptionInput[]
    upsert?: QuizOptionMediaUpsertWithWhereUniqueWithoutOptionInput | QuizOptionMediaUpsertWithWhereUniqueWithoutOptionInput[]
    createMany?: QuizOptionMediaCreateManyOptionInputEnvelope
    set?: QuizOptionMediaWhereUniqueInput | QuizOptionMediaWhereUniqueInput[]
    disconnect?: QuizOptionMediaWhereUniqueInput | QuizOptionMediaWhereUniqueInput[]
    delete?: QuizOptionMediaWhereUniqueInput | QuizOptionMediaWhereUniqueInput[]
    connect?: QuizOptionMediaWhereUniqueInput | QuizOptionMediaWhereUniqueInput[]
    update?: QuizOptionMediaUpdateWithWhereUniqueWithoutOptionInput | QuizOptionMediaUpdateWithWhereUniqueWithoutOptionInput[]
    updateMany?: QuizOptionMediaUpdateManyWithWhereWithoutOptionInput | QuizOptionMediaUpdateManyWithWhereWithoutOptionInput[]
    deleteMany?: QuizOptionMediaScalarWhereInput | QuizOptionMediaScalarWhereInput[]
  }

  export type QuizCreateNestedOneWithoutAttemptsInput = {
    create?: XOR<QuizCreateWithoutAttemptsInput, QuizUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutAttemptsInput
    connect?: QuizWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutQuizAttemptsInput = {
    create?: XOR<UserCreateWithoutQuizAttemptsInput, UserUncheckedCreateWithoutQuizAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuizAttemptsInput
    connect?: UserWhereUniqueInput
  }

  export type QuizAnswerCreateNestedManyWithoutAttemptInput = {
    create?: XOR<QuizAnswerCreateWithoutAttemptInput, QuizAnswerUncheckedCreateWithoutAttemptInput> | QuizAnswerCreateWithoutAttemptInput[] | QuizAnswerUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutAttemptInput | QuizAnswerCreateOrConnectWithoutAttemptInput[]
    createMany?: QuizAnswerCreateManyAttemptInputEnvelope
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
  }

  export type QuizAnswerUncheckedCreateNestedManyWithoutAttemptInput = {
    create?: XOR<QuizAnswerCreateWithoutAttemptInput, QuizAnswerUncheckedCreateWithoutAttemptInput> | QuizAnswerCreateWithoutAttemptInput[] | QuizAnswerUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutAttemptInput | QuizAnswerCreateOrConnectWithoutAttemptInput[]
    createMany?: QuizAnswerCreateManyAttemptInputEnvelope
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
  }

  export type QuizUpdateOneRequiredWithoutAttemptsNestedInput = {
    create?: XOR<QuizCreateWithoutAttemptsInput, QuizUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutAttemptsInput
    upsert?: QuizUpsertWithoutAttemptsInput
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutAttemptsInput, QuizUpdateWithoutAttemptsInput>, QuizUncheckedUpdateWithoutAttemptsInput>
  }

  export type UserUpdateOneRequiredWithoutQuizAttemptsNestedInput = {
    create?: XOR<UserCreateWithoutQuizAttemptsInput, UserUncheckedCreateWithoutQuizAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuizAttemptsInput
    upsert?: UserUpsertWithoutQuizAttemptsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuizAttemptsInput, UserUpdateWithoutQuizAttemptsInput>, UserUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type QuizAnswerUpdateManyWithoutAttemptNestedInput = {
    create?: XOR<QuizAnswerCreateWithoutAttemptInput, QuizAnswerUncheckedCreateWithoutAttemptInput> | QuizAnswerCreateWithoutAttemptInput[] | QuizAnswerUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutAttemptInput | QuizAnswerCreateOrConnectWithoutAttemptInput[]
    upsert?: QuizAnswerUpsertWithWhereUniqueWithoutAttemptInput | QuizAnswerUpsertWithWhereUniqueWithoutAttemptInput[]
    createMany?: QuizAnswerCreateManyAttemptInputEnvelope
    set?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    disconnect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    delete?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    update?: QuizAnswerUpdateWithWhereUniqueWithoutAttemptInput | QuizAnswerUpdateWithWhereUniqueWithoutAttemptInput[]
    updateMany?: QuizAnswerUpdateManyWithWhereWithoutAttemptInput | QuizAnswerUpdateManyWithWhereWithoutAttemptInput[]
    deleteMany?: QuizAnswerScalarWhereInput | QuizAnswerScalarWhereInput[]
  }

  export type QuizAnswerUncheckedUpdateManyWithoutAttemptNestedInput = {
    create?: XOR<QuizAnswerCreateWithoutAttemptInput, QuizAnswerUncheckedCreateWithoutAttemptInput> | QuizAnswerCreateWithoutAttemptInput[] | QuizAnswerUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: QuizAnswerCreateOrConnectWithoutAttemptInput | QuizAnswerCreateOrConnectWithoutAttemptInput[]
    upsert?: QuizAnswerUpsertWithWhereUniqueWithoutAttemptInput | QuizAnswerUpsertWithWhereUniqueWithoutAttemptInput[]
    createMany?: QuizAnswerCreateManyAttemptInputEnvelope
    set?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    disconnect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    delete?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    connect?: QuizAnswerWhereUniqueInput | QuizAnswerWhereUniqueInput[]
    update?: QuizAnswerUpdateWithWhereUniqueWithoutAttemptInput | QuizAnswerUpdateWithWhereUniqueWithoutAttemptInput[]
    updateMany?: QuizAnswerUpdateManyWithWhereWithoutAttemptInput | QuizAnswerUpdateManyWithWhereWithoutAttemptInput[]
    deleteMany?: QuizAnswerScalarWhereInput | QuizAnswerScalarWhereInput[]
  }

  export type QuizAttemptCreateNestedOneWithoutAnswersInput = {
    create?: XOR<QuizAttemptCreateWithoutAnswersInput, QuizAttemptUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutAnswersInput
    connect?: QuizAttemptWhereUniqueInput
  }

  export type QuizQuestionCreateNestedOneWithoutAnswersInput = {
    create?: XOR<QuizQuestionCreateWithoutAnswersInput, QuizQuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutAnswersInput
    connect?: QuizQuestionWhereUniqueInput
  }

  export type QuizOptionCreateNestedOneWithoutAnswersInput = {
    create?: XOR<QuizOptionCreateWithoutAnswersInput, QuizOptionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuizOptionCreateOrConnectWithoutAnswersInput
    connect?: QuizOptionWhereUniqueInput
  }

  export type QuizAttemptUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutAnswersInput, QuizAttemptUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutAnswersInput
    upsert?: QuizAttemptUpsertWithoutAnswersInput
    connect?: QuizAttemptWhereUniqueInput
    update?: XOR<XOR<QuizAttemptUpdateToOneWithWhereWithoutAnswersInput, QuizAttemptUpdateWithoutAnswersInput>, QuizAttemptUncheckedUpdateWithoutAnswersInput>
  }

  export type QuizQuestionUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutAnswersInput, QuizQuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutAnswersInput
    upsert?: QuizQuestionUpsertWithoutAnswersInput
    connect?: QuizQuestionWhereUniqueInput
    update?: XOR<XOR<QuizQuestionUpdateToOneWithWhereWithoutAnswersInput, QuizQuestionUpdateWithoutAnswersInput>, QuizQuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type QuizOptionUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<QuizOptionCreateWithoutAnswersInput, QuizOptionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuizOptionCreateOrConnectWithoutAnswersInput
    upsert?: QuizOptionUpsertWithoutAnswersInput
    connect?: QuizOptionWhereUniqueInput
    update?: XOR<XOR<QuizOptionUpdateToOneWithWhereWithoutAnswersInput, QuizOptionUpdateWithoutAnswersInput>, QuizOptionUncheckedUpdateWithoutAnswersInput>
  }

  export type QuizQuestionGroupCreateNestedOneWithoutMediasInput = {
    create?: XOR<QuizQuestionGroupCreateWithoutMediasInput, QuizQuestionGroupUncheckedCreateWithoutMediasInput>
    connectOrCreate?: QuizQuestionGroupCreateOrConnectWithoutMediasInput
    connect?: QuizQuestionGroupWhereUniqueInput
  }

  export type MediaCreateNestedOneWithoutQuizQuestionGroupMediasInput = {
    create?: XOR<MediaCreateWithoutQuizQuestionGroupMediasInput, MediaUncheckedCreateWithoutQuizQuestionGroupMediasInput>
    connectOrCreate?: MediaCreateOrConnectWithoutQuizQuestionGroupMediasInput
    connect?: MediaWhereUniqueInput
  }

  export type QuizQuestionGroupUpdateOneRequiredWithoutMediasNestedInput = {
    create?: XOR<QuizQuestionGroupCreateWithoutMediasInput, QuizQuestionGroupUncheckedCreateWithoutMediasInput>
    connectOrCreate?: QuizQuestionGroupCreateOrConnectWithoutMediasInput
    upsert?: QuizQuestionGroupUpsertWithoutMediasInput
    connect?: QuizQuestionGroupWhereUniqueInput
    update?: XOR<XOR<QuizQuestionGroupUpdateToOneWithWhereWithoutMediasInput, QuizQuestionGroupUpdateWithoutMediasInput>, QuizQuestionGroupUncheckedUpdateWithoutMediasInput>
  }

  export type MediaUpdateOneRequiredWithoutQuizQuestionGroupMediasNestedInput = {
    create?: XOR<MediaCreateWithoutQuizQuestionGroupMediasInput, MediaUncheckedCreateWithoutQuizQuestionGroupMediasInput>
    connectOrCreate?: MediaCreateOrConnectWithoutQuizQuestionGroupMediasInput
    upsert?: MediaUpsertWithoutQuizQuestionGroupMediasInput
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutQuizQuestionGroupMediasInput, MediaUpdateWithoutQuizQuestionGroupMediasInput>, MediaUncheckedUpdateWithoutQuizQuestionGroupMediasInput>
  }

  export type QuizQuestionCreateNestedOneWithoutMediasInput = {
    create?: XOR<QuizQuestionCreateWithoutMediasInput, QuizQuestionUncheckedCreateWithoutMediasInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutMediasInput
    connect?: QuizQuestionWhereUniqueInput
  }

  export type MediaCreateNestedOneWithoutQuizQuestionMediasInput = {
    create?: XOR<MediaCreateWithoutQuizQuestionMediasInput, MediaUncheckedCreateWithoutQuizQuestionMediasInput>
    connectOrCreate?: MediaCreateOrConnectWithoutQuizQuestionMediasInput
    connect?: MediaWhereUniqueInput
  }

  export type QuizQuestionUpdateOneRequiredWithoutMediasNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutMediasInput, QuizQuestionUncheckedCreateWithoutMediasInput>
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutMediasInput
    upsert?: QuizQuestionUpsertWithoutMediasInput
    connect?: QuizQuestionWhereUniqueInput
    update?: XOR<XOR<QuizQuestionUpdateToOneWithWhereWithoutMediasInput, QuizQuestionUpdateWithoutMediasInput>, QuizQuestionUncheckedUpdateWithoutMediasInput>
  }

  export type MediaUpdateOneRequiredWithoutQuizQuestionMediasNestedInput = {
    create?: XOR<MediaCreateWithoutQuizQuestionMediasInput, MediaUncheckedCreateWithoutQuizQuestionMediasInput>
    connectOrCreate?: MediaCreateOrConnectWithoutQuizQuestionMediasInput
    upsert?: MediaUpsertWithoutQuizQuestionMediasInput
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutQuizQuestionMediasInput, MediaUpdateWithoutQuizQuestionMediasInput>, MediaUncheckedUpdateWithoutQuizQuestionMediasInput>
  }

  export type QuizOptionCreateNestedOneWithoutMediasInput = {
    create?: XOR<QuizOptionCreateWithoutMediasInput, QuizOptionUncheckedCreateWithoutMediasInput>
    connectOrCreate?: QuizOptionCreateOrConnectWithoutMediasInput
    connect?: QuizOptionWhereUniqueInput
  }

  export type MediaCreateNestedOneWithoutQuizOptionMediasInput = {
    create?: XOR<MediaCreateWithoutQuizOptionMediasInput, MediaUncheckedCreateWithoutQuizOptionMediasInput>
    connectOrCreate?: MediaCreateOrConnectWithoutQuizOptionMediasInput
    connect?: MediaWhereUniqueInput
  }

  export type QuizOptionUpdateOneRequiredWithoutMediasNestedInput = {
    create?: XOR<QuizOptionCreateWithoutMediasInput, QuizOptionUncheckedCreateWithoutMediasInput>
    connectOrCreate?: QuizOptionCreateOrConnectWithoutMediasInput
    upsert?: QuizOptionUpsertWithoutMediasInput
    connect?: QuizOptionWhereUniqueInput
    update?: XOR<XOR<QuizOptionUpdateToOneWithWhereWithoutMediasInput, QuizOptionUpdateWithoutMediasInput>, QuizOptionUncheckedUpdateWithoutMediasInput>
  }

  export type MediaUpdateOneRequiredWithoutQuizOptionMediasNestedInput = {
    create?: XOR<MediaCreateWithoutQuizOptionMediasInput, MediaUncheckedCreateWithoutQuizOptionMediasInput>
    connectOrCreate?: MediaCreateOrConnectWithoutQuizOptionMediasInput
    upsert?: MediaUpsertWithoutQuizOptionMediasInput
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutQuizOptionMediasInput, MediaUpdateWithoutQuizOptionMediasInput>, MediaUncheckedUpdateWithoutQuizOptionMediasInput>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumLessonTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonType | EnumLessonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonTypeFilter<$PrismaModel> | $Enums.LessonType
  }

  export type NestedEnumLessonTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonType | EnumLessonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonTypeWithAggregatesFilter<$PrismaModel> | $Enums.LessonType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLessonTypeFilter<$PrismaModel>
    _max?: NestedEnumLessonTypeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type UserCreateWithoutRefreshTokensInput = {
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarMedia?: MediaCreateNestedOneWithoutUserAvatarsInput
    uploadedMedia?: MediaCreateNestedManyWithoutUploaderInput
    taughtClassrooms?: ClassroomCreateNestedManyWithoutTutorInput
    createdClassrooms?: ClassroomCreateNestedManyWithoutCreatorInput
    classroomStudents?: ClassroomStudentCreateNestedManyWithoutStudentInput
    joinRequests?: JoinRequestCreateNestedManyWithoutStudentInput
    uploadedMaterials?: MaterialCreateNestedManyWithoutUploaderInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    exerciseSubmissions?: ExerciseSubmissionCreateNestedManyWithoutStudentInput
    createdQuizzes?: QuizCreateNestedManyWithoutCreatorInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutStudentInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: number
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    avatarMediaId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedMedia?: MediaUncheckedCreateNestedManyWithoutUploaderInput
    taughtClassrooms?: ClassroomUncheckedCreateNestedManyWithoutTutorInput
    createdClassrooms?: ClassroomUncheckedCreateNestedManyWithoutCreatorInput
    classroomStudents?: ClassroomStudentUncheckedCreateNestedManyWithoutStudentInput
    joinRequests?: JoinRequestUncheckedCreateNestedManyWithoutStudentInput
    uploadedMaterials?: MaterialUncheckedCreateNestedManyWithoutUploaderInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutStudentInput
    createdQuizzes?: QuizUncheckedCreateNestedManyWithoutCreatorInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutStudentInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarMedia?: MediaUpdateOneWithoutUserAvatarsNestedInput
    uploadedMedia?: MediaUpdateManyWithoutUploaderNestedInput
    taughtClassrooms?: ClassroomUpdateManyWithoutTutorNestedInput
    createdClassrooms?: ClassroomUpdateManyWithoutCreatorNestedInput
    classroomStudents?: ClassroomStudentUpdateManyWithoutStudentNestedInput
    joinRequests?: JoinRequestUpdateManyWithoutStudentNestedInput
    uploadedMaterials?: MaterialUpdateManyWithoutUploaderNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    exerciseSubmissions?: ExerciseSubmissionUpdateManyWithoutStudentNestedInput
    createdQuizzes?: QuizUpdateManyWithoutCreatorNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutStudentNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatarMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedMedia?: MediaUncheckedUpdateManyWithoutUploaderNestedInput
    taughtClassrooms?: ClassroomUncheckedUpdateManyWithoutTutorNestedInput
    createdClassrooms?: ClassroomUncheckedUpdateManyWithoutCreatorNestedInput
    classroomStudents?: ClassroomStudentUncheckedUpdateManyWithoutStudentNestedInput
    joinRequests?: JoinRequestUncheckedUpdateManyWithoutStudentNestedInput
    uploadedMaterials?: MaterialUncheckedUpdateManyWithoutUploaderNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    createdQuizzes?: QuizUncheckedUpdateManyWithoutCreatorNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type UserCreateWithoutUploadedMediaInput = {
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarMedia?: MediaCreateNestedOneWithoutUserAvatarsInput
    taughtClassrooms?: ClassroomCreateNestedManyWithoutTutorInput
    createdClassrooms?: ClassroomCreateNestedManyWithoutCreatorInput
    classroomStudents?: ClassroomStudentCreateNestedManyWithoutStudentInput
    joinRequests?: JoinRequestCreateNestedManyWithoutStudentInput
    uploadedMaterials?: MaterialCreateNestedManyWithoutUploaderInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    exerciseSubmissions?: ExerciseSubmissionCreateNestedManyWithoutStudentInput
    createdQuizzes?: QuizCreateNestedManyWithoutCreatorInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutStudentInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUploadedMediaInput = {
    id?: number
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    avatarMediaId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    taughtClassrooms?: ClassroomUncheckedCreateNestedManyWithoutTutorInput
    createdClassrooms?: ClassroomUncheckedCreateNestedManyWithoutCreatorInput
    classroomStudents?: ClassroomStudentUncheckedCreateNestedManyWithoutStudentInput
    joinRequests?: JoinRequestUncheckedCreateNestedManyWithoutStudentInput
    uploadedMaterials?: MaterialUncheckedCreateNestedManyWithoutUploaderInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutStudentInput
    createdQuizzes?: QuizUncheckedCreateNestedManyWithoutCreatorInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutStudentInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUploadedMediaInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedMediaInput, UserUncheckedCreateWithoutUploadedMediaInput>
  }

  export type UserCreateWithoutAvatarMediaInput = {
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedMedia?: MediaCreateNestedManyWithoutUploaderInput
    taughtClassrooms?: ClassroomCreateNestedManyWithoutTutorInput
    createdClassrooms?: ClassroomCreateNestedManyWithoutCreatorInput
    classroomStudents?: ClassroomStudentCreateNestedManyWithoutStudentInput
    joinRequests?: JoinRequestCreateNestedManyWithoutStudentInput
    uploadedMaterials?: MaterialCreateNestedManyWithoutUploaderInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    exerciseSubmissions?: ExerciseSubmissionCreateNestedManyWithoutStudentInput
    createdQuizzes?: QuizCreateNestedManyWithoutCreatorInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutStudentInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAvatarMediaInput = {
    id?: number
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedMedia?: MediaUncheckedCreateNestedManyWithoutUploaderInput
    taughtClassrooms?: ClassroomUncheckedCreateNestedManyWithoutTutorInput
    createdClassrooms?: ClassroomUncheckedCreateNestedManyWithoutCreatorInput
    classroomStudents?: ClassroomStudentUncheckedCreateNestedManyWithoutStudentInput
    joinRequests?: JoinRequestUncheckedCreateNestedManyWithoutStudentInput
    uploadedMaterials?: MaterialUncheckedCreateNestedManyWithoutUploaderInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutStudentInput
    createdQuizzes?: QuizUncheckedCreateNestedManyWithoutCreatorInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutStudentInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAvatarMediaInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAvatarMediaInput, UserUncheckedCreateWithoutAvatarMediaInput>
  }

  export type UserCreateManyAvatarMediaInputEnvelope = {
    data: UserCreateManyAvatarMediaInput | UserCreateManyAvatarMediaInput[]
    skipDuplicates?: boolean
  }

  export type ClassroomCreateWithoutCoverMediaInput = {
    name: string
    description?: string | null
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tutor: UserCreateNestedOneWithoutTaughtClassroomsInput
    creator: UserCreateNestedOneWithoutCreatedClassroomsInput
    classroomStudents?: ClassroomStudentCreateNestedManyWithoutClassroomInput
    joinRequests?: JoinRequestCreateNestedManyWithoutClassroomInput
    lessons?: LessonCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomUncheckedCreateWithoutCoverMediaInput = {
    id?: number
    name: string
    description?: string | null
    tutorId: number
    isArchived?: boolean
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    classroomStudents?: ClassroomStudentUncheckedCreateNestedManyWithoutClassroomInput
    joinRequests?: JoinRequestUncheckedCreateNestedManyWithoutClassroomInput
    lessons?: LessonUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomCreateOrConnectWithoutCoverMediaInput = {
    where: ClassroomWhereUniqueInput
    create: XOR<ClassroomCreateWithoutCoverMediaInput, ClassroomUncheckedCreateWithoutCoverMediaInput>
  }

  export type ClassroomCreateManyCoverMediaInputEnvelope = {
    data: ClassroomCreateManyCoverMediaInput | ClassroomCreateManyCoverMediaInput[]
    skipDuplicates?: boolean
  }

  export type MaterialCreateWithoutMediaInput = {
    title: string
    uploadedAt?: Date | string
    lesson?: LessonCreateNestedOneWithoutMaterialsInput
    uploader: UserCreateNestedOneWithoutUploadedMaterialsInput
  }

  export type MaterialUncheckedCreateWithoutMediaInput = {
    id?: number
    lessonId: number
    title: string
    uploadedBy: number
    uploadedAt?: Date | string
  }

  export type MaterialCreateOrConnectWithoutMediaInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutMediaInput, MaterialUncheckedCreateWithoutMediaInput>
  }

  export type MaterialCreateManyMediaInputEnvelope = {
    data: MaterialCreateManyMediaInput | MaterialCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type ExerciseCreateWithoutAttachMediaInput = {
    title: string
    description?: string | null
    dueAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lesson?: LessonCreateNestedOneWithoutExercisesInput
    creator: UserCreateNestedOneWithoutCreatedExercisesInput
    submissions?: ExerciseSubmissionCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutAttachMediaInput = {
    id?: number
    lessonId: number
    title: string
    description?: string | null
    dueAt?: Date | string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    submissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutAttachMediaInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutAttachMediaInput, ExerciseUncheckedCreateWithoutAttachMediaInput>
  }

  export type ExerciseCreateManyAttachMediaInputEnvelope = {
    data: ExerciseCreateManyAttachMediaInput | ExerciseCreateManyAttachMediaInput[]
    skipDuplicates?: boolean
  }

  export type ExerciseSubmissionCreateWithoutMediaInput = {
    submittedAt?: Date | string
    score?: Decimal | DecimalJsLike | number | string | null
    comment?: string | null
    gradedAt?: Date | string | null
    exercise: ExerciseCreateNestedOneWithoutSubmissionsInput
    student: UserCreateNestedOneWithoutExerciseSubmissionsInput
  }

  export type ExerciseSubmissionUncheckedCreateWithoutMediaInput = {
    id?: number
    exerciseId: number
    studentId: number
    submittedAt?: Date | string
    score?: Decimal | DecimalJsLike | number | string | null
    comment?: string | null
    gradedAt?: Date | string | null
  }

  export type ExerciseSubmissionCreateOrConnectWithoutMediaInput = {
    where: ExerciseSubmissionWhereUniqueInput
    create: XOR<ExerciseSubmissionCreateWithoutMediaInput, ExerciseSubmissionUncheckedCreateWithoutMediaInput>
  }

  export type ExerciseSubmissionCreateManyMediaInputEnvelope = {
    data: ExerciseSubmissionCreateManyMediaInput | ExerciseSubmissionCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type QuizQuestionGroupMediaCreateWithoutMediaInput = {
    createdAt?: Date | string
    group: QuizQuestionGroupCreateNestedOneWithoutMediasInput
  }

  export type QuizQuestionGroupMediaUncheckedCreateWithoutMediaInput = {
    id?: number
    groupId: number
    createdAt?: Date | string
  }

  export type QuizQuestionGroupMediaCreateOrConnectWithoutMediaInput = {
    where: QuizQuestionGroupMediaWhereUniqueInput
    create: XOR<QuizQuestionGroupMediaCreateWithoutMediaInput, QuizQuestionGroupMediaUncheckedCreateWithoutMediaInput>
  }

  export type QuizQuestionGroupMediaCreateManyMediaInputEnvelope = {
    data: QuizQuestionGroupMediaCreateManyMediaInput | QuizQuestionGroupMediaCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type QuizQuestionMediaCreateWithoutMediaInput = {
    createdAt?: Date | string
    question: QuizQuestionCreateNestedOneWithoutMediasInput
  }

  export type QuizQuestionMediaUncheckedCreateWithoutMediaInput = {
    id?: number
    questionId: number
    createdAt?: Date | string
  }

  export type QuizQuestionMediaCreateOrConnectWithoutMediaInput = {
    where: QuizQuestionMediaWhereUniqueInput
    create: XOR<QuizQuestionMediaCreateWithoutMediaInput, QuizQuestionMediaUncheckedCreateWithoutMediaInput>
  }

  export type QuizQuestionMediaCreateManyMediaInputEnvelope = {
    data: QuizQuestionMediaCreateManyMediaInput | QuizQuestionMediaCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type QuizOptionMediaCreateWithoutMediaInput = {
    createdAt?: Date | string
    option: QuizOptionCreateNestedOneWithoutMediasInput
  }

  export type QuizOptionMediaUncheckedCreateWithoutMediaInput = {
    id?: number
    optionId: number
    createdAt?: Date | string
  }

  export type QuizOptionMediaCreateOrConnectWithoutMediaInput = {
    where: QuizOptionMediaWhereUniqueInput
    create: XOR<QuizOptionMediaCreateWithoutMediaInput, QuizOptionMediaUncheckedCreateWithoutMediaInput>
  }

  export type QuizOptionMediaCreateManyMediaInputEnvelope = {
    data: QuizOptionMediaCreateManyMediaInput | QuizOptionMediaCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutUploadedMediaInput = {
    update: XOR<UserUpdateWithoutUploadedMediaInput, UserUncheckedUpdateWithoutUploadedMediaInput>
    create: XOR<UserCreateWithoutUploadedMediaInput, UserUncheckedCreateWithoutUploadedMediaInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedMediaInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedMediaInput, UserUncheckedUpdateWithoutUploadedMediaInput>
  }

  export type UserUpdateWithoutUploadedMediaInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarMedia?: MediaUpdateOneWithoutUserAvatarsNestedInput
    taughtClassrooms?: ClassroomUpdateManyWithoutTutorNestedInput
    createdClassrooms?: ClassroomUpdateManyWithoutCreatorNestedInput
    classroomStudents?: ClassroomStudentUpdateManyWithoutStudentNestedInput
    joinRequests?: JoinRequestUpdateManyWithoutStudentNestedInput
    uploadedMaterials?: MaterialUpdateManyWithoutUploaderNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    exerciseSubmissions?: ExerciseSubmissionUpdateManyWithoutStudentNestedInput
    createdQuizzes?: QuizUpdateManyWithoutCreatorNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutStudentNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatarMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taughtClassrooms?: ClassroomUncheckedUpdateManyWithoutTutorNestedInput
    createdClassrooms?: ClassroomUncheckedUpdateManyWithoutCreatorNestedInput
    classroomStudents?: ClassroomStudentUncheckedUpdateManyWithoutStudentNestedInput
    joinRequests?: JoinRequestUncheckedUpdateManyWithoutStudentNestedInput
    uploadedMaterials?: MaterialUncheckedUpdateManyWithoutUploaderNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    createdQuizzes?: QuizUncheckedUpdateManyWithoutCreatorNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutStudentNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutAvatarMediaInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutAvatarMediaInput, UserUncheckedUpdateWithoutAvatarMediaInput>
    create: XOR<UserCreateWithoutAvatarMediaInput, UserUncheckedCreateWithoutAvatarMediaInput>
  }

  export type UserUpdateWithWhereUniqueWithoutAvatarMediaInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutAvatarMediaInput, UserUncheckedUpdateWithoutAvatarMediaInput>
  }

  export type UserUpdateManyWithWhereWithoutAvatarMediaInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutAvatarMediaInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    fullName?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    avatarMediaId?: IntNullableFilter<"User"> | number | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type ClassroomUpsertWithWhereUniqueWithoutCoverMediaInput = {
    where: ClassroomWhereUniqueInput
    update: XOR<ClassroomUpdateWithoutCoverMediaInput, ClassroomUncheckedUpdateWithoutCoverMediaInput>
    create: XOR<ClassroomCreateWithoutCoverMediaInput, ClassroomUncheckedCreateWithoutCoverMediaInput>
  }

  export type ClassroomUpdateWithWhereUniqueWithoutCoverMediaInput = {
    where: ClassroomWhereUniqueInput
    data: XOR<ClassroomUpdateWithoutCoverMediaInput, ClassroomUncheckedUpdateWithoutCoverMediaInput>
  }

  export type ClassroomUpdateManyWithWhereWithoutCoverMediaInput = {
    where: ClassroomScalarWhereInput
    data: XOR<ClassroomUpdateManyMutationInput, ClassroomUncheckedUpdateManyWithoutCoverMediaInput>
  }

  export type ClassroomScalarWhereInput = {
    AND?: ClassroomScalarWhereInput | ClassroomScalarWhereInput[]
    OR?: ClassroomScalarWhereInput[]
    NOT?: ClassroomScalarWhereInput | ClassroomScalarWhereInput[]
    id?: IntFilter<"Classroom"> | number
    name?: StringFilter<"Classroom"> | string
    description?: StringNullableFilter<"Classroom"> | string | null
    tutorId?: IntFilter<"Classroom"> | number
    coverMediaId?: IntNullableFilter<"Classroom"> | number | null
    isArchived?: BoolFilter<"Classroom"> | boolean
    createdBy?: IntFilter<"Classroom"> | number
    createdAt?: DateTimeFilter<"Classroom"> | Date | string
    updatedAt?: DateTimeFilter<"Classroom"> | Date | string
  }

  export type MaterialUpsertWithWhereUniqueWithoutMediaInput = {
    where: MaterialWhereUniqueInput
    update: XOR<MaterialUpdateWithoutMediaInput, MaterialUncheckedUpdateWithoutMediaInput>
    create: XOR<MaterialCreateWithoutMediaInput, MaterialUncheckedCreateWithoutMediaInput>
  }

  export type MaterialUpdateWithWhereUniqueWithoutMediaInput = {
    where: MaterialWhereUniqueInput
    data: XOR<MaterialUpdateWithoutMediaInput, MaterialUncheckedUpdateWithoutMediaInput>
  }

  export type MaterialUpdateManyWithWhereWithoutMediaInput = {
    where: MaterialScalarWhereInput
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyWithoutMediaInput>
  }

  export type MaterialScalarWhereInput = {
    AND?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
    OR?: MaterialScalarWhereInput[]
    NOT?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
    id?: IntFilter<"Material"> | number
    lessonId?: IntFilter<"Material"> | number
    title?: StringFilter<"Material"> | string
    mediaId?: IntFilter<"Material"> | number
    uploadedBy?: IntFilter<"Material"> | number
    uploadedAt?: DateTimeFilter<"Material"> | Date | string
  }

  export type ExerciseUpsertWithWhereUniqueWithoutAttachMediaInput = {
    where: ExerciseWhereUniqueInput
    update: XOR<ExerciseUpdateWithoutAttachMediaInput, ExerciseUncheckedUpdateWithoutAttachMediaInput>
    create: XOR<ExerciseCreateWithoutAttachMediaInput, ExerciseUncheckedCreateWithoutAttachMediaInput>
  }

  export type ExerciseUpdateWithWhereUniqueWithoutAttachMediaInput = {
    where: ExerciseWhereUniqueInput
    data: XOR<ExerciseUpdateWithoutAttachMediaInput, ExerciseUncheckedUpdateWithoutAttachMediaInput>
  }

  export type ExerciseUpdateManyWithWhereWithoutAttachMediaInput = {
    where: ExerciseScalarWhereInput
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyWithoutAttachMediaInput>
  }

  export type ExerciseScalarWhereInput = {
    AND?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
    OR?: ExerciseScalarWhereInput[]
    NOT?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
    id?: IntFilter<"Exercise"> | number
    lessonId?: IntFilter<"Exercise"> | number
    title?: StringFilter<"Exercise"> | string
    description?: StringNullableFilter<"Exercise"> | string | null
    attachMediaId?: IntNullableFilter<"Exercise"> | number | null
    dueAt?: DateTimeNullableFilter<"Exercise"> | Date | string | null
    createdBy?: IntFilter<"Exercise"> | number
    createdAt?: DateTimeFilter<"Exercise"> | Date | string
    updatedAt?: DateTimeFilter<"Exercise"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Exercise"> | Date | string | null
  }

  export type ExerciseSubmissionUpsertWithWhereUniqueWithoutMediaInput = {
    where: ExerciseSubmissionWhereUniqueInput
    update: XOR<ExerciseSubmissionUpdateWithoutMediaInput, ExerciseSubmissionUncheckedUpdateWithoutMediaInput>
    create: XOR<ExerciseSubmissionCreateWithoutMediaInput, ExerciseSubmissionUncheckedCreateWithoutMediaInput>
  }

  export type ExerciseSubmissionUpdateWithWhereUniqueWithoutMediaInput = {
    where: ExerciseSubmissionWhereUniqueInput
    data: XOR<ExerciseSubmissionUpdateWithoutMediaInput, ExerciseSubmissionUncheckedUpdateWithoutMediaInput>
  }

  export type ExerciseSubmissionUpdateManyWithWhereWithoutMediaInput = {
    where: ExerciseSubmissionScalarWhereInput
    data: XOR<ExerciseSubmissionUpdateManyMutationInput, ExerciseSubmissionUncheckedUpdateManyWithoutMediaInput>
  }

  export type ExerciseSubmissionScalarWhereInput = {
    AND?: ExerciseSubmissionScalarWhereInput | ExerciseSubmissionScalarWhereInput[]
    OR?: ExerciseSubmissionScalarWhereInput[]
    NOT?: ExerciseSubmissionScalarWhereInput | ExerciseSubmissionScalarWhereInput[]
    id?: IntFilter<"ExerciseSubmission"> | number
    exerciseId?: IntFilter<"ExerciseSubmission"> | number
    studentId?: IntFilter<"ExerciseSubmission"> | number
    mediaId?: IntFilter<"ExerciseSubmission"> | number
    submittedAt?: DateTimeFilter<"ExerciseSubmission"> | Date | string
    score?: DecimalNullableFilter<"ExerciseSubmission"> | Decimal | DecimalJsLike | number | string | null
    comment?: StringNullableFilter<"ExerciseSubmission"> | string | null
    gradedAt?: DateTimeNullableFilter<"ExerciseSubmission"> | Date | string | null
  }

  export type QuizQuestionGroupMediaUpsertWithWhereUniqueWithoutMediaInput = {
    where: QuizQuestionGroupMediaWhereUniqueInput
    update: XOR<QuizQuestionGroupMediaUpdateWithoutMediaInput, QuizQuestionGroupMediaUncheckedUpdateWithoutMediaInput>
    create: XOR<QuizQuestionGroupMediaCreateWithoutMediaInput, QuizQuestionGroupMediaUncheckedCreateWithoutMediaInput>
  }

  export type QuizQuestionGroupMediaUpdateWithWhereUniqueWithoutMediaInput = {
    where: QuizQuestionGroupMediaWhereUniqueInput
    data: XOR<QuizQuestionGroupMediaUpdateWithoutMediaInput, QuizQuestionGroupMediaUncheckedUpdateWithoutMediaInput>
  }

  export type QuizQuestionGroupMediaUpdateManyWithWhereWithoutMediaInput = {
    where: QuizQuestionGroupMediaScalarWhereInput
    data: XOR<QuizQuestionGroupMediaUpdateManyMutationInput, QuizQuestionGroupMediaUncheckedUpdateManyWithoutMediaInput>
  }

  export type QuizQuestionGroupMediaScalarWhereInput = {
    AND?: QuizQuestionGroupMediaScalarWhereInput | QuizQuestionGroupMediaScalarWhereInput[]
    OR?: QuizQuestionGroupMediaScalarWhereInput[]
    NOT?: QuizQuestionGroupMediaScalarWhereInput | QuizQuestionGroupMediaScalarWhereInput[]
    id?: IntFilter<"QuizQuestionGroupMedia"> | number
    groupId?: IntFilter<"QuizQuestionGroupMedia"> | number
    mediaId?: IntFilter<"QuizQuestionGroupMedia"> | number
    createdAt?: DateTimeFilter<"QuizQuestionGroupMedia"> | Date | string
  }

  export type QuizQuestionMediaUpsertWithWhereUniqueWithoutMediaInput = {
    where: QuizQuestionMediaWhereUniqueInput
    update: XOR<QuizQuestionMediaUpdateWithoutMediaInput, QuizQuestionMediaUncheckedUpdateWithoutMediaInput>
    create: XOR<QuizQuestionMediaCreateWithoutMediaInput, QuizQuestionMediaUncheckedCreateWithoutMediaInput>
  }

  export type QuizQuestionMediaUpdateWithWhereUniqueWithoutMediaInput = {
    where: QuizQuestionMediaWhereUniqueInput
    data: XOR<QuizQuestionMediaUpdateWithoutMediaInput, QuizQuestionMediaUncheckedUpdateWithoutMediaInput>
  }

  export type QuizQuestionMediaUpdateManyWithWhereWithoutMediaInput = {
    where: QuizQuestionMediaScalarWhereInput
    data: XOR<QuizQuestionMediaUpdateManyMutationInput, QuizQuestionMediaUncheckedUpdateManyWithoutMediaInput>
  }

  export type QuizQuestionMediaScalarWhereInput = {
    AND?: QuizQuestionMediaScalarWhereInput | QuizQuestionMediaScalarWhereInput[]
    OR?: QuizQuestionMediaScalarWhereInput[]
    NOT?: QuizQuestionMediaScalarWhereInput | QuizQuestionMediaScalarWhereInput[]
    id?: IntFilter<"QuizQuestionMedia"> | number
    questionId?: IntFilter<"QuizQuestionMedia"> | number
    mediaId?: IntFilter<"QuizQuestionMedia"> | number
    createdAt?: DateTimeFilter<"QuizQuestionMedia"> | Date | string
  }

  export type QuizOptionMediaUpsertWithWhereUniqueWithoutMediaInput = {
    where: QuizOptionMediaWhereUniqueInput
    update: XOR<QuizOptionMediaUpdateWithoutMediaInput, QuizOptionMediaUncheckedUpdateWithoutMediaInput>
    create: XOR<QuizOptionMediaCreateWithoutMediaInput, QuizOptionMediaUncheckedCreateWithoutMediaInput>
  }

  export type QuizOptionMediaUpdateWithWhereUniqueWithoutMediaInput = {
    where: QuizOptionMediaWhereUniqueInput
    data: XOR<QuizOptionMediaUpdateWithoutMediaInput, QuizOptionMediaUncheckedUpdateWithoutMediaInput>
  }

  export type QuizOptionMediaUpdateManyWithWhereWithoutMediaInput = {
    where: QuizOptionMediaScalarWhereInput
    data: XOR<QuizOptionMediaUpdateManyMutationInput, QuizOptionMediaUncheckedUpdateManyWithoutMediaInput>
  }

  export type QuizOptionMediaScalarWhereInput = {
    AND?: QuizOptionMediaScalarWhereInput | QuizOptionMediaScalarWhereInput[]
    OR?: QuizOptionMediaScalarWhereInput[]
    NOT?: QuizOptionMediaScalarWhereInput | QuizOptionMediaScalarWhereInput[]
    id?: IntFilter<"QuizOptionMedia"> | number
    optionId?: IntFilter<"QuizOptionMedia"> | number
    mediaId?: IntFilter<"QuizOptionMedia"> | number
    createdAt?: DateTimeFilter<"QuizOptionMedia"> | Date | string
  }

  export type MediaCreateWithoutUserAvatarsInput = {
    disk: string
    bucket?: string | null
    objectKey: string
    mimeType?: string | null
    sizeBytes?: bigint | number | null
    visibility?: string
    createdAt?: Date | string
    uploader?: UserCreateNestedOneWithoutUploadedMediaInput
    classroomCovers?: ClassroomCreateNestedManyWithoutCoverMediaInput
    materials?: MaterialCreateNestedManyWithoutMediaInput
    exerciseAttachments?: ExerciseCreateNestedManyWithoutAttachMediaInput
    exerciseSubmissions?: ExerciseSubmissionCreateNestedManyWithoutMediaInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaCreateNestedManyWithoutMediaInput
    quizQuestionMedias?: QuizQuestionMediaCreateNestedManyWithoutMediaInput
    quizOptionMedias?: QuizOptionMediaCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutUserAvatarsInput = {
    id?: number
    disk: string
    bucket?: string | null
    objectKey: string
    mimeType?: string | null
    sizeBytes?: bigint | number | null
    visibility?: string
    uploadedBy?: number | null
    createdAt?: Date | string
    classroomCovers?: ClassroomUncheckedCreateNestedManyWithoutCoverMediaInput
    materials?: MaterialUncheckedCreateNestedManyWithoutMediaInput
    exerciseAttachments?: ExerciseUncheckedCreateNestedManyWithoutAttachMediaInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutMediaInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaUncheckedCreateNestedManyWithoutMediaInput
    quizQuestionMedias?: QuizQuestionMediaUncheckedCreateNestedManyWithoutMediaInput
    quizOptionMedias?: QuizOptionMediaUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutUserAvatarsInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutUserAvatarsInput, MediaUncheckedCreateWithoutUserAvatarsInput>
  }

  export type MediaCreateWithoutUploaderInput = {
    disk: string
    bucket?: string | null
    objectKey: string
    mimeType?: string | null
    sizeBytes?: bigint | number | null
    visibility?: string
    createdAt?: Date | string
    userAvatars?: UserCreateNestedManyWithoutAvatarMediaInput
    classroomCovers?: ClassroomCreateNestedManyWithoutCoverMediaInput
    materials?: MaterialCreateNestedManyWithoutMediaInput
    exerciseAttachments?: ExerciseCreateNestedManyWithoutAttachMediaInput
    exerciseSubmissions?: ExerciseSubmissionCreateNestedManyWithoutMediaInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaCreateNestedManyWithoutMediaInput
    quizQuestionMedias?: QuizQuestionMediaCreateNestedManyWithoutMediaInput
    quizOptionMedias?: QuizOptionMediaCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutUploaderInput = {
    id?: number
    disk: string
    bucket?: string | null
    objectKey: string
    mimeType?: string | null
    sizeBytes?: bigint | number | null
    visibility?: string
    createdAt?: Date | string
    userAvatars?: UserUncheckedCreateNestedManyWithoutAvatarMediaInput
    classroomCovers?: ClassroomUncheckedCreateNestedManyWithoutCoverMediaInput
    materials?: MaterialUncheckedCreateNestedManyWithoutMediaInput
    exerciseAttachments?: ExerciseUncheckedCreateNestedManyWithoutAttachMediaInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutMediaInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaUncheckedCreateNestedManyWithoutMediaInput
    quizQuestionMedias?: QuizQuestionMediaUncheckedCreateNestedManyWithoutMediaInput
    quizOptionMedias?: QuizOptionMediaUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutUploaderInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutUploaderInput, MediaUncheckedCreateWithoutUploaderInput>
  }

  export type MediaCreateManyUploaderInputEnvelope = {
    data: MediaCreateManyUploaderInput | MediaCreateManyUploaderInput[]
    skipDuplicates?: boolean
  }

  export type ClassroomCreateWithoutTutorInput = {
    name: string
    description?: string | null
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedClassroomsInput
    coverMedia?: MediaCreateNestedOneWithoutClassroomCoversInput
    classroomStudents?: ClassroomStudentCreateNestedManyWithoutClassroomInput
    joinRequests?: JoinRequestCreateNestedManyWithoutClassroomInput
    lessons?: LessonCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomUncheckedCreateWithoutTutorInput = {
    id?: number
    name: string
    description?: string | null
    coverMediaId?: number | null
    isArchived?: boolean
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    classroomStudents?: ClassroomStudentUncheckedCreateNestedManyWithoutClassroomInput
    joinRequests?: JoinRequestUncheckedCreateNestedManyWithoutClassroomInput
    lessons?: LessonUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomCreateOrConnectWithoutTutorInput = {
    where: ClassroomWhereUniqueInput
    create: XOR<ClassroomCreateWithoutTutorInput, ClassroomUncheckedCreateWithoutTutorInput>
  }

  export type ClassroomCreateManyTutorInputEnvelope = {
    data: ClassroomCreateManyTutorInput | ClassroomCreateManyTutorInput[]
    skipDuplicates?: boolean
  }

  export type ClassroomCreateWithoutCreatorInput = {
    name: string
    description?: string | null
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tutor: UserCreateNestedOneWithoutTaughtClassroomsInput
    coverMedia?: MediaCreateNestedOneWithoutClassroomCoversInput
    classroomStudents?: ClassroomStudentCreateNestedManyWithoutClassroomInput
    joinRequests?: JoinRequestCreateNestedManyWithoutClassroomInput
    lessons?: LessonCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomUncheckedCreateWithoutCreatorInput = {
    id?: number
    name: string
    description?: string | null
    tutorId: number
    coverMediaId?: number | null
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    classroomStudents?: ClassroomStudentUncheckedCreateNestedManyWithoutClassroomInput
    joinRequests?: JoinRequestUncheckedCreateNestedManyWithoutClassroomInput
    lessons?: LessonUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomCreateOrConnectWithoutCreatorInput = {
    where: ClassroomWhereUniqueInput
    create: XOR<ClassroomCreateWithoutCreatorInput, ClassroomUncheckedCreateWithoutCreatorInput>
  }

  export type ClassroomCreateManyCreatorInputEnvelope = {
    data: ClassroomCreateManyCreatorInput | ClassroomCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ClassroomStudentCreateWithoutStudentInput = {
    joinedAt?: Date | string
    status?: number
    classroom: ClassroomCreateNestedOneWithoutClassroomStudentsInput
  }

  export type ClassroomStudentUncheckedCreateWithoutStudentInput = {
    classroomId: number
    joinedAt?: Date | string
    status?: number
  }

  export type ClassroomStudentCreateOrConnectWithoutStudentInput = {
    where: ClassroomStudentWhereUniqueInput
    create: XOR<ClassroomStudentCreateWithoutStudentInput, ClassroomStudentUncheckedCreateWithoutStudentInput>
  }

  export type ClassroomStudentCreateManyStudentInputEnvelope = {
    data: ClassroomStudentCreateManyStudentInput | ClassroomStudentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type JoinRequestCreateWithoutStudentInput = {
    status?: string
    requestedAt?: Date | string
    handledAt?: Date | string | null
    classroom: ClassroomCreateNestedOneWithoutJoinRequestsInput
  }

  export type JoinRequestUncheckedCreateWithoutStudentInput = {
    id?: number
    classroomId: number
    status?: string
    requestedAt?: Date | string
    handledAt?: Date | string | null
  }

  export type JoinRequestCreateOrConnectWithoutStudentInput = {
    where: JoinRequestWhereUniqueInput
    create: XOR<JoinRequestCreateWithoutStudentInput, JoinRequestUncheckedCreateWithoutStudentInput>
  }

  export type JoinRequestCreateManyStudentInputEnvelope = {
    data: JoinRequestCreateManyStudentInput | JoinRequestCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type MaterialCreateWithoutUploaderInput = {
    title: string
    uploadedAt?: Date | string
    lesson?: LessonCreateNestedOneWithoutMaterialsInput
    media: MediaCreateNestedOneWithoutMaterialsInput
  }

  export type MaterialUncheckedCreateWithoutUploaderInput = {
    id?: number
    lessonId: number
    title: string
    mediaId: number
    uploadedAt?: Date | string
  }

  export type MaterialCreateOrConnectWithoutUploaderInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutUploaderInput, MaterialUncheckedCreateWithoutUploaderInput>
  }

  export type MaterialCreateManyUploaderInputEnvelope = {
    data: MaterialCreateManyUploaderInput | MaterialCreateManyUploaderInput[]
    skipDuplicates?: boolean
  }

  export type ExerciseCreateWithoutCreatorInput = {
    title: string
    description?: string | null
    dueAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lesson?: LessonCreateNestedOneWithoutExercisesInput
    attachMedia?: MediaCreateNestedOneWithoutExerciseAttachmentsInput
    submissions?: ExerciseSubmissionCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutCreatorInput = {
    id?: number
    lessonId: number
    title: string
    description?: string | null
    attachMediaId?: number | null
    dueAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    submissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutCreatorInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutCreatorInput, ExerciseUncheckedCreateWithoutCreatorInput>
  }

  export type ExerciseCreateManyCreatorInputEnvelope = {
    data: ExerciseCreateManyCreatorInput | ExerciseCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ExerciseSubmissionCreateWithoutStudentInput = {
    submittedAt?: Date | string
    score?: Decimal | DecimalJsLike | number | string | null
    comment?: string | null
    gradedAt?: Date | string | null
    exercise: ExerciseCreateNestedOneWithoutSubmissionsInput
    media: MediaCreateNestedOneWithoutExerciseSubmissionsInput
  }

  export type ExerciseSubmissionUncheckedCreateWithoutStudentInput = {
    id?: number
    exerciseId: number
    mediaId: number
    submittedAt?: Date | string
    score?: Decimal | DecimalJsLike | number | string | null
    comment?: string | null
    gradedAt?: Date | string | null
  }

  export type ExerciseSubmissionCreateOrConnectWithoutStudentInput = {
    where: ExerciseSubmissionWhereUniqueInput
    create: XOR<ExerciseSubmissionCreateWithoutStudentInput, ExerciseSubmissionUncheckedCreateWithoutStudentInput>
  }

  export type ExerciseSubmissionCreateManyStudentInputEnvelope = {
    data: ExerciseSubmissionCreateManyStudentInput | ExerciseSubmissionCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type QuizCreateWithoutCreatorInput = {
    title: string
    description?: string | null
    timeLimitSec?: number | null
    maxAttempts?: number
    shuffleQuestions?: boolean
    shuffleOptions?: boolean
    gradingMethod?: string
    showAnswersAfter?: string
    dueAt?: Date | string | null
    isPublished?: boolean
    totalPoints?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lesson: LessonCreateNestedOneWithoutQuizzesInput
    sections?: QuizSectionCreateNestedManyWithoutQuizInput
    questionGroups?: QuizQuestionGroupCreateNestedManyWithoutQuizInput
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
    attempts?: QuizAttemptCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutCreatorInput = {
    id?: number
    lessonId: number
    title: string
    description?: string | null
    timeLimitSec?: number | null
    maxAttempts?: number
    shuffleQuestions?: boolean
    shuffleOptions?: boolean
    gradingMethod?: string
    showAnswersAfter?: string
    dueAt?: Date | string | null
    isPublished?: boolean
    totalPoints?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sections?: QuizSectionUncheckedCreateNestedManyWithoutQuizInput
    questionGroups?: QuizQuestionGroupUncheckedCreateNestedManyWithoutQuizInput
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutCreatorInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutCreatorInput, QuizUncheckedCreateWithoutCreatorInput>
  }

  export type QuizCreateManyCreatorInputEnvelope = {
    data: QuizCreateManyCreatorInput | QuizCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type QuizAttemptCreateWithoutStudentInput = {
    startedAt?: Date | string
    submittedAt?: Date | string | null
    status?: string
    scoreRaw?: Decimal | DecimalJsLike | number | string | null
    scoreScaled10?: Decimal | DecimalJsLike | number | string | null
    quiz: QuizCreateNestedOneWithoutAttemptsInput
    answers?: QuizAnswerCreateNestedManyWithoutAttemptInput
  }

  export type QuizAttemptUncheckedCreateWithoutStudentInput = {
    id?: number
    quizId: number
    startedAt?: Date | string
    submittedAt?: Date | string | null
    status?: string
    scoreRaw?: Decimal | DecimalJsLike | number | string | null
    scoreScaled10?: Decimal | DecimalJsLike | number | string | null
    answers?: QuizAnswerUncheckedCreateNestedManyWithoutAttemptInput
  }

  export type QuizAttemptCreateOrConnectWithoutStudentInput = {
    where: QuizAttemptWhereUniqueInput
    create: XOR<QuizAttemptCreateWithoutStudentInput, QuizAttemptUncheckedCreateWithoutStudentInput>
  }

  export type QuizAttemptCreateManyStudentInputEnvelope = {
    data: QuizAttemptCreateManyStudentInput | QuizAttemptCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: bigint | number
    tokenHash: string
    issuedAt?: Date | string
    expiresAt: Date | string
    revokedAt?: Date | string | null
    replacedByHash?: string | null
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: bigint | number
    tokenHash: string
    issuedAt?: Date | string
    expiresAt: Date | string
    revokedAt?: Date | string | null
    replacedByHash?: string | null
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MediaUpsertWithoutUserAvatarsInput = {
    update: XOR<MediaUpdateWithoutUserAvatarsInput, MediaUncheckedUpdateWithoutUserAvatarsInput>
    create: XOR<MediaCreateWithoutUserAvatarsInput, MediaUncheckedCreateWithoutUserAvatarsInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutUserAvatarsInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutUserAvatarsInput, MediaUncheckedUpdateWithoutUserAvatarsInput>
  }

  export type MediaUpdateWithoutUserAvatarsInput = {
    disk?: StringFieldUpdateOperationsInput | string
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    objectKey?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneWithoutUploadedMediaNestedInput
    classroomCovers?: ClassroomUpdateManyWithoutCoverMediaNestedInput
    materials?: MaterialUpdateManyWithoutMediaNestedInput
    exerciseAttachments?: ExerciseUpdateManyWithoutAttachMediaNestedInput
    exerciseSubmissions?: ExerciseSubmissionUpdateManyWithoutMediaNestedInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaUpdateManyWithoutMediaNestedInput
    quizQuestionMedias?: QuizQuestionMediaUpdateManyWithoutMediaNestedInput
    quizOptionMedias?: QuizOptionMediaUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutUserAvatarsInput = {
    id?: IntFieldUpdateOperationsInput | number
    disk?: StringFieldUpdateOperationsInput | string
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    objectKey?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    visibility?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classroomCovers?: ClassroomUncheckedUpdateManyWithoutCoverMediaNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutMediaNestedInput
    exerciseAttachments?: ExerciseUncheckedUpdateManyWithoutAttachMediaNestedInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedUpdateManyWithoutMediaNestedInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaUncheckedUpdateManyWithoutMediaNestedInput
    quizQuestionMedias?: QuizQuestionMediaUncheckedUpdateManyWithoutMediaNestedInput
    quizOptionMedias?: QuizOptionMediaUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type MediaUpsertWithWhereUniqueWithoutUploaderInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutUploaderInput, MediaUncheckedUpdateWithoutUploaderInput>
    create: XOR<MediaCreateWithoutUploaderInput, MediaUncheckedCreateWithoutUploaderInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutUploaderInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutUploaderInput, MediaUncheckedUpdateWithoutUploaderInput>
  }

  export type MediaUpdateManyWithWhereWithoutUploaderInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutUploaderInput>
  }

  export type MediaScalarWhereInput = {
    AND?: MediaScalarWhereInput | MediaScalarWhereInput[]
    OR?: MediaScalarWhereInput[]
    NOT?: MediaScalarWhereInput | MediaScalarWhereInput[]
    id?: IntFilter<"Media"> | number
    disk?: StringFilter<"Media"> | string
    bucket?: StringNullableFilter<"Media"> | string | null
    objectKey?: StringFilter<"Media"> | string
    mimeType?: StringNullableFilter<"Media"> | string | null
    sizeBytes?: BigIntNullableFilter<"Media"> | bigint | number | null
    visibility?: StringFilter<"Media"> | string
    uploadedBy?: IntNullableFilter<"Media"> | number | null
    createdAt?: DateTimeFilter<"Media"> | Date | string
  }

  export type ClassroomUpsertWithWhereUniqueWithoutTutorInput = {
    where: ClassroomWhereUniqueInput
    update: XOR<ClassroomUpdateWithoutTutorInput, ClassroomUncheckedUpdateWithoutTutorInput>
    create: XOR<ClassroomCreateWithoutTutorInput, ClassroomUncheckedCreateWithoutTutorInput>
  }

  export type ClassroomUpdateWithWhereUniqueWithoutTutorInput = {
    where: ClassroomWhereUniqueInput
    data: XOR<ClassroomUpdateWithoutTutorInput, ClassroomUncheckedUpdateWithoutTutorInput>
  }

  export type ClassroomUpdateManyWithWhereWithoutTutorInput = {
    where: ClassroomScalarWhereInput
    data: XOR<ClassroomUpdateManyMutationInput, ClassroomUncheckedUpdateManyWithoutTutorInput>
  }

  export type ClassroomUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ClassroomWhereUniqueInput
    update: XOR<ClassroomUpdateWithoutCreatorInput, ClassroomUncheckedUpdateWithoutCreatorInput>
    create: XOR<ClassroomCreateWithoutCreatorInput, ClassroomUncheckedCreateWithoutCreatorInput>
  }

  export type ClassroomUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ClassroomWhereUniqueInput
    data: XOR<ClassroomUpdateWithoutCreatorInput, ClassroomUncheckedUpdateWithoutCreatorInput>
  }

  export type ClassroomUpdateManyWithWhereWithoutCreatorInput = {
    where: ClassroomScalarWhereInput
    data: XOR<ClassroomUpdateManyMutationInput, ClassroomUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ClassroomStudentUpsertWithWhereUniqueWithoutStudentInput = {
    where: ClassroomStudentWhereUniqueInput
    update: XOR<ClassroomStudentUpdateWithoutStudentInput, ClassroomStudentUncheckedUpdateWithoutStudentInput>
    create: XOR<ClassroomStudentCreateWithoutStudentInput, ClassroomStudentUncheckedCreateWithoutStudentInput>
  }

  export type ClassroomStudentUpdateWithWhereUniqueWithoutStudentInput = {
    where: ClassroomStudentWhereUniqueInput
    data: XOR<ClassroomStudentUpdateWithoutStudentInput, ClassroomStudentUncheckedUpdateWithoutStudentInput>
  }

  export type ClassroomStudentUpdateManyWithWhereWithoutStudentInput = {
    where: ClassroomStudentScalarWhereInput
    data: XOR<ClassroomStudentUpdateManyMutationInput, ClassroomStudentUncheckedUpdateManyWithoutStudentInput>
  }

  export type ClassroomStudentScalarWhereInput = {
    AND?: ClassroomStudentScalarWhereInput | ClassroomStudentScalarWhereInput[]
    OR?: ClassroomStudentScalarWhereInput[]
    NOT?: ClassroomStudentScalarWhereInput | ClassroomStudentScalarWhereInput[]
    classroomId?: IntFilter<"ClassroomStudent"> | number
    studentId?: IntFilter<"ClassroomStudent"> | number
    joinedAt?: DateTimeFilter<"ClassroomStudent"> | Date | string
    status?: IntFilter<"ClassroomStudent"> | number
  }

  export type JoinRequestUpsertWithWhereUniqueWithoutStudentInput = {
    where: JoinRequestWhereUniqueInput
    update: XOR<JoinRequestUpdateWithoutStudentInput, JoinRequestUncheckedUpdateWithoutStudentInput>
    create: XOR<JoinRequestCreateWithoutStudentInput, JoinRequestUncheckedCreateWithoutStudentInput>
  }

  export type JoinRequestUpdateWithWhereUniqueWithoutStudentInput = {
    where: JoinRequestWhereUniqueInput
    data: XOR<JoinRequestUpdateWithoutStudentInput, JoinRequestUncheckedUpdateWithoutStudentInput>
  }

  export type JoinRequestUpdateManyWithWhereWithoutStudentInput = {
    where: JoinRequestScalarWhereInput
    data: XOR<JoinRequestUpdateManyMutationInput, JoinRequestUncheckedUpdateManyWithoutStudentInput>
  }

  export type JoinRequestScalarWhereInput = {
    AND?: JoinRequestScalarWhereInput | JoinRequestScalarWhereInput[]
    OR?: JoinRequestScalarWhereInput[]
    NOT?: JoinRequestScalarWhereInput | JoinRequestScalarWhereInput[]
    id?: IntFilter<"JoinRequest"> | number
    classroomId?: IntFilter<"JoinRequest"> | number
    studentId?: IntFilter<"JoinRequest"> | number
    status?: StringFilter<"JoinRequest"> | string
    requestedAt?: DateTimeFilter<"JoinRequest"> | Date | string
    handledAt?: DateTimeNullableFilter<"JoinRequest"> | Date | string | null
  }

  export type MaterialUpsertWithWhereUniqueWithoutUploaderInput = {
    where: MaterialWhereUniqueInput
    update: XOR<MaterialUpdateWithoutUploaderInput, MaterialUncheckedUpdateWithoutUploaderInput>
    create: XOR<MaterialCreateWithoutUploaderInput, MaterialUncheckedCreateWithoutUploaderInput>
  }

  export type MaterialUpdateWithWhereUniqueWithoutUploaderInput = {
    where: MaterialWhereUniqueInput
    data: XOR<MaterialUpdateWithoutUploaderInput, MaterialUncheckedUpdateWithoutUploaderInput>
  }

  export type MaterialUpdateManyWithWhereWithoutUploaderInput = {
    where: MaterialScalarWhereInput
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyWithoutUploaderInput>
  }

  export type ExerciseUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ExerciseWhereUniqueInput
    update: XOR<ExerciseUpdateWithoutCreatorInput, ExerciseUncheckedUpdateWithoutCreatorInput>
    create: XOR<ExerciseCreateWithoutCreatorInput, ExerciseUncheckedCreateWithoutCreatorInput>
  }

  export type ExerciseUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ExerciseWhereUniqueInput
    data: XOR<ExerciseUpdateWithoutCreatorInput, ExerciseUncheckedUpdateWithoutCreatorInput>
  }

  export type ExerciseUpdateManyWithWhereWithoutCreatorInput = {
    where: ExerciseScalarWhereInput
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ExerciseSubmissionUpsertWithWhereUniqueWithoutStudentInput = {
    where: ExerciseSubmissionWhereUniqueInput
    update: XOR<ExerciseSubmissionUpdateWithoutStudentInput, ExerciseSubmissionUncheckedUpdateWithoutStudentInput>
    create: XOR<ExerciseSubmissionCreateWithoutStudentInput, ExerciseSubmissionUncheckedCreateWithoutStudentInput>
  }

  export type ExerciseSubmissionUpdateWithWhereUniqueWithoutStudentInput = {
    where: ExerciseSubmissionWhereUniqueInput
    data: XOR<ExerciseSubmissionUpdateWithoutStudentInput, ExerciseSubmissionUncheckedUpdateWithoutStudentInput>
  }

  export type ExerciseSubmissionUpdateManyWithWhereWithoutStudentInput = {
    where: ExerciseSubmissionScalarWhereInput
    data: XOR<ExerciseSubmissionUpdateManyMutationInput, ExerciseSubmissionUncheckedUpdateManyWithoutStudentInput>
  }

  export type QuizUpsertWithWhereUniqueWithoutCreatorInput = {
    where: QuizWhereUniqueInput
    update: XOR<QuizUpdateWithoutCreatorInput, QuizUncheckedUpdateWithoutCreatorInput>
    create: XOR<QuizCreateWithoutCreatorInput, QuizUncheckedCreateWithoutCreatorInput>
  }

  export type QuizUpdateWithWhereUniqueWithoutCreatorInput = {
    where: QuizWhereUniqueInput
    data: XOR<QuizUpdateWithoutCreatorInput, QuizUncheckedUpdateWithoutCreatorInput>
  }

  export type QuizUpdateManyWithWhereWithoutCreatorInput = {
    where: QuizScalarWhereInput
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyWithoutCreatorInput>
  }

  export type QuizScalarWhereInput = {
    AND?: QuizScalarWhereInput | QuizScalarWhereInput[]
    OR?: QuizScalarWhereInput[]
    NOT?: QuizScalarWhereInput | QuizScalarWhereInput[]
    id?: IntFilter<"Quiz"> | number
    lessonId?: IntFilter<"Quiz"> | number
    title?: StringFilter<"Quiz"> | string
    description?: StringNullableFilter<"Quiz"> | string | null
    timeLimitSec?: IntNullableFilter<"Quiz"> | number | null
    maxAttempts?: IntFilter<"Quiz"> | number
    shuffleQuestions?: BoolFilter<"Quiz"> | boolean
    shuffleOptions?: BoolFilter<"Quiz"> | boolean
    gradingMethod?: StringFilter<"Quiz"> | string
    showAnswersAfter?: StringFilter<"Quiz"> | string
    dueAt?: DateTimeNullableFilter<"Quiz"> | Date | string | null
    isPublished?: BoolFilter<"Quiz"> | boolean
    totalPoints?: DecimalFilter<"Quiz"> | Decimal | DecimalJsLike | number | string
    createdBy?: IntFilter<"Quiz"> | number
    createdAt?: DateTimeFilter<"Quiz"> | Date | string
    updatedAt?: DateTimeFilter<"Quiz"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Quiz"> | Date | string | null
  }

  export type QuizAttemptUpsertWithWhereUniqueWithoutStudentInput = {
    where: QuizAttemptWhereUniqueInput
    update: XOR<QuizAttemptUpdateWithoutStudentInput, QuizAttemptUncheckedUpdateWithoutStudentInput>
    create: XOR<QuizAttemptCreateWithoutStudentInput, QuizAttemptUncheckedCreateWithoutStudentInput>
  }

  export type QuizAttemptUpdateWithWhereUniqueWithoutStudentInput = {
    where: QuizAttemptWhereUniqueInput
    data: XOR<QuizAttemptUpdateWithoutStudentInput, QuizAttemptUncheckedUpdateWithoutStudentInput>
  }

  export type QuizAttemptUpdateManyWithWhereWithoutStudentInput = {
    where: QuizAttemptScalarWhereInput
    data: XOR<QuizAttemptUpdateManyMutationInput, QuizAttemptUncheckedUpdateManyWithoutStudentInput>
  }

  export type QuizAttemptScalarWhereInput = {
    AND?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
    OR?: QuizAttemptScalarWhereInput[]
    NOT?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
    id?: IntFilter<"QuizAttempt"> | number
    quizId?: IntFilter<"QuizAttempt"> | number
    studentId?: IntFilter<"QuizAttempt"> | number
    startedAt?: DateTimeFilter<"QuizAttempt"> | Date | string
    submittedAt?: DateTimeNullableFilter<"QuizAttempt"> | Date | string | null
    status?: StringFilter<"QuizAttempt"> | string
    scoreRaw?: DecimalNullableFilter<"QuizAttempt"> | Decimal | DecimalJsLike | number | string | null
    scoreScaled10?: DecimalNullableFilter<"QuizAttempt"> | Decimal | DecimalJsLike | number | string | null
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: BigIntFilter<"RefreshToken"> | bigint | number
    userId?: IntFilter<"RefreshToken"> | number
    tokenHash?: StringFilter<"RefreshToken"> | string
    issuedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    replacedByHash?: StringNullableFilter<"RefreshToken"> | string | null
  }

  export type UserCreateWithoutTaughtClassroomsInput = {
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarMedia?: MediaCreateNestedOneWithoutUserAvatarsInput
    uploadedMedia?: MediaCreateNestedManyWithoutUploaderInput
    createdClassrooms?: ClassroomCreateNestedManyWithoutCreatorInput
    classroomStudents?: ClassroomStudentCreateNestedManyWithoutStudentInput
    joinRequests?: JoinRequestCreateNestedManyWithoutStudentInput
    uploadedMaterials?: MaterialCreateNestedManyWithoutUploaderInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    exerciseSubmissions?: ExerciseSubmissionCreateNestedManyWithoutStudentInput
    createdQuizzes?: QuizCreateNestedManyWithoutCreatorInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutStudentInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTaughtClassroomsInput = {
    id?: number
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    avatarMediaId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedMedia?: MediaUncheckedCreateNestedManyWithoutUploaderInput
    createdClassrooms?: ClassroomUncheckedCreateNestedManyWithoutCreatorInput
    classroomStudents?: ClassroomStudentUncheckedCreateNestedManyWithoutStudentInput
    joinRequests?: JoinRequestUncheckedCreateNestedManyWithoutStudentInput
    uploadedMaterials?: MaterialUncheckedCreateNestedManyWithoutUploaderInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutStudentInput
    createdQuizzes?: QuizUncheckedCreateNestedManyWithoutCreatorInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutStudentInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTaughtClassroomsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTaughtClassroomsInput, UserUncheckedCreateWithoutTaughtClassroomsInput>
  }

  export type UserCreateWithoutCreatedClassroomsInput = {
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarMedia?: MediaCreateNestedOneWithoutUserAvatarsInput
    uploadedMedia?: MediaCreateNestedManyWithoutUploaderInput
    taughtClassrooms?: ClassroomCreateNestedManyWithoutTutorInput
    classroomStudents?: ClassroomStudentCreateNestedManyWithoutStudentInput
    joinRequests?: JoinRequestCreateNestedManyWithoutStudentInput
    uploadedMaterials?: MaterialCreateNestedManyWithoutUploaderInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    exerciseSubmissions?: ExerciseSubmissionCreateNestedManyWithoutStudentInput
    createdQuizzes?: QuizCreateNestedManyWithoutCreatorInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutStudentInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedClassroomsInput = {
    id?: number
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    avatarMediaId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedMedia?: MediaUncheckedCreateNestedManyWithoutUploaderInput
    taughtClassrooms?: ClassroomUncheckedCreateNestedManyWithoutTutorInput
    classroomStudents?: ClassroomStudentUncheckedCreateNestedManyWithoutStudentInput
    joinRequests?: JoinRequestUncheckedCreateNestedManyWithoutStudentInput
    uploadedMaterials?: MaterialUncheckedCreateNestedManyWithoutUploaderInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutStudentInput
    createdQuizzes?: QuizUncheckedCreateNestedManyWithoutCreatorInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutStudentInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedClassroomsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedClassroomsInput, UserUncheckedCreateWithoutCreatedClassroomsInput>
  }

  export type MediaCreateWithoutClassroomCoversInput = {
    disk: string
    bucket?: string | null
    objectKey: string
    mimeType?: string | null
    sizeBytes?: bigint | number | null
    visibility?: string
    createdAt?: Date | string
    uploader?: UserCreateNestedOneWithoutUploadedMediaInput
    userAvatars?: UserCreateNestedManyWithoutAvatarMediaInput
    materials?: MaterialCreateNestedManyWithoutMediaInput
    exerciseAttachments?: ExerciseCreateNestedManyWithoutAttachMediaInput
    exerciseSubmissions?: ExerciseSubmissionCreateNestedManyWithoutMediaInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaCreateNestedManyWithoutMediaInput
    quizQuestionMedias?: QuizQuestionMediaCreateNestedManyWithoutMediaInput
    quizOptionMedias?: QuizOptionMediaCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutClassroomCoversInput = {
    id?: number
    disk: string
    bucket?: string | null
    objectKey: string
    mimeType?: string | null
    sizeBytes?: bigint | number | null
    visibility?: string
    uploadedBy?: number | null
    createdAt?: Date | string
    userAvatars?: UserUncheckedCreateNestedManyWithoutAvatarMediaInput
    materials?: MaterialUncheckedCreateNestedManyWithoutMediaInput
    exerciseAttachments?: ExerciseUncheckedCreateNestedManyWithoutAttachMediaInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutMediaInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaUncheckedCreateNestedManyWithoutMediaInput
    quizQuestionMedias?: QuizQuestionMediaUncheckedCreateNestedManyWithoutMediaInput
    quizOptionMedias?: QuizOptionMediaUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutClassroomCoversInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutClassroomCoversInput, MediaUncheckedCreateWithoutClassroomCoversInput>
  }

  export type ClassroomStudentCreateWithoutClassroomInput = {
    joinedAt?: Date | string
    status?: number
    student: UserCreateNestedOneWithoutClassroomStudentsInput
  }

  export type ClassroomStudentUncheckedCreateWithoutClassroomInput = {
    studentId: number
    joinedAt?: Date | string
    status?: number
  }

  export type ClassroomStudentCreateOrConnectWithoutClassroomInput = {
    where: ClassroomStudentWhereUniqueInput
    create: XOR<ClassroomStudentCreateWithoutClassroomInput, ClassroomStudentUncheckedCreateWithoutClassroomInput>
  }

  export type ClassroomStudentCreateManyClassroomInputEnvelope = {
    data: ClassroomStudentCreateManyClassroomInput | ClassroomStudentCreateManyClassroomInput[]
    skipDuplicates?: boolean
  }

  export type JoinRequestCreateWithoutClassroomInput = {
    status?: string
    requestedAt?: Date | string
    handledAt?: Date | string | null
    student: UserCreateNestedOneWithoutJoinRequestsInput
  }

  export type JoinRequestUncheckedCreateWithoutClassroomInput = {
    id?: number
    studentId: number
    status?: string
    requestedAt?: Date | string
    handledAt?: Date | string | null
  }

  export type JoinRequestCreateOrConnectWithoutClassroomInput = {
    where: JoinRequestWhereUniqueInput
    create: XOR<JoinRequestCreateWithoutClassroomInput, JoinRequestUncheckedCreateWithoutClassroomInput>
  }

  export type JoinRequestCreateManyClassroomInputEnvelope = {
    data: JoinRequestCreateManyClassroomInput | JoinRequestCreateManyClassroomInput[]
    skipDuplicates?: boolean
  }

  export type LessonCreateWithoutClassroomInput = {
    title: string
    content?: string | null
    lessonType?: $Enums.LessonType
    orderIndex?: number
    publishedAt?: Date | string | null
    materials?: MaterialCreateNestedManyWithoutLessonInput
    exercises?: ExerciseCreateNestedManyWithoutLessonInput
    quizzes?: QuizCreateNestedManyWithoutLessonInput
    parent?: LessonCreateNestedOneWithoutSubLessonsInput
    subLessons?: LessonCreateNestedManyWithoutParentInput
  }

  export type LessonUncheckedCreateWithoutClassroomInput = {
    id?: number
    parentId?: number | null
    title: string
    content?: string | null
    lessonType?: $Enums.LessonType
    orderIndex?: number
    publishedAt?: Date | string | null
    materials?: MaterialUncheckedCreateNestedManyWithoutLessonInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutLessonInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutLessonInput
    subLessons?: LessonUncheckedCreateNestedManyWithoutParentInput
  }

  export type LessonCreateOrConnectWithoutClassroomInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutClassroomInput, LessonUncheckedCreateWithoutClassroomInput>
  }

  export type LessonCreateManyClassroomInputEnvelope = {
    data: LessonCreateManyClassroomInput | LessonCreateManyClassroomInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTaughtClassroomsInput = {
    update: XOR<UserUpdateWithoutTaughtClassroomsInput, UserUncheckedUpdateWithoutTaughtClassroomsInput>
    create: XOR<UserCreateWithoutTaughtClassroomsInput, UserUncheckedCreateWithoutTaughtClassroomsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTaughtClassroomsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTaughtClassroomsInput, UserUncheckedUpdateWithoutTaughtClassroomsInput>
  }

  export type UserUpdateWithoutTaughtClassroomsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarMedia?: MediaUpdateOneWithoutUserAvatarsNestedInput
    uploadedMedia?: MediaUpdateManyWithoutUploaderNestedInput
    createdClassrooms?: ClassroomUpdateManyWithoutCreatorNestedInput
    classroomStudents?: ClassroomStudentUpdateManyWithoutStudentNestedInput
    joinRequests?: JoinRequestUpdateManyWithoutStudentNestedInput
    uploadedMaterials?: MaterialUpdateManyWithoutUploaderNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    exerciseSubmissions?: ExerciseSubmissionUpdateManyWithoutStudentNestedInput
    createdQuizzes?: QuizUpdateManyWithoutCreatorNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutStudentNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTaughtClassroomsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatarMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedMedia?: MediaUncheckedUpdateManyWithoutUploaderNestedInput
    createdClassrooms?: ClassroomUncheckedUpdateManyWithoutCreatorNestedInput
    classroomStudents?: ClassroomStudentUncheckedUpdateManyWithoutStudentNestedInput
    joinRequests?: JoinRequestUncheckedUpdateManyWithoutStudentNestedInput
    uploadedMaterials?: MaterialUncheckedUpdateManyWithoutUploaderNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    createdQuizzes?: QuizUncheckedUpdateManyWithoutCreatorNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutStudentNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutCreatedClassroomsInput = {
    update: XOR<UserUpdateWithoutCreatedClassroomsInput, UserUncheckedUpdateWithoutCreatedClassroomsInput>
    create: XOR<UserCreateWithoutCreatedClassroomsInput, UserUncheckedCreateWithoutCreatedClassroomsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedClassroomsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedClassroomsInput, UserUncheckedUpdateWithoutCreatedClassroomsInput>
  }

  export type UserUpdateWithoutCreatedClassroomsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarMedia?: MediaUpdateOneWithoutUserAvatarsNestedInput
    uploadedMedia?: MediaUpdateManyWithoutUploaderNestedInput
    taughtClassrooms?: ClassroomUpdateManyWithoutTutorNestedInput
    classroomStudents?: ClassroomStudentUpdateManyWithoutStudentNestedInput
    joinRequests?: JoinRequestUpdateManyWithoutStudentNestedInput
    uploadedMaterials?: MaterialUpdateManyWithoutUploaderNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    exerciseSubmissions?: ExerciseSubmissionUpdateManyWithoutStudentNestedInput
    createdQuizzes?: QuizUpdateManyWithoutCreatorNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutStudentNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedClassroomsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatarMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedMedia?: MediaUncheckedUpdateManyWithoutUploaderNestedInput
    taughtClassrooms?: ClassroomUncheckedUpdateManyWithoutTutorNestedInput
    classroomStudents?: ClassroomStudentUncheckedUpdateManyWithoutStudentNestedInput
    joinRequests?: JoinRequestUncheckedUpdateManyWithoutStudentNestedInput
    uploadedMaterials?: MaterialUncheckedUpdateManyWithoutUploaderNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    createdQuizzes?: QuizUncheckedUpdateManyWithoutCreatorNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutStudentNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MediaUpsertWithoutClassroomCoversInput = {
    update: XOR<MediaUpdateWithoutClassroomCoversInput, MediaUncheckedUpdateWithoutClassroomCoversInput>
    create: XOR<MediaCreateWithoutClassroomCoversInput, MediaUncheckedCreateWithoutClassroomCoversInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutClassroomCoversInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutClassroomCoversInput, MediaUncheckedUpdateWithoutClassroomCoversInput>
  }

  export type MediaUpdateWithoutClassroomCoversInput = {
    disk?: StringFieldUpdateOperationsInput | string
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    objectKey?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneWithoutUploadedMediaNestedInput
    userAvatars?: UserUpdateManyWithoutAvatarMediaNestedInput
    materials?: MaterialUpdateManyWithoutMediaNestedInput
    exerciseAttachments?: ExerciseUpdateManyWithoutAttachMediaNestedInput
    exerciseSubmissions?: ExerciseSubmissionUpdateManyWithoutMediaNestedInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaUpdateManyWithoutMediaNestedInput
    quizQuestionMedias?: QuizQuestionMediaUpdateManyWithoutMediaNestedInput
    quizOptionMedias?: QuizOptionMediaUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutClassroomCoversInput = {
    id?: IntFieldUpdateOperationsInput | number
    disk?: StringFieldUpdateOperationsInput | string
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    objectKey?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    visibility?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAvatars?: UserUncheckedUpdateManyWithoutAvatarMediaNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutMediaNestedInput
    exerciseAttachments?: ExerciseUncheckedUpdateManyWithoutAttachMediaNestedInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedUpdateManyWithoutMediaNestedInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaUncheckedUpdateManyWithoutMediaNestedInput
    quizQuestionMedias?: QuizQuestionMediaUncheckedUpdateManyWithoutMediaNestedInput
    quizOptionMedias?: QuizOptionMediaUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type ClassroomStudentUpsertWithWhereUniqueWithoutClassroomInput = {
    where: ClassroomStudentWhereUniqueInput
    update: XOR<ClassroomStudentUpdateWithoutClassroomInput, ClassroomStudentUncheckedUpdateWithoutClassroomInput>
    create: XOR<ClassroomStudentCreateWithoutClassroomInput, ClassroomStudentUncheckedCreateWithoutClassroomInput>
  }

  export type ClassroomStudentUpdateWithWhereUniqueWithoutClassroomInput = {
    where: ClassroomStudentWhereUniqueInput
    data: XOR<ClassroomStudentUpdateWithoutClassroomInput, ClassroomStudentUncheckedUpdateWithoutClassroomInput>
  }

  export type ClassroomStudentUpdateManyWithWhereWithoutClassroomInput = {
    where: ClassroomStudentScalarWhereInput
    data: XOR<ClassroomStudentUpdateManyMutationInput, ClassroomStudentUncheckedUpdateManyWithoutClassroomInput>
  }

  export type JoinRequestUpsertWithWhereUniqueWithoutClassroomInput = {
    where: JoinRequestWhereUniqueInput
    update: XOR<JoinRequestUpdateWithoutClassroomInput, JoinRequestUncheckedUpdateWithoutClassroomInput>
    create: XOR<JoinRequestCreateWithoutClassroomInput, JoinRequestUncheckedCreateWithoutClassroomInput>
  }

  export type JoinRequestUpdateWithWhereUniqueWithoutClassroomInput = {
    where: JoinRequestWhereUniqueInput
    data: XOR<JoinRequestUpdateWithoutClassroomInput, JoinRequestUncheckedUpdateWithoutClassroomInput>
  }

  export type JoinRequestUpdateManyWithWhereWithoutClassroomInput = {
    where: JoinRequestScalarWhereInput
    data: XOR<JoinRequestUpdateManyMutationInput, JoinRequestUncheckedUpdateManyWithoutClassroomInput>
  }

  export type LessonUpsertWithWhereUniqueWithoutClassroomInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutClassroomInput, LessonUncheckedUpdateWithoutClassroomInput>
    create: XOR<LessonCreateWithoutClassroomInput, LessonUncheckedCreateWithoutClassroomInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutClassroomInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutClassroomInput, LessonUncheckedUpdateWithoutClassroomInput>
  }

  export type LessonUpdateManyWithWhereWithoutClassroomInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutClassroomInput>
  }

  export type LessonScalarWhereInput = {
    AND?: LessonScalarWhereInput | LessonScalarWhereInput[]
    OR?: LessonScalarWhereInput[]
    NOT?: LessonScalarWhereInput | LessonScalarWhereInput[]
    id?: IntFilter<"Lesson"> | number
    classroomId?: IntFilter<"Lesson"> | number
    parentId?: IntNullableFilter<"Lesson"> | number | null
    title?: StringFilter<"Lesson"> | string
    content?: StringNullableFilter<"Lesson"> | string | null
    lessonType?: EnumLessonTypeFilter<"Lesson"> | $Enums.LessonType
    orderIndex?: IntFilter<"Lesson"> | number
    publishedAt?: DateTimeNullableFilter<"Lesson"> | Date | string | null
  }

  export type ClassroomCreateWithoutClassroomStudentsInput = {
    name: string
    description?: string | null
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tutor: UserCreateNestedOneWithoutTaughtClassroomsInput
    creator: UserCreateNestedOneWithoutCreatedClassroomsInput
    coverMedia?: MediaCreateNestedOneWithoutClassroomCoversInput
    joinRequests?: JoinRequestCreateNestedManyWithoutClassroomInput
    lessons?: LessonCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomUncheckedCreateWithoutClassroomStudentsInput = {
    id?: number
    name: string
    description?: string | null
    tutorId: number
    coverMediaId?: number | null
    isArchived?: boolean
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    joinRequests?: JoinRequestUncheckedCreateNestedManyWithoutClassroomInput
    lessons?: LessonUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomCreateOrConnectWithoutClassroomStudentsInput = {
    where: ClassroomWhereUniqueInput
    create: XOR<ClassroomCreateWithoutClassroomStudentsInput, ClassroomUncheckedCreateWithoutClassroomStudentsInput>
  }

  export type UserCreateWithoutClassroomStudentsInput = {
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarMedia?: MediaCreateNestedOneWithoutUserAvatarsInput
    uploadedMedia?: MediaCreateNestedManyWithoutUploaderInput
    taughtClassrooms?: ClassroomCreateNestedManyWithoutTutorInput
    createdClassrooms?: ClassroomCreateNestedManyWithoutCreatorInput
    joinRequests?: JoinRequestCreateNestedManyWithoutStudentInput
    uploadedMaterials?: MaterialCreateNestedManyWithoutUploaderInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    exerciseSubmissions?: ExerciseSubmissionCreateNestedManyWithoutStudentInput
    createdQuizzes?: QuizCreateNestedManyWithoutCreatorInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutStudentInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClassroomStudentsInput = {
    id?: number
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    avatarMediaId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedMedia?: MediaUncheckedCreateNestedManyWithoutUploaderInput
    taughtClassrooms?: ClassroomUncheckedCreateNestedManyWithoutTutorInput
    createdClassrooms?: ClassroomUncheckedCreateNestedManyWithoutCreatorInput
    joinRequests?: JoinRequestUncheckedCreateNestedManyWithoutStudentInput
    uploadedMaterials?: MaterialUncheckedCreateNestedManyWithoutUploaderInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutStudentInput
    createdQuizzes?: QuizUncheckedCreateNestedManyWithoutCreatorInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutStudentInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClassroomStudentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClassroomStudentsInput, UserUncheckedCreateWithoutClassroomStudentsInput>
  }

  export type ClassroomUpsertWithoutClassroomStudentsInput = {
    update: XOR<ClassroomUpdateWithoutClassroomStudentsInput, ClassroomUncheckedUpdateWithoutClassroomStudentsInput>
    create: XOR<ClassroomCreateWithoutClassroomStudentsInput, ClassroomUncheckedCreateWithoutClassroomStudentsInput>
    where?: ClassroomWhereInput
  }

  export type ClassroomUpdateToOneWithWhereWithoutClassroomStudentsInput = {
    where?: ClassroomWhereInput
    data: XOR<ClassroomUpdateWithoutClassroomStudentsInput, ClassroomUncheckedUpdateWithoutClassroomStudentsInput>
  }

  export type ClassroomUpdateWithoutClassroomStudentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tutor?: UserUpdateOneRequiredWithoutTaughtClassroomsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedClassroomsNestedInput
    coverMedia?: MediaUpdateOneWithoutClassroomCoversNestedInput
    joinRequests?: JoinRequestUpdateManyWithoutClassroomNestedInput
    lessons?: LessonUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateWithoutClassroomStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tutorId?: IntFieldUpdateOperationsInput | number
    coverMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinRequests?: JoinRequestUncheckedUpdateManyWithoutClassroomNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type UserUpsertWithoutClassroomStudentsInput = {
    update: XOR<UserUpdateWithoutClassroomStudentsInput, UserUncheckedUpdateWithoutClassroomStudentsInput>
    create: XOR<UserCreateWithoutClassroomStudentsInput, UserUncheckedCreateWithoutClassroomStudentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClassroomStudentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClassroomStudentsInput, UserUncheckedUpdateWithoutClassroomStudentsInput>
  }

  export type UserUpdateWithoutClassroomStudentsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarMedia?: MediaUpdateOneWithoutUserAvatarsNestedInput
    uploadedMedia?: MediaUpdateManyWithoutUploaderNestedInput
    taughtClassrooms?: ClassroomUpdateManyWithoutTutorNestedInput
    createdClassrooms?: ClassroomUpdateManyWithoutCreatorNestedInput
    joinRequests?: JoinRequestUpdateManyWithoutStudentNestedInput
    uploadedMaterials?: MaterialUpdateManyWithoutUploaderNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    exerciseSubmissions?: ExerciseSubmissionUpdateManyWithoutStudentNestedInput
    createdQuizzes?: QuizUpdateManyWithoutCreatorNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutStudentNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClassroomStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatarMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedMedia?: MediaUncheckedUpdateManyWithoutUploaderNestedInput
    taughtClassrooms?: ClassroomUncheckedUpdateManyWithoutTutorNestedInput
    createdClassrooms?: ClassroomUncheckedUpdateManyWithoutCreatorNestedInput
    joinRequests?: JoinRequestUncheckedUpdateManyWithoutStudentNestedInput
    uploadedMaterials?: MaterialUncheckedUpdateManyWithoutUploaderNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    createdQuizzes?: QuizUncheckedUpdateManyWithoutCreatorNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutStudentNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClassroomCreateWithoutJoinRequestsInput = {
    name: string
    description?: string | null
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tutor: UserCreateNestedOneWithoutTaughtClassroomsInput
    creator: UserCreateNestedOneWithoutCreatedClassroomsInput
    coverMedia?: MediaCreateNestedOneWithoutClassroomCoversInput
    classroomStudents?: ClassroomStudentCreateNestedManyWithoutClassroomInput
    lessons?: LessonCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomUncheckedCreateWithoutJoinRequestsInput = {
    id?: number
    name: string
    description?: string | null
    tutorId: number
    coverMediaId?: number | null
    isArchived?: boolean
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    classroomStudents?: ClassroomStudentUncheckedCreateNestedManyWithoutClassroomInput
    lessons?: LessonUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomCreateOrConnectWithoutJoinRequestsInput = {
    where: ClassroomWhereUniqueInput
    create: XOR<ClassroomCreateWithoutJoinRequestsInput, ClassroomUncheckedCreateWithoutJoinRequestsInput>
  }

  export type UserCreateWithoutJoinRequestsInput = {
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarMedia?: MediaCreateNestedOneWithoutUserAvatarsInput
    uploadedMedia?: MediaCreateNestedManyWithoutUploaderInput
    taughtClassrooms?: ClassroomCreateNestedManyWithoutTutorInput
    createdClassrooms?: ClassroomCreateNestedManyWithoutCreatorInput
    classroomStudents?: ClassroomStudentCreateNestedManyWithoutStudentInput
    uploadedMaterials?: MaterialCreateNestedManyWithoutUploaderInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    exerciseSubmissions?: ExerciseSubmissionCreateNestedManyWithoutStudentInput
    createdQuizzes?: QuizCreateNestedManyWithoutCreatorInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutStudentInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutJoinRequestsInput = {
    id?: number
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    avatarMediaId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedMedia?: MediaUncheckedCreateNestedManyWithoutUploaderInput
    taughtClassrooms?: ClassroomUncheckedCreateNestedManyWithoutTutorInput
    createdClassrooms?: ClassroomUncheckedCreateNestedManyWithoutCreatorInput
    classroomStudents?: ClassroomStudentUncheckedCreateNestedManyWithoutStudentInput
    uploadedMaterials?: MaterialUncheckedCreateNestedManyWithoutUploaderInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutStudentInput
    createdQuizzes?: QuizUncheckedCreateNestedManyWithoutCreatorInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutStudentInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutJoinRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJoinRequestsInput, UserUncheckedCreateWithoutJoinRequestsInput>
  }

  export type ClassroomUpsertWithoutJoinRequestsInput = {
    update: XOR<ClassroomUpdateWithoutJoinRequestsInput, ClassroomUncheckedUpdateWithoutJoinRequestsInput>
    create: XOR<ClassroomCreateWithoutJoinRequestsInput, ClassroomUncheckedCreateWithoutJoinRequestsInput>
    where?: ClassroomWhereInput
  }

  export type ClassroomUpdateToOneWithWhereWithoutJoinRequestsInput = {
    where?: ClassroomWhereInput
    data: XOR<ClassroomUpdateWithoutJoinRequestsInput, ClassroomUncheckedUpdateWithoutJoinRequestsInput>
  }

  export type ClassroomUpdateWithoutJoinRequestsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tutor?: UserUpdateOneRequiredWithoutTaughtClassroomsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedClassroomsNestedInput
    coverMedia?: MediaUpdateOneWithoutClassroomCoversNestedInput
    classroomStudents?: ClassroomStudentUpdateManyWithoutClassroomNestedInput
    lessons?: LessonUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateWithoutJoinRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tutorId?: IntFieldUpdateOperationsInput | number
    coverMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classroomStudents?: ClassroomStudentUncheckedUpdateManyWithoutClassroomNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type UserUpsertWithoutJoinRequestsInput = {
    update: XOR<UserUpdateWithoutJoinRequestsInput, UserUncheckedUpdateWithoutJoinRequestsInput>
    create: XOR<UserCreateWithoutJoinRequestsInput, UserUncheckedCreateWithoutJoinRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutJoinRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutJoinRequestsInput, UserUncheckedUpdateWithoutJoinRequestsInput>
  }

  export type UserUpdateWithoutJoinRequestsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarMedia?: MediaUpdateOneWithoutUserAvatarsNestedInput
    uploadedMedia?: MediaUpdateManyWithoutUploaderNestedInput
    taughtClassrooms?: ClassroomUpdateManyWithoutTutorNestedInput
    createdClassrooms?: ClassroomUpdateManyWithoutCreatorNestedInput
    classroomStudents?: ClassroomStudentUpdateManyWithoutStudentNestedInput
    uploadedMaterials?: MaterialUpdateManyWithoutUploaderNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    exerciseSubmissions?: ExerciseSubmissionUpdateManyWithoutStudentNestedInput
    createdQuizzes?: QuizUpdateManyWithoutCreatorNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutStudentNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutJoinRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatarMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedMedia?: MediaUncheckedUpdateManyWithoutUploaderNestedInput
    taughtClassrooms?: ClassroomUncheckedUpdateManyWithoutTutorNestedInput
    createdClassrooms?: ClassroomUncheckedUpdateManyWithoutCreatorNestedInput
    classroomStudents?: ClassroomStudentUncheckedUpdateManyWithoutStudentNestedInput
    uploadedMaterials?: MaterialUncheckedUpdateManyWithoutUploaderNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    createdQuizzes?: QuizUncheckedUpdateManyWithoutCreatorNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutStudentNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClassroomCreateWithoutLessonsInput = {
    name: string
    description?: string | null
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tutor: UserCreateNestedOneWithoutTaughtClassroomsInput
    creator: UserCreateNestedOneWithoutCreatedClassroomsInput
    coverMedia?: MediaCreateNestedOneWithoutClassroomCoversInput
    classroomStudents?: ClassroomStudentCreateNestedManyWithoutClassroomInput
    joinRequests?: JoinRequestCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomUncheckedCreateWithoutLessonsInput = {
    id?: number
    name: string
    description?: string | null
    tutorId: number
    coverMediaId?: number | null
    isArchived?: boolean
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    classroomStudents?: ClassroomStudentUncheckedCreateNestedManyWithoutClassroomInput
    joinRequests?: JoinRequestUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomCreateOrConnectWithoutLessonsInput = {
    where: ClassroomWhereUniqueInput
    create: XOR<ClassroomCreateWithoutLessonsInput, ClassroomUncheckedCreateWithoutLessonsInput>
  }

  export type MaterialCreateWithoutLessonInput = {
    title: string
    uploadedAt?: Date | string
    media: MediaCreateNestedOneWithoutMaterialsInput
    uploader: UserCreateNestedOneWithoutUploadedMaterialsInput
  }

  export type MaterialUncheckedCreateWithoutLessonInput = {
    id?: number
    title: string
    mediaId: number
    uploadedBy: number
    uploadedAt?: Date | string
  }

  export type MaterialCreateOrConnectWithoutLessonInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutLessonInput, MaterialUncheckedCreateWithoutLessonInput>
  }

  export type MaterialCreateManyLessonInputEnvelope = {
    data: MaterialCreateManyLessonInput | MaterialCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type ExerciseCreateWithoutLessonInput = {
    title: string
    description?: string | null
    dueAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    attachMedia?: MediaCreateNestedOneWithoutExerciseAttachmentsInput
    creator: UserCreateNestedOneWithoutCreatedExercisesInput
    submissions?: ExerciseSubmissionCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutLessonInput = {
    id?: number
    title: string
    description?: string | null
    attachMediaId?: number | null
    dueAt?: Date | string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    submissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutLessonInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutLessonInput, ExerciseUncheckedCreateWithoutLessonInput>
  }

  export type ExerciseCreateManyLessonInputEnvelope = {
    data: ExerciseCreateManyLessonInput | ExerciseCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type QuizCreateWithoutLessonInput = {
    title: string
    description?: string | null
    timeLimitSec?: number | null
    maxAttempts?: number
    shuffleQuestions?: boolean
    shuffleOptions?: boolean
    gradingMethod?: string
    showAnswersAfter?: string
    dueAt?: Date | string | null
    isPublished?: boolean
    totalPoints?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    creator: UserCreateNestedOneWithoutCreatedQuizzesInput
    sections?: QuizSectionCreateNestedManyWithoutQuizInput
    questionGroups?: QuizQuestionGroupCreateNestedManyWithoutQuizInput
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
    attempts?: QuizAttemptCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutLessonInput = {
    id?: number
    title: string
    description?: string | null
    timeLimitSec?: number | null
    maxAttempts?: number
    shuffleQuestions?: boolean
    shuffleOptions?: boolean
    gradingMethod?: string
    showAnswersAfter?: string
    dueAt?: Date | string | null
    isPublished?: boolean
    totalPoints?: Decimal | DecimalJsLike | number | string
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sections?: QuizSectionUncheckedCreateNestedManyWithoutQuizInput
    questionGroups?: QuizQuestionGroupUncheckedCreateNestedManyWithoutQuizInput
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutLessonInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutLessonInput, QuizUncheckedCreateWithoutLessonInput>
  }

  export type QuizCreateManyLessonInputEnvelope = {
    data: QuizCreateManyLessonInput | QuizCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type LessonCreateWithoutSubLessonsInput = {
    title: string
    content?: string | null
    lessonType?: $Enums.LessonType
    orderIndex?: number
    publishedAt?: Date | string | null
    classroom: ClassroomCreateNestedOneWithoutLessonsInput
    materials?: MaterialCreateNestedManyWithoutLessonInput
    exercises?: ExerciseCreateNestedManyWithoutLessonInput
    quizzes?: QuizCreateNestedManyWithoutLessonInput
    parent?: LessonCreateNestedOneWithoutSubLessonsInput
  }

  export type LessonUncheckedCreateWithoutSubLessonsInput = {
    id?: number
    classroomId: number
    parentId?: number | null
    title: string
    content?: string | null
    lessonType?: $Enums.LessonType
    orderIndex?: number
    publishedAt?: Date | string | null
    materials?: MaterialUncheckedCreateNestedManyWithoutLessonInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutLessonInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutSubLessonsInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutSubLessonsInput, LessonUncheckedCreateWithoutSubLessonsInput>
  }

  export type LessonCreateWithoutParentInput = {
    title: string
    content?: string | null
    lessonType?: $Enums.LessonType
    orderIndex?: number
    publishedAt?: Date | string | null
    classroom: ClassroomCreateNestedOneWithoutLessonsInput
    materials?: MaterialCreateNestedManyWithoutLessonInput
    exercises?: ExerciseCreateNestedManyWithoutLessonInput
    quizzes?: QuizCreateNestedManyWithoutLessonInput
    subLessons?: LessonCreateNestedManyWithoutParentInput
  }

  export type LessonUncheckedCreateWithoutParentInput = {
    id?: number
    classroomId: number
    title: string
    content?: string | null
    lessonType?: $Enums.LessonType
    orderIndex?: number
    publishedAt?: Date | string | null
    materials?: MaterialUncheckedCreateNestedManyWithoutLessonInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutLessonInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutLessonInput
    subLessons?: LessonUncheckedCreateNestedManyWithoutParentInput
  }

  export type LessonCreateOrConnectWithoutParentInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutParentInput, LessonUncheckedCreateWithoutParentInput>
  }

  export type LessonCreateManyParentInputEnvelope = {
    data: LessonCreateManyParentInput | LessonCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type ClassroomUpsertWithoutLessonsInput = {
    update: XOR<ClassroomUpdateWithoutLessonsInput, ClassroomUncheckedUpdateWithoutLessonsInput>
    create: XOR<ClassroomCreateWithoutLessonsInput, ClassroomUncheckedCreateWithoutLessonsInput>
    where?: ClassroomWhereInput
  }

  export type ClassroomUpdateToOneWithWhereWithoutLessonsInput = {
    where?: ClassroomWhereInput
    data: XOR<ClassroomUpdateWithoutLessonsInput, ClassroomUncheckedUpdateWithoutLessonsInput>
  }

  export type ClassroomUpdateWithoutLessonsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tutor?: UserUpdateOneRequiredWithoutTaughtClassroomsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedClassroomsNestedInput
    coverMedia?: MediaUpdateOneWithoutClassroomCoversNestedInput
    classroomStudents?: ClassroomStudentUpdateManyWithoutClassroomNestedInput
    joinRequests?: JoinRequestUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateWithoutLessonsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tutorId?: IntFieldUpdateOperationsInput | number
    coverMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classroomStudents?: ClassroomStudentUncheckedUpdateManyWithoutClassroomNestedInput
    joinRequests?: JoinRequestUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type MaterialUpsertWithWhereUniqueWithoutLessonInput = {
    where: MaterialWhereUniqueInput
    update: XOR<MaterialUpdateWithoutLessonInput, MaterialUncheckedUpdateWithoutLessonInput>
    create: XOR<MaterialCreateWithoutLessonInput, MaterialUncheckedCreateWithoutLessonInput>
  }

  export type MaterialUpdateWithWhereUniqueWithoutLessonInput = {
    where: MaterialWhereUniqueInput
    data: XOR<MaterialUpdateWithoutLessonInput, MaterialUncheckedUpdateWithoutLessonInput>
  }

  export type MaterialUpdateManyWithWhereWithoutLessonInput = {
    where: MaterialScalarWhereInput
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyWithoutLessonInput>
  }

  export type ExerciseUpsertWithWhereUniqueWithoutLessonInput = {
    where: ExerciseWhereUniqueInput
    update: XOR<ExerciseUpdateWithoutLessonInput, ExerciseUncheckedUpdateWithoutLessonInput>
    create: XOR<ExerciseCreateWithoutLessonInput, ExerciseUncheckedCreateWithoutLessonInput>
  }

  export type ExerciseUpdateWithWhereUniqueWithoutLessonInput = {
    where: ExerciseWhereUniqueInput
    data: XOR<ExerciseUpdateWithoutLessonInput, ExerciseUncheckedUpdateWithoutLessonInput>
  }

  export type ExerciseUpdateManyWithWhereWithoutLessonInput = {
    where: ExerciseScalarWhereInput
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyWithoutLessonInput>
  }

  export type QuizUpsertWithWhereUniqueWithoutLessonInput = {
    where: QuizWhereUniqueInput
    update: XOR<QuizUpdateWithoutLessonInput, QuizUncheckedUpdateWithoutLessonInput>
    create: XOR<QuizCreateWithoutLessonInput, QuizUncheckedCreateWithoutLessonInput>
  }

  export type QuizUpdateWithWhereUniqueWithoutLessonInput = {
    where: QuizWhereUniqueInput
    data: XOR<QuizUpdateWithoutLessonInput, QuizUncheckedUpdateWithoutLessonInput>
  }

  export type QuizUpdateManyWithWhereWithoutLessonInput = {
    where: QuizScalarWhereInput
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyWithoutLessonInput>
  }

  export type LessonUpsertWithoutSubLessonsInput = {
    update: XOR<LessonUpdateWithoutSubLessonsInput, LessonUncheckedUpdateWithoutSubLessonsInput>
    create: XOR<LessonCreateWithoutSubLessonsInput, LessonUncheckedCreateWithoutSubLessonsInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutSubLessonsInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutSubLessonsInput, LessonUncheckedUpdateWithoutSubLessonsInput>
  }

  export type LessonUpdateWithoutSubLessonsInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    lessonType?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    orderIndex?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classroom?: ClassroomUpdateOneRequiredWithoutLessonsNestedInput
    materials?: MaterialUpdateManyWithoutLessonNestedInput
    exercises?: ExerciseUpdateManyWithoutLessonNestedInput
    quizzes?: QuizUpdateManyWithoutLessonNestedInput
    parent?: LessonUpdateOneWithoutSubLessonsNestedInput
  }

  export type LessonUncheckedUpdateWithoutSubLessonsInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    lessonType?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    orderIndex?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    materials?: MaterialUncheckedUpdateManyWithoutLessonNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutLessonNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonUpsertWithWhereUniqueWithoutParentInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutParentInput, LessonUncheckedUpdateWithoutParentInput>
    create: XOR<LessonCreateWithoutParentInput, LessonUncheckedCreateWithoutParentInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutParentInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutParentInput, LessonUncheckedUpdateWithoutParentInput>
  }

  export type LessonUpdateManyWithWhereWithoutParentInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutParentInput>
  }

  export type LessonCreateWithoutMaterialsInput = {
    title: string
    content?: string | null
    lessonType?: $Enums.LessonType
    orderIndex?: number
    publishedAt?: Date | string | null
    classroom: ClassroomCreateNestedOneWithoutLessonsInput
    exercises?: ExerciseCreateNestedManyWithoutLessonInput
    quizzes?: QuizCreateNestedManyWithoutLessonInput
    parent?: LessonCreateNestedOneWithoutSubLessonsInput
    subLessons?: LessonCreateNestedManyWithoutParentInput
  }

  export type LessonUncheckedCreateWithoutMaterialsInput = {
    id?: number
    classroomId: number
    parentId?: number | null
    title: string
    content?: string | null
    lessonType?: $Enums.LessonType
    orderIndex?: number
    publishedAt?: Date | string | null
    exercises?: ExerciseUncheckedCreateNestedManyWithoutLessonInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutLessonInput
    subLessons?: LessonUncheckedCreateNestedManyWithoutParentInput
  }

  export type LessonCreateOrConnectWithoutMaterialsInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutMaterialsInput, LessonUncheckedCreateWithoutMaterialsInput>
  }

  export type MediaCreateWithoutMaterialsInput = {
    disk: string
    bucket?: string | null
    objectKey: string
    mimeType?: string | null
    sizeBytes?: bigint | number | null
    visibility?: string
    createdAt?: Date | string
    uploader?: UserCreateNestedOneWithoutUploadedMediaInput
    userAvatars?: UserCreateNestedManyWithoutAvatarMediaInput
    classroomCovers?: ClassroomCreateNestedManyWithoutCoverMediaInput
    exerciseAttachments?: ExerciseCreateNestedManyWithoutAttachMediaInput
    exerciseSubmissions?: ExerciseSubmissionCreateNestedManyWithoutMediaInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaCreateNestedManyWithoutMediaInput
    quizQuestionMedias?: QuizQuestionMediaCreateNestedManyWithoutMediaInput
    quizOptionMedias?: QuizOptionMediaCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutMaterialsInput = {
    id?: number
    disk: string
    bucket?: string | null
    objectKey: string
    mimeType?: string | null
    sizeBytes?: bigint | number | null
    visibility?: string
    uploadedBy?: number | null
    createdAt?: Date | string
    userAvatars?: UserUncheckedCreateNestedManyWithoutAvatarMediaInput
    classroomCovers?: ClassroomUncheckedCreateNestedManyWithoutCoverMediaInput
    exerciseAttachments?: ExerciseUncheckedCreateNestedManyWithoutAttachMediaInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutMediaInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaUncheckedCreateNestedManyWithoutMediaInput
    quizQuestionMedias?: QuizQuestionMediaUncheckedCreateNestedManyWithoutMediaInput
    quizOptionMedias?: QuizOptionMediaUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutMaterialsInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutMaterialsInput, MediaUncheckedCreateWithoutMaterialsInput>
  }

  export type UserCreateWithoutUploadedMaterialsInput = {
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarMedia?: MediaCreateNestedOneWithoutUserAvatarsInput
    uploadedMedia?: MediaCreateNestedManyWithoutUploaderInput
    taughtClassrooms?: ClassroomCreateNestedManyWithoutTutorInput
    createdClassrooms?: ClassroomCreateNestedManyWithoutCreatorInput
    classroomStudents?: ClassroomStudentCreateNestedManyWithoutStudentInput
    joinRequests?: JoinRequestCreateNestedManyWithoutStudentInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    exerciseSubmissions?: ExerciseSubmissionCreateNestedManyWithoutStudentInput
    createdQuizzes?: QuizCreateNestedManyWithoutCreatorInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutStudentInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUploadedMaterialsInput = {
    id?: number
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    avatarMediaId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedMedia?: MediaUncheckedCreateNestedManyWithoutUploaderInput
    taughtClassrooms?: ClassroomUncheckedCreateNestedManyWithoutTutorInput
    createdClassrooms?: ClassroomUncheckedCreateNestedManyWithoutCreatorInput
    classroomStudents?: ClassroomStudentUncheckedCreateNestedManyWithoutStudentInput
    joinRequests?: JoinRequestUncheckedCreateNestedManyWithoutStudentInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutStudentInput
    createdQuizzes?: QuizUncheckedCreateNestedManyWithoutCreatorInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutStudentInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUploadedMaterialsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedMaterialsInput, UserUncheckedCreateWithoutUploadedMaterialsInput>
  }

  export type LessonUpsertWithoutMaterialsInput = {
    update: XOR<LessonUpdateWithoutMaterialsInput, LessonUncheckedUpdateWithoutMaterialsInput>
    create: XOR<LessonCreateWithoutMaterialsInput, LessonUncheckedCreateWithoutMaterialsInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutMaterialsInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutMaterialsInput, LessonUncheckedUpdateWithoutMaterialsInput>
  }

  export type LessonUpdateWithoutMaterialsInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    lessonType?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    orderIndex?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classroom?: ClassroomUpdateOneRequiredWithoutLessonsNestedInput
    exercises?: ExerciseUpdateManyWithoutLessonNestedInput
    quizzes?: QuizUpdateManyWithoutLessonNestedInput
    parent?: LessonUpdateOneWithoutSubLessonsNestedInput
    subLessons?: LessonUpdateManyWithoutParentNestedInput
  }

  export type LessonUncheckedUpdateWithoutMaterialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    lessonType?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    orderIndex?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exercises?: ExerciseUncheckedUpdateManyWithoutLessonNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutLessonNestedInput
    subLessons?: LessonUncheckedUpdateManyWithoutParentNestedInput
  }

  export type MediaUpsertWithoutMaterialsInput = {
    update: XOR<MediaUpdateWithoutMaterialsInput, MediaUncheckedUpdateWithoutMaterialsInput>
    create: XOR<MediaCreateWithoutMaterialsInput, MediaUncheckedCreateWithoutMaterialsInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutMaterialsInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutMaterialsInput, MediaUncheckedUpdateWithoutMaterialsInput>
  }

  export type MediaUpdateWithoutMaterialsInput = {
    disk?: StringFieldUpdateOperationsInput | string
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    objectKey?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneWithoutUploadedMediaNestedInput
    userAvatars?: UserUpdateManyWithoutAvatarMediaNestedInput
    classroomCovers?: ClassroomUpdateManyWithoutCoverMediaNestedInput
    exerciseAttachments?: ExerciseUpdateManyWithoutAttachMediaNestedInput
    exerciseSubmissions?: ExerciseSubmissionUpdateManyWithoutMediaNestedInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaUpdateManyWithoutMediaNestedInput
    quizQuestionMedias?: QuizQuestionMediaUpdateManyWithoutMediaNestedInput
    quizOptionMedias?: QuizOptionMediaUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutMaterialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    disk?: StringFieldUpdateOperationsInput | string
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    objectKey?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    visibility?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAvatars?: UserUncheckedUpdateManyWithoutAvatarMediaNestedInput
    classroomCovers?: ClassroomUncheckedUpdateManyWithoutCoverMediaNestedInput
    exerciseAttachments?: ExerciseUncheckedUpdateManyWithoutAttachMediaNestedInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedUpdateManyWithoutMediaNestedInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaUncheckedUpdateManyWithoutMediaNestedInput
    quizQuestionMedias?: QuizQuestionMediaUncheckedUpdateManyWithoutMediaNestedInput
    quizOptionMedias?: QuizOptionMediaUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type UserUpsertWithoutUploadedMaterialsInput = {
    update: XOR<UserUpdateWithoutUploadedMaterialsInput, UserUncheckedUpdateWithoutUploadedMaterialsInput>
    create: XOR<UserCreateWithoutUploadedMaterialsInput, UserUncheckedCreateWithoutUploadedMaterialsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedMaterialsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedMaterialsInput, UserUncheckedUpdateWithoutUploadedMaterialsInput>
  }

  export type UserUpdateWithoutUploadedMaterialsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarMedia?: MediaUpdateOneWithoutUserAvatarsNestedInput
    uploadedMedia?: MediaUpdateManyWithoutUploaderNestedInput
    taughtClassrooms?: ClassroomUpdateManyWithoutTutorNestedInput
    createdClassrooms?: ClassroomUpdateManyWithoutCreatorNestedInput
    classroomStudents?: ClassroomStudentUpdateManyWithoutStudentNestedInput
    joinRequests?: JoinRequestUpdateManyWithoutStudentNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    exerciseSubmissions?: ExerciseSubmissionUpdateManyWithoutStudentNestedInput
    createdQuizzes?: QuizUpdateManyWithoutCreatorNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutStudentNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedMaterialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatarMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedMedia?: MediaUncheckedUpdateManyWithoutUploaderNestedInput
    taughtClassrooms?: ClassroomUncheckedUpdateManyWithoutTutorNestedInput
    createdClassrooms?: ClassroomUncheckedUpdateManyWithoutCreatorNestedInput
    classroomStudents?: ClassroomStudentUncheckedUpdateManyWithoutStudentNestedInput
    joinRequests?: JoinRequestUncheckedUpdateManyWithoutStudentNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    createdQuizzes?: QuizUncheckedUpdateManyWithoutCreatorNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutStudentNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LessonCreateWithoutExercisesInput = {
    title: string
    content?: string | null
    lessonType?: $Enums.LessonType
    orderIndex?: number
    publishedAt?: Date | string | null
    classroom: ClassroomCreateNestedOneWithoutLessonsInput
    materials?: MaterialCreateNestedManyWithoutLessonInput
    quizzes?: QuizCreateNestedManyWithoutLessonInput
    parent?: LessonCreateNestedOneWithoutSubLessonsInput
    subLessons?: LessonCreateNestedManyWithoutParentInput
  }

  export type LessonUncheckedCreateWithoutExercisesInput = {
    id?: number
    classroomId: number
    parentId?: number | null
    title: string
    content?: string | null
    lessonType?: $Enums.LessonType
    orderIndex?: number
    publishedAt?: Date | string | null
    materials?: MaterialUncheckedCreateNestedManyWithoutLessonInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutLessonInput
    subLessons?: LessonUncheckedCreateNestedManyWithoutParentInput
  }

  export type LessonCreateOrConnectWithoutExercisesInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutExercisesInput, LessonUncheckedCreateWithoutExercisesInput>
  }

  export type MediaCreateWithoutExerciseAttachmentsInput = {
    disk: string
    bucket?: string | null
    objectKey: string
    mimeType?: string | null
    sizeBytes?: bigint | number | null
    visibility?: string
    createdAt?: Date | string
    uploader?: UserCreateNestedOneWithoutUploadedMediaInput
    userAvatars?: UserCreateNestedManyWithoutAvatarMediaInput
    classroomCovers?: ClassroomCreateNestedManyWithoutCoverMediaInput
    materials?: MaterialCreateNestedManyWithoutMediaInput
    exerciseSubmissions?: ExerciseSubmissionCreateNestedManyWithoutMediaInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaCreateNestedManyWithoutMediaInput
    quizQuestionMedias?: QuizQuestionMediaCreateNestedManyWithoutMediaInput
    quizOptionMedias?: QuizOptionMediaCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutExerciseAttachmentsInput = {
    id?: number
    disk: string
    bucket?: string | null
    objectKey: string
    mimeType?: string | null
    sizeBytes?: bigint | number | null
    visibility?: string
    uploadedBy?: number | null
    createdAt?: Date | string
    userAvatars?: UserUncheckedCreateNestedManyWithoutAvatarMediaInput
    classroomCovers?: ClassroomUncheckedCreateNestedManyWithoutCoverMediaInput
    materials?: MaterialUncheckedCreateNestedManyWithoutMediaInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutMediaInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaUncheckedCreateNestedManyWithoutMediaInput
    quizQuestionMedias?: QuizQuestionMediaUncheckedCreateNestedManyWithoutMediaInput
    quizOptionMedias?: QuizOptionMediaUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutExerciseAttachmentsInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutExerciseAttachmentsInput, MediaUncheckedCreateWithoutExerciseAttachmentsInput>
  }

  export type UserCreateWithoutCreatedExercisesInput = {
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarMedia?: MediaCreateNestedOneWithoutUserAvatarsInput
    uploadedMedia?: MediaCreateNestedManyWithoutUploaderInput
    taughtClassrooms?: ClassroomCreateNestedManyWithoutTutorInput
    createdClassrooms?: ClassroomCreateNestedManyWithoutCreatorInput
    classroomStudents?: ClassroomStudentCreateNestedManyWithoutStudentInput
    joinRequests?: JoinRequestCreateNestedManyWithoutStudentInput
    uploadedMaterials?: MaterialCreateNestedManyWithoutUploaderInput
    exerciseSubmissions?: ExerciseSubmissionCreateNestedManyWithoutStudentInput
    createdQuizzes?: QuizCreateNestedManyWithoutCreatorInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutStudentInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedExercisesInput = {
    id?: number
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    avatarMediaId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedMedia?: MediaUncheckedCreateNestedManyWithoutUploaderInput
    taughtClassrooms?: ClassroomUncheckedCreateNestedManyWithoutTutorInput
    createdClassrooms?: ClassroomUncheckedCreateNestedManyWithoutCreatorInput
    classroomStudents?: ClassroomStudentUncheckedCreateNestedManyWithoutStudentInput
    joinRequests?: JoinRequestUncheckedCreateNestedManyWithoutStudentInput
    uploadedMaterials?: MaterialUncheckedCreateNestedManyWithoutUploaderInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutStudentInput
    createdQuizzes?: QuizUncheckedCreateNestedManyWithoutCreatorInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutStudentInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedExercisesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedExercisesInput, UserUncheckedCreateWithoutCreatedExercisesInput>
  }

  export type ExerciseSubmissionCreateWithoutExerciseInput = {
    submittedAt?: Date | string
    score?: Decimal | DecimalJsLike | number | string | null
    comment?: string | null
    gradedAt?: Date | string | null
    student: UserCreateNestedOneWithoutExerciseSubmissionsInput
    media: MediaCreateNestedOneWithoutExerciseSubmissionsInput
  }

  export type ExerciseSubmissionUncheckedCreateWithoutExerciseInput = {
    id?: number
    studentId: number
    mediaId: number
    submittedAt?: Date | string
    score?: Decimal | DecimalJsLike | number | string | null
    comment?: string | null
    gradedAt?: Date | string | null
  }

  export type ExerciseSubmissionCreateOrConnectWithoutExerciseInput = {
    where: ExerciseSubmissionWhereUniqueInput
    create: XOR<ExerciseSubmissionCreateWithoutExerciseInput, ExerciseSubmissionUncheckedCreateWithoutExerciseInput>
  }

  export type ExerciseSubmissionCreateManyExerciseInputEnvelope = {
    data: ExerciseSubmissionCreateManyExerciseInput | ExerciseSubmissionCreateManyExerciseInput[]
    skipDuplicates?: boolean
  }

  export type LessonUpsertWithoutExercisesInput = {
    update: XOR<LessonUpdateWithoutExercisesInput, LessonUncheckedUpdateWithoutExercisesInput>
    create: XOR<LessonCreateWithoutExercisesInput, LessonUncheckedCreateWithoutExercisesInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutExercisesInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutExercisesInput, LessonUncheckedUpdateWithoutExercisesInput>
  }

  export type LessonUpdateWithoutExercisesInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    lessonType?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    orderIndex?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classroom?: ClassroomUpdateOneRequiredWithoutLessonsNestedInput
    materials?: MaterialUpdateManyWithoutLessonNestedInput
    quizzes?: QuizUpdateManyWithoutLessonNestedInput
    parent?: LessonUpdateOneWithoutSubLessonsNestedInput
    subLessons?: LessonUpdateManyWithoutParentNestedInput
  }

  export type LessonUncheckedUpdateWithoutExercisesInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    lessonType?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    orderIndex?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    materials?: MaterialUncheckedUpdateManyWithoutLessonNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutLessonNestedInput
    subLessons?: LessonUncheckedUpdateManyWithoutParentNestedInput
  }

  export type MediaUpsertWithoutExerciseAttachmentsInput = {
    update: XOR<MediaUpdateWithoutExerciseAttachmentsInput, MediaUncheckedUpdateWithoutExerciseAttachmentsInput>
    create: XOR<MediaCreateWithoutExerciseAttachmentsInput, MediaUncheckedCreateWithoutExerciseAttachmentsInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutExerciseAttachmentsInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutExerciseAttachmentsInput, MediaUncheckedUpdateWithoutExerciseAttachmentsInput>
  }

  export type MediaUpdateWithoutExerciseAttachmentsInput = {
    disk?: StringFieldUpdateOperationsInput | string
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    objectKey?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneWithoutUploadedMediaNestedInput
    userAvatars?: UserUpdateManyWithoutAvatarMediaNestedInput
    classroomCovers?: ClassroomUpdateManyWithoutCoverMediaNestedInput
    materials?: MaterialUpdateManyWithoutMediaNestedInput
    exerciseSubmissions?: ExerciseSubmissionUpdateManyWithoutMediaNestedInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaUpdateManyWithoutMediaNestedInput
    quizQuestionMedias?: QuizQuestionMediaUpdateManyWithoutMediaNestedInput
    quizOptionMedias?: QuizOptionMediaUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutExerciseAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    disk?: StringFieldUpdateOperationsInput | string
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    objectKey?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    visibility?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAvatars?: UserUncheckedUpdateManyWithoutAvatarMediaNestedInput
    classroomCovers?: ClassroomUncheckedUpdateManyWithoutCoverMediaNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutMediaNestedInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedUpdateManyWithoutMediaNestedInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaUncheckedUpdateManyWithoutMediaNestedInput
    quizQuestionMedias?: QuizQuestionMediaUncheckedUpdateManyWithoutMediaNestedInput
    quizOptionMedias?: QuizOptionMediaUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type UserUpsertWithoutCreatedExercisesInput = {
    update: XOR<UserUpdateWithoutCreatedExercisesInput, UserUncheckedUpdateWithoutCreatedExercisesInput>
    create: XOR<UserCreateWithoutCreatedExercisesInput, UserUncheckedCreateWithoutCreatedExercisesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedExercisesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedExercisesInput, UserUncheckedUpdateWithoutCreatedExercisesInput>
  }

  export type UserUpdateWithoutCreatedExercisesInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarMedia?: MediaUpdateOneWithoutUserAvatarsNestedInput
    uploadedMedia?: MediaUpdateManyWithoutUploaderNestedInput
    taughtClassrooms?: ClassroomUpdateManyWithoutTutorNestedInput
    createdClassrooms?: ClassroomUpdateManyWithoutCreatorNestedInput
    classroomStudents?: ClassroomStudentUpdateManyWithoutStudentNestedInput
    joinRequests?: JoinRequestUpdateManyWithoutStudentNestedInput
    uploadedMaterials?: MaterialUpdateManyWithoutUploaderNestedInput
    exerciseSubmissions?: ExerciseSubmissionUpdateManyWithoutStudentNestedInput
    createdQuizzes?: QuizUpdateManyWithoutCreatorNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutStudentNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedExercisesInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatarMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedMedia?: MediaUncheckedUpdateManyWithoutUploaderNestedInput
    taughtClassrooms?: ClassroomUncheckedUpdateManyWithoutTutorNestedInput
    createdClassrooms?: ClassroomUncheckedUpdateManyWithoutCreatorNestedInput
    classroomStudents?: ClassroomStudentUncheckedUpdateManyWithoutStudentNestedInput
    joinRequests?: JoinRequestUncheckedUpdateManyWithoutStudentNestedInput
    uploadedMaterials?: MaterialUncheckedUpdateManyWithoutUploaderNestedInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    createdQuizzes?: QuizUncheckedUpdateManyWithoutCreatorNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutStudentNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ExerciseSubmissionUpsertWithWhereUniqueWithoutExerciseInput = {
    where: ExerciseSubmissionWhereUniqueInput
    update: XOR<ExerciseSubmissionUpdateWithoutExerciseInput, ExerciseSubmissionUncheckedUpdateWithoutExerciseInput>
    create: XOR<ExerciseSubmissionCreateWithoutExerciseInput, ExerciseSubmissionUncheckedCreateWithoutExerciseInput>
  }

  export type ExerciseSubmissionUpdateWithWhereUniqueWithoutExerciseInput = {
    where: ExerciseSubmissionWhereUniqueInput
    data: XOR<ExerciseSubmissionUpdateWithoutExerciseInput, ExerciseSubmissionUncheckedUpdateWithoutExerciseInput>
  }

  export type ExerciseSubmissionUpdateManyWithWhereWithoutExerciseInput = {
    where: ExerciseSubmissionScalarWhereInput
    data: XOR<ExerciseSubmissionUpdateManyMutationInput, ExerciseSubmissionUncheckedUpdateManyWithoutExerciseInput>
  }

  export type ExerciseCreateWithoutSubmissionsInput = {
    title: string
    description?: string | null
    dueAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lesson?: LessonCreateNestedOneWithoutExercisesInput
    attachMedia?: MediaCreateNestedOneWithoutExerciseAttachmentsInput
    creator: UserCreateNestedOneWithoutCreatedExercisesInput
  }

  export type ExerciseUncheckedCreateWithoutSubmissionsInput = {
    id?: number
    lessonId: number
    title: string
    description?: string | null
    attachMediaId?: number | null
    dueAt?: Date | string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ExerciseCreateOrConnectWithoutSubmissionsInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutSubmissionsInput, ExerciseUncheckedCreateWithoutSubmissionsInput>
  }

  export type UserCreateWithoutExerciseSubmissionsInput = {
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarMedia?: MediaCreateNestedOneWithoutUserAvatarsInput
    uploadedMedia?: MediaCreateNestedManyWithoutUploaderInput
    taughtClassrooms?: ClassroomCreateNestedManyWithoutTutorInput
    createdClassrooms?: ClassroomCreateNestedManyWithoutCreatorInput
    classroomStudents?: ClassroomStudentCreateNestedManyWithoutStudentInput
    joinRequests?: JoinRequestCreateNestedManyWithoutStudentInput
    uploadedMaterials?: MaterialCreateNestedManyWithoutUploaderInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    createdQuizzes?: QuizCreateNestedManyWithoutCreatorInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutStudentInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutExerciseSubmissionsInput = {
    id?: number
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    avatarMediaId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedMedia?: MediaUncheckedCreateNestedManyWithoutUploaderInput
    taughtClassrooms?: ClassroomUncheckedCreateNestedManyWithoutTutorInput
    createdClassrooms?: ClassroomUncheckedCreateNestedManyWithoutCreatorInput
    classroomStudents?: ClassroomStudentUncheckedCreateNestedManyWithoutStudentInput
    joinRequests?: JoinRequestUncheckedCreateNestedManyWithoutStudentInput
    uploadedMaterials?: MaterialUncheckedCreateNestedManyWithoutUploaderInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    createdQuizzes?: QuizUncheckedCreateNestedManyWithoutCreatorInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutStudentInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutExerciseSubmissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExerciseSubmissionsInput, UserUncheckedCreateWithoutExerciseSubmissionsInput>
  }

  export type MediaCreateWithoutExerciseSubmissionsInput = {
    disk: string
    bucket?: string | null
    objectKey: string
    mimeType?: string | null
    sizeBytes?: bigint | number | null
    visibility?: string
    createdAt?: Date | string
    uploader?: UserCreateNestedOneWithoutUploadedMediaInput
    userAvatars?: UserCreateNestedManyWithoutAvatarMediaInput
    classroomCovers?: ClassroomCreateNestedManyWithoutCoverMediaInput
    materials?: MaterialCreateNestedManyWithoutMediaInput
    exerciseAttachments?: ExerciseCreateNestedManyWithoutAttachMediaInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaCreateNestedManyWithoutMediaInput
    quizQuestionMedias?: QuizQuestionMediaCreateNestedManyWithoutMediaInput
    quizOptionMedias?: QuizOptionMediaCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutExerciseSubmissionsInput = {
    id?: number
    disk: string
    bucket?: string | null
    objectKey: string
    mimeType?: string | null
    sizeBytes?: bigint | number | null
    visibility?: string
    uploadedBy?: number | null
    createdAt?: Date | string
    userAvatars?: UserUncheckedCreateNestedManyWithoutAvatarMediaInput
    classroomCovers?: ClassroomUncheckedCreateNestedManyWithoutCoverMediaInput
    materials?: MaterialUncheckedCreateNestedManyWithoutMediaInput
    exerciseAttachments?: ExerciseUncheckedCreateNestedManyWithoutAttachMediaInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaUncheckedCreateNestedManyWithoutMediaInput
    quizQuestionMedias?: QuizQuestionMediaUncheckedCreateNestedManyWithoutMediaInput
    quizOptionMedias?: QuizOptionMediaUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutExerciseSubmissionsInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutExerciseSubmissionsInput, MediaUncheckedCreateWithoutExerciseSubmissionsInput>
  }

  export type ExerciseUpsertWithoutSubmissionsInput = {
    update: XOR<ExerciseUpdateWithoutSubmissionsInput, ExerciseUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<ExerciseCreateWithoutSubmissionsInput, ExerciseUncheckedCreateWithoutSubmissionsInput>
    where?: ExerciseWhereInput
  }

  export type ExerciseUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: ExerciseWhereInput
    data: XOR<ExerciseUpdateWithoutSubmissionsInput, ExerciseUncheckedUpdateWithoutSubmissionsInput>
  }

  export type ExerciseUpdateWithoutSubmissionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson?: LessonUpdateOneWithoutExercisesNestedInput
    attachMedia?: MediaUpdateOneWithoutExerciseAttachmentsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedExercisesNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutSubmissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpsertWithoutExerciseSubmissionsInput = {
    update: XOR<UserUpdateWithoutExerciseSubmissionsInput, UserUncheckedUpdateWithoutExerciseSubmissionsInput>
    create: XOR<UserCreateWithoutExerciseSubmissionsInput, UserUncheckedCreateWithoutExerciseSubmissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExerciseSubmissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExerciseSubmissionsInput, UserUncheckedUpdateWithoutExerciseSubmissionsInput>
  }

  export type UserUpdateWithoutExerciseSubmissionsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarMedia?: MediaUpdateOneWithoutUserAvatarsNestedInput
    uploadedMedia?: MediaUpdateManyWithoutUploaderNestedInput
    taughtClassrooms?: ClassroomUpdateManyWithoutTutorNestedInput
    createdClassrooms?: ClassroomUpdateManyWithoutCreatorNestedInput
    classroomStudents?: ClassroomStudentUpdateManyWithoutStudentNestedInput
    joinRequests?: JoinRequestUpdateManyWithoutStudentNestedInput
    uploadedMaterials?: MaterialUpdateManyWithoutUploaderNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    createdQuizzes?: QuizUpdateManyWithoutCreatorNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutStudentNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutExerciseSubmissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatarMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedMedia?: MediaUncheckedUpdateManyWithoutUploaderNestedInput
    taughtClassrooms?: ClassroomUncheckedUpdateManyWithoutTutorNestedInput
    createdClassrooms?: ClassroomUncheckedUpdateManyWithoutCreatorNestedInput
    classroomStudents?: ClassroomStudentUncheckedUpdateManyWithoutStudentNestedInput
    joinRequests?: JoinRequestUncheckedUpdateManyWithoutStudentNestedInput
    uploadedMaterials?: MaterialUncheckedUpdateManyWithoutUploaderNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuizzes?: QuizUncheckedUpdateManyWithoutCreatorNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutStudentNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MediaUpsertWithoutExerciseSubmissionsInput = {
    update: XOR<MediaUpdateWithoutExerciseSubmissionsInput, MediaUncheckedUpdateWithoutExerciseSubmissionsInput>
    create: XOR<MediaCreateWithoutExerciseSubmissionsInput, MediaUncheckedCreateWithoutExerciseSubmissionsInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutExerciseSubmissionsInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutExerciseSubmissionsInput, MediaUncheckedUpdateWithoutExerciseSubmissionsInput>
  }

  export type MediaUpdateWithoutExerciseSubmissionsInput = {
    disk?: StringFieldUpdateOperationsInput | string
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    objectKey?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneWithoutUploadedMediaNestedInput
    userAvatars?: UserUpdateManyWithoutAvatarMediaNestedInput
    classroomCovers?: ClassroomUpdateManyWithoutCoverMediaNestedInput
    materials?: MaterialUpdateManyWithoutMediaNestedInput
    exerciseAttachments?: ExerciseUpdateManyWithoutAttachMediaNestedInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaUpdateManyWithoutMediaNestedInput
    quizQuestionMedias?: QuizQuestionMediaUpdateManyWithoutMediaNestedInput
    quizOptionMedias?: QuizOptionMediaUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutExerciseSubmissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    disk?: StringFieldUpdateOperationsInput | string
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    objectKey?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    visibility?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAvatars?: UserUncheckedUpdateManyWithoutAvatarMediaNestedInput
    classroomCovers?: ClassroomUncheckedUpdateManyWithoutCoverMediaNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutMediaNestedInput
    exerciseAttachments?: ExerciseUncheckedUpdateManyWithoutAttachMediaNestedInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaUncheckedUpdateManyWithoutMediaNestedInput
    quizQuestionMedias?: QuizQuestionMediaUncheckedUpdateManyWithoutMediaNestedInput
    quizOptionMedias?: QuizOptionMediaUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type LessonCreateWithoutQuizzesInput = {
    title: string
    content?: string | null
    lessonType?: $Enums.LessonType
    orderIndex?: number
    publishedAt?: Date | string | null
    classroom: ClassroomCreateNestedOneWithoutLessonsInput
    materials?: MaterialCreateNestedManyWithoutLessonInput
    exercises?: ExerciseCreateNestedManyWithoutLessonInput
    parent?: LessonCreateNestedOneWithoutSubLessonsInput
    subLessons?: LessonCreateNestedManyWithoutParentInput
  }

  export type LessonUncheckedCreateWithoutQuizzesInput = {
    id?: number
    classroomId: number
    parentId?: number | null
    title: string
    content?: string | null
    lessonType?: $Enums.LessonType
    orderIndex?: number
    publishedAt?: Date | string | null
    materials?: MaterialUncheckedCreateNestedManyWithoutLessonInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutLessonInput
    subLessons?: LessonUncheckedCreateNestedManyWithoutParentInput
  }

  export type LessonCreateOrConnectWithoutQuizzesInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutQuizzesInput, LessonUncheckedCreateWithoutQuizzesInput>
  }

  export type UserCreateWithoutCreatedQuizzesInput = {
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarMedia?: MediaCreateNestedOneWithoutUserAvatarsInput
    uploadedMedia?: MediaCreateNestedManyWithoutUploaderInput
    taughtClassrooms?: ClassroomCreateNestedManyWithoutTutorInput
    createdClassrooms?: ClassroomCreateNestedManyWithoutCreatorInput
    classroomStudents?: ClassroomStudentCreateNestedManyWithoutStudentInput
    joinRequests?: JoinRequestCreateNestedManyWithoutStudentInput
    uploadedMaterials?: MaterialCreateNestedManyWithoutUploaderInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    exerciseSubmissions?: ExerciseSubmissionCreateNestedManyWithoutStudentInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutStudentInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedQuizzesInput = {
    id?: number
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    avatarMediaId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedMedia?: MediaUncheckedCreateNestedManyWithoutUploaderInput
    taughtClassrooms?: ClassroomUncheckedCreateNestedManyWithoutTutorInput
    createdClassrooms?: ClassroomUncheckedCreateNestedManyWithoutCreatorInput
    classroomStudents?: ClassroomStudentUncheckedCreateNestedManyWithoutStudentInput
    joinRequests?: JoinRequestUncheckedCreateNestedManyWithoutStudentInput
    uploadedMaterials?: MaterialUncheckedCreateNestedManyWithoutUploaderInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutStudentInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutStudentInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedQuizzesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedQuizzesInput, UserUncheckedCreateWithoutCreatedQuizzesInput>
  }

  export type QuizSectionCreateWithoutQuizInput = {
    title: string
    description?: string | null
    orderIndex?: number
    questionGroups?: QuizQuestionGroupCreateNestedManyWithoutSectionInput
    questions?: QuizQuestionCreateNestedManyWithoutSectionInput
  }

  export type QuizSectionUncheckedCreateWithoutQuizInput = {
    id?: number
    title: string
    description?: string | null
    orderIndex?: number
    questionGroups?: QuizQuestionGroupUncheckedCreateNestedManyWithoutSectionInput
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutSectionInput
  }

  export type QuizSectionCreateOrConnectWithoutQuizInput = {
    where: QuizSectionWhereUniqueInput
    create: XOR<QuizSectionCreateWithoutQuizInput, QuizSectionUncheckedCreateWithoutQuizInput>
  }

  export type QuizSectionCreateManyQuizInputEnvelope = {
    data: QuizSectionCreateManyQuizInput | QuizSectionCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type QuizQuestionGroupCreateWithoutQuizInput = {
    title?: string | null
    introText?: string | null
    orderIndex?: number
    shuffleInside?: boolean
    pointsPolicy?: string
    createdAt?: Date | string
    section?: QuizSectionCreateNestedOneWithoutQuestionGroupsInput
    questions?: QuizQuestionCreateNestedManyWithoutGroupInput
    medias?: QuizQuestionGroupMediaCreateNestedManyWithoutGroupInput
  }

  export type QuizQuestionGroupUncheckedCreateWithoutQuizInput = {
    id?: number
    sectionId?: number | null
    title?: string | null
    introText?: string | null
    orderIndex?: number
    shuffleInside?: boolean
    pointsPolicy?: string
    createdAt?: Date | string
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutGroupInput
    medias?: QuizQuestionGroupMediaUncheckedCreateNestedManyWithoutGroupInput
  }

  export type QuizQuestionGroupCreateOrConnectWithoutQuizInput = {
    where: QuizQuestionGroupWhereUniqueInput
    create: XOR<QuizQuestionGroupCreateWithoutQuizInput, QuizQuestionGroupUncheckedCreateWithoutQuizInput>
  }

  export type QuizQuestionGroupCreateManyQuizInputEnvelope = {
    data: QuizQuestionGroupCreateManyQuizInput | QuizQuestionGroupCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type QuizQuestionCreateWithoutQuizInput = {
    content: string
    explanation?: string | null
    questionType?: string
    points?: Decimal | DecimalJsLike | number | string
    orderIndex?: number
    section?: QuizSectionCreateNestedOneWithoutQuestionsInput
    group?: QuizQuestionGroupCreateNestedOneWithoutQuestionsInput
    options?: QuizOptionCreateNestedManyWithoutQuestionInput
    answers?: QuizAnswerCreateNestedManyWithoutQuestionInput
    medias?: QuizQuestionMediaCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionUncheckedCreateWithoutQuizInput = {
    id?: number
    sectionId?: number | null
    groupId?: number | null
    content: string
    explanation?: string | null
    questionType?: string
    points?: Decimal | DecimalJsLike | number | string
    orderIndex?: number
    options?: QuizOptionUncheckedCreateNestedManyWithoutQuestionInput
    answers?: QuizAnswerUncheckedCreateNestedManyWithoutQuestionInput
    medias?: QuizQuestionMediaUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionCreateOrConnectWithoutQuizInput = {
    where: QuizQuestionWhereUniqueInput
    create: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput>
  }

  export type QuizQuestionCreateManyQuizInputEnvelope = {
    data: QuizQuestionCreateManyQuizInput | QuizQuestionCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type QuizAttemptCreateWithoutQuizInput = {
    startedAt?: Date | string
    submittedAt?: Date | string | null
    status?: string
    scoreRaw?: Decimal | DecimalJsLike | number | string | null
    scoreScaled10?: Decimal | DecimalJsLike | number | string | null
    student: UserCreateNestedOneWithoutQuizAttemptsInput
    answers?: QuizAnswerCreateNestedManyWithoutAttemptInput
  }

  export type QuizAttemptUncheckedCreateWithoutQuizInput = {
    id?: number
    studentId: number
    startedAt?: Date | string
    submittedAt?: Date | string | null
    status?: string
    scoreRaw?: Decimal | DecimalJsLike | number | string | null
    scoreScaled10?: Decimal | DecimalJsLike | number | string | null
    answers?: QuizAnswerUncheckedCreateNestedManyWithoutAttemptInput
  }

  export type QuizAttemptCreateOrConnectWithoutQuizInput = {
    where: QuizAttemptWhereUniqueInput
    create: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput>
  }

  export type QuizAttemptCreateManyQuizInputEnvelope = {
    data: QuizAttemptCreateManyQuizInput | QuizAttemptCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type LessonUpsertWithoutQuizzesInput = {
    update: XOR<LessonUpdateWithoutQuizzesInput, LessonUncheckedUpdateWithoutQuizzesInput>
    create: XOR<LessonCreateWithoutQuizzesInput, LessonUncheckedCreateWithoutQuizzesInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutQuizzesInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutQuizzesInput, LessonUncheckedUpdateWithoutQuizzesInput>
  }

  export type LessonUpdateWithoutQuizzesInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    lessonType?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    orderIndex?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classroom?: ClassroomUpdateOneRequiredWithoutLessonsNestedInput
    materials?: MaterialUpdateManyWithoutLessonNestedInput
    exercises?: ExerciseUpdateManyWithoutLessonNestedInput
    parent?: LessonUpdateOneWithoutSubLessonsNestedInput
    subLessons?: LessonUpdateManyWithoutParentNestedInput
  }

  export type LessonUncheckedUpdateWithoutQuizzesInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    lessonType?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    orderIndex?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    materials?: MaterialUncheckedUpdateManyWithoutLessonNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutLessonNestedInput
    subLessons?: LessonUncheckedUpdateManyWithoutParentNestedInput
  }

  export type UserUpsertWithoutCreatedQuizzesInput = {
    update: XOR<UserUpdateWithoutCreatedQuizzesInput, UserUncheckedUpdateWithoutCreatedQuizzesInput>
    create: XOR<UserCreateWithoutCreatedQuizzesInput, UserUncheckedCreateWithoutCreatedQuizzesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedQuizzesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedQuizzesInput, UserUncheckedUpdateWithoutCreatedQuizzesInput>
  }

  export type UserUpdateWithoutCreatedQuizzesInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarMedia?: MediaUpdateOneWithoutUserAvatarsNestedInput
    uploadedMedia?: MediaUpdateManyWithoutUploaderNestedInput
    taughtClassrooms?: ClassroomUpdateManyWithoutTutorNestedInput
    createdClassrooms?: ClassroomUpdateManyWithoutCreatorNestedInput
    classroomStudents?: ClassroomStudentUpdateManyWithoutStudentNestedInput
    joinRequests?: JoinRequestUpdateManyWithoutStudentNestedInput
    uploadedMaterials?: MaterialUpdateManyWithoutUploaderNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    exerciseSubmissions?: ExerciseSubmissionUpdateManyWithoutStudentNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutStudentNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedQuizzesInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatarMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedMedia?: MediaUncheckedUpdateManyWithoutUploaderNestedInput
    taughtClassrooms?: ClassroomUncheckedUpdateManyWithoutTutorNestedInput
    createdClassrooms?: ClassroomUncheckedUpdateManyWithoutCreatorNestedInput
    classroomStudents?: ClassroomStudentUncheckedUpdateManyWithoutStudentNestedInput
    joinRequests?: JoinRequestUncheckedUpdateManyWithoutStudentNestedInput
    uploadedMaterials?: MaterialUncheckedUpdateManyWithoutUploaderNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutStudentNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type QuizSectionUpsertWithWhereUniqueWithoutQuizInput = {
    where: QuizSectionWhereUniqueInput
    update: XOR<QuizSectionUpdateWithoutQuizInput, QuizSectionUncheckedUpdateWithoutQuizInput>
    create: XOR<QuizSectionCreateWithoutQuizInput, QuizSectionUncheckedCreateWithoutQuizInput>
  }

  export type QuizSectionUpdateWithWhereUniqueWithoutQuizInput = {
    where: QuizSectionWhereUniqueInput
    data: XOR<QuizSectionUpdateWithoutQuizInput, QuizSectionUncheckedUpdateWithoutQuizInput>
  }

  export type QuizSectionUpdateManyWithWhereWithoutQuizInput = {
    where: QuizSectionScalarWhereInput
    data: XOR<QuizSectionUpdateManyMutationInput, QuizSectionUncheckedUpdateManyWithoutQuizInput>
  }

  export type QuizSectionScalarWhereInput = {
    AND?: QuizSectionScalarWhereInput | QuizSectionScalarWhereInput[]
    OR?: QuizSectionScalarWhereInput[]
    NOT?: QuizSectionScalarWhereInput | QuizSectionScalarWhereInput[]
    id?: IntFilter<"QuizSection"> | number
    quizId?: IntFilter<"QuizSection"> | number
    title?: StringFilter<"QuizSection"> | string
    description?: StringNullableFilter<"QuizSection"> | string | null
    orderIndex?: IntFilter<"QuizSection"> | number
  }

  export type QuizQuestionGroupUpsertWithWhereUniqueWithoutQuizInput = {
    where: QuizQuestionGroupWhereUniqueInput
    update: XOR<QuizQuestionGroupUpdateWithoutQuizInput, QuizQuestionGroupUncheckedUpdateWithoutQuizInput>
    create: XOR<QuizQuestionGroupCreateWithoutQuizInput, QuizQuestionGroupUncheckedCreateWithoutQuizInput>
  }

  export type QuizQuestionGroupUpdateWithWhereUniqueWithoutQuizInput = {
    where: QuizQuestionGroupWhereUniqueInput
    data: XOR<QuizQuestionGroupUpdateWithoutQuizInput, QuizQuestionGroupUncheckedUpdateWithoutQuizInput>
  }

  export type QuizQuestionGroupUpdateManyWithWhereWithoutQuizInput = {
    where: QuizQuestionGroupScalarWhereInput
    data: XOR<QuizQuestionGroupUpdateManyMutationInput, QuizQuestionGroupUncheckedUpdateManyWithoutQuizInput>
  }

  export type QuizQuestionGroupScalarWhereInput = {
    AND?: QuizQuestionGroupScalarWhereInput | QuizQuestionGroupScalarWhereInput[]
    OR?: QuizQuestionGroupScalarWhereInput[]
    NOT?: QuizQuestionGroupScalarWhereInput | QuizQuestionGroupScalarWhereInput[]
    id?: IntFilter<"QuizQuestionGroup"> | number
    quizId?: IntFilter<"QuizQuestionGroup"> | number
    sectionId?: IntNullableFilter<"QuizQuestionGroup"> | number | null
    title?: StringNullableFilter<"QuizQuestionGroup"> | string | null
    introText?: StringNullableFilter<"QuizQuestionGroup"> | string | null
    orderIndex?: IntFilter<"QuizQuestionGroup"> | number
    shuffleInside?: BoolFilter<"QuizQuestionGroup"> | boolean
    pointsPolicy?: StringFilter<"QuizQuestionGroup"> | string
    createdAt?: DateTimeFilter<"QuizQuestionGroup"> | Date | string
  }

  export type QuizQuestionUpsertWithWhereUniqueWithoutQuizInput = {
    where: QuizQuestionWhereUniqueInput
    update: XOR<QuizQuestionUpdateWithoutQuizInput, QuizQuestionUncheckedUpdateWithoutQuizInput>
    create: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput>
  }

  export type QuizQuestionUpdateWithWhereUniqueWithoutQuizInput = {
    where: QuizQuestionWhereUniqueInput
    data: XOR<QuizQuestionUpdateWithoutQuizInput, QuizQuestionUncheckedUpdateWithoutQuizInput>
  }

  export type QuizQuestionUpdateManyWithWhereWithoutQuizInput = {
    where: QuizQuestionScalarWhereInput
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyWithoutQuizInput>
  }

  export type QuizQuestionScalarWhereInput = {
    AND?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
    OR?: QuizQuestionScalarWhereInput[]
    NOT?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
    id?: IntFilter<"QuizQuestion"> | number
    quizId?: IntFilter<"QuizQuestion"> | number
    sectionId?: IntNullableFilter<"QuizQuestion"> | number | null
    groupId?: IntNullableFilter<"QuizQuestion"> | number | null
    content?: StringFilter<"QuizQuestion"> | string
    explanation?: StringNullableFilter<"QuizQuestion"> | string | null
    questionType?: StringFilter<"QuizQuestion"> | string
    points?: DecimalFilter<"QuizQuestion"> | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFilter<"QuizQuestion"> | number
  }

  export type QuizAttemptUpsertWithWhereUniqueWithoutQuizInput = {
    where: QuizAttemptWhereUniqueInput
    update: XOR<QuizAttemptUpdateWithoutQuizInput, QuizAttemptUncheckedUpdateWithoutQuizInput>
    create: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput>
  }

  export type QuizAttemptUpdateWithWhereUniqueWithoutQuizInput = {
    where: QuizAttemptWhereUniqueInput
    data: XOR<QuizAttemptUpdateWithoutQuizInput, QuizAttemptUncheckedUpdateWithoutQuizInput>
  }

  export type QuizAttemptUpdateManyWithWhereWithoutQuizInput = {
    where: QuizAttemptScalarWhereInput
    data: XOR<QuizAttemptUpdateManyMutationInput, QuizAttemptUncheckedUpdateManyWithoutQuizInput>
  }

  export type QuizCreateWithoutSectionsInput = {
    title: string
    description?: string | null
    timeLimitSec?: number | null
    maxAttempts?: number
    shuffleQuestions?: boolean
    shuffleOptions?: boolean
    gradingMethod?: string
    showAnswersAfter?: string
    dueAt?: Date | string | null
    isPublished?: boolean
    totalPoints?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lesson: LessonCreateNestedOneWithoutQuizzesInput
    creator: UserCreateNestedOneWithoutCreatedQuizzesInput
    questionGroups?: QuizQuestionGroupCreateNestedManyWithoutQuizInput
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
    attempts?: QuizAttemptCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutSectionsInput = {
    id?: number
    lessonId: number
    title: string
    description?: string | null
    timeLimitSec?: number | null
    maxAttempts?: number
    shuffleQuestions?: boolean
    shuffleOptions?: boolean
    gradingMethod?: string
    showAnswersAfter?: string
    dueAt?: Date | string | null
    isPublished?: boolean
    totalPoints?: Decimal | DecimalJsLike | number | string
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    questionGroups?: QuizQuestionGroupUncheckedCreateNestedManyWithoutQuizInput
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutSectionsInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutSectionsInput, QuizUncheckedCreateWithoutSectionsInput>
  }

  export type QuizQuestionGroupCreateWithoutSectionInput = {
    title?: string | null
    introText?: string | null
    orderIndex?: number
    shuffleInside?: boolean
    pointsPolicy?: string
    createdAt?: Date | string
    quiz: QuizCreateNestedOneWithoutQuestionGroupsInput
    questions?: QuizQuestionCreateNestedManyWithoutGroupInput
    medias?: QuizQuestionGroupMediaCreateNestedManyWithoutGroupInput
  }

  export type QuizQuestionGroupUncheckedCreateWithoutSectionInput = {
    id?: number
    quizId: number
    title?: string | null
    introText?: string | null
    orderIndex?: number
    shuffleInside?: boolean
    pointsPolicy?: string
    createdAt?: Date | string
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutGroupInput
    medias?: QuizQuestionGroupMediaUncheckedCreateNestedManyWithoutGroupInput
  }

  export type QuizQuestionGroupCreateOrConnectWithoutSectionInput = {
    where: QuizQuestionGroupWhereUniqueInput
    create: XOR<QuizQuestionGroupCreateWithoutSectionInput, QuizQuestionGroupUncheckedCreateWithoutSectionInput>
  }

  export type QuizQuestionGroupCreateManySectionInputEnvelope = {
    data: QuizQuestionGroupCreateManySectionInput | QuizQuestionGroupCreateManySectionInput[]
    skipDuplicates?: boolean
  }

  export type QuizQuestionCreateWithoutSectionInput = {
    content: string
    explanation?: string | null
    questionType?: string
    points?: Decimal | DecimalJsLike | number | string
    orderIndex?: number
    quiz: QuizCreateNestedOneWithoutQuestionsInput
    group?: QuizQuestionGroupCreateNestedOneWithoutQuestionsInput
    options?: QuizOptionCreateNestedManyWithoutQuestionInput
    answers?: QuizAnswerCreateNestedManyWithoutQuestionInput
    medias?: QuizQuestionMediaCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionUncheckedCreateWithoutSectionInput = {
    id?: number
    quizId: number
    groupId?: number | null
    content: string
    explanation?: string | null
    questionType?: string
    points?: Decimal | DecimalJsLike | number | string
    orderIndex?: number
    options?: QuizOptionUncheckedCreateNestedManyWithoutQuestionInput
    answers?: QuizAnswerUncheckedCreateNestedManyWithoutQuestionInput
    medias?: QuizQuestionMediaUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionCreateOrConnectWithoutSectionInput = {
    where: QuizQuestionWhereUniqueInput
    create: XOR<QuizQuestionCreateWithoutSectionInput, QuizQuestionUncheckedCreateWithoutSectionInput>
  }

  export type QuizQuestionCreateManySectionInputEnvelope = {
    data: QuizQuestionCreateManySectionInput | QuizQuestionCreateManySectionInput[]
    skipDuplicates?: boolean
  }

  export type QuizUpsertWithoutSectionsInput = {
    update: XOR<QuizUpdateWithoutSectionsInput, QuizUncheckedUpdateWithoutSectionsInput>
    create: XOR<QuizCreateWithoutSectionsInput, QuizUncheckedCreateWithoutSectionsInput>
    where?: QuizWhereInput
  }

  export type QuizUpdateToOneWithWhereWithoutSectionsInput = {
    where?: QuizWhereInput
    data: XOR<QuizUpdateWithoutSectionsInput, QuizUncheckedUpdateWithoutSectionsInput>
  }

  export type QuizUpdateWithoutSectionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    maxAttempts?: IntFieldUpdateOperationsInput | number
    shuffleQuestions?: BoolFieldUpdateOperationsInput | boolean
    shuffleOptions?: BoolFieldUpdateOperationsInput | boolean
    gradingMethod?: StringFieldUpdateOperationsInput | string
    showAnswersAfter?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson?: LessonUpdateOneRequiredWithoutQuizzesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedQuizzesNestedInput
    questionGroups?: QuizQuestionGroupUpdateManyWithoutQuizNestedInput
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
    attempts?: QuizAttemptUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutSectionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    maxAttempts?: IntFieldUpdateOperationsInput | number
    shuffleQuestions?: BoolFieldUpdateOperationsInput | boolean
    shuffleOptions?: BoolFieldUpdateOperationsInput | boolean
    gradingMethod?: StringFieldUpdateOperationsInput | string
    showAnswersAfter?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questionGroups?: QuizQuestionGroupUncheckedUpdateManyWithoutQuizNestedInput
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
    attempts?: QuizAttemptUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizQuestionGroupUpsertWithWhereUniqueWithoutSectionInput = {
    where: QuizQuestionGroupWhereUniqueInput
    update: XOR<QuizQuestionGroupUpdateWithoutSectionInput, QuizQuestionGroupUncheckedUpdateWithoutSectionInput>
    create: XOR<QuizQuestionGroupCreateWithoutSectionInput, QuizQuestionGroupUncheckedCreateWithoutSectionInput>
  }

  export type QuizQuestionGroupUpdateWithWhereUniqueWithoutSectionInput = {
    where: QuizQuestionGroupWhereUniqueInput
    data: XOR<QuizQuestionGroupUpdateWithoutSectionInput, QuizQuestionGroupUncheckedUpdateWithoutSectionInput>
  }

  export type QuizQuestionGroupUpdateManyWithWhereWithoutSectionInput = {
    where: QuizQuestionGroupScalarWhereInput
    data: XOR<QuizQuestionGroupUpdateManyMutationInput, QuizQuestionGroupUncheckedUpdateManyWithoutSectionInput>
  }

  export type QuizQuestionUpsertWithWhereUniqueWithoutSectionInput = {
    where: QuizQuestionWhereUniqueInput
    update: XOR<QuizQuestionUpdateWithoutSectionInput, QuizQuestionUncheckedUpdateWithoutSectionInput>
    create: XOR<QuizQuestionCreateWithoutSectionInput, QuizQuestionUncheckedCreateWithoutSectionInput>
  }

  export type QuizQuestionUpdateWithWhereUniqueWithoutSectionInput = {
    where: QuizQuestionWhereUniqueInput
    data: XOR<QuizQuestionUpdateWithoutSectionInput, QuizQuestionUncheckedUpdateWithoutSectionInput>
  }

  export type QuizQuestionUpdateManyWithWhereWithoutSectionInput = {
    where: QuizQuestionScalarWhereInput
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyWithoutSectionInput>
  }

  export type QuizCreateWithoutQuestionGroupsInput = {
    title: string
    description?: string | null
    timeLimitSec?: number | null
    maxAttempts?: number
    shuffleQuestions?: boolean
    shuffleOptions?: boolean
    gradingMethod?: string
    showAnswersAfter?: string
    dueAt?: Date | string | null
    isPublished?: boolean
    totalPoints?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lesson: LessonCreateNestedOneWithoutQuizzesInput
    creator: UserCreateNestedOneWithoutCreatedQuizzesInput
    sections?: QuizSectionCreateNestedManyWithoutQuizInput
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
    attempts?: QuizAttemptCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutQuestionGroupsInput = {
    id?: number
    lessonId: number
    title: string
    description?: string | null
    timeLimitSec?: number | null
    maxAttempts?: number
    shuffleQuestions?: boolean
    shuffleOptions?: boolean
    gradingMethod?: string
    showAnswersAfter?: string
    dueAt?: Date | string | null
    isPublished?: boolean
    totalPoints?: Decimal | DecimalJsLike | number | string
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sections?: QuizSectionUncheckedCreateNestedManyWithoutQuizInput
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutQuestionGroupsInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutQuestionGroupsInput, QuizUncheckedCreateWithoutQuestionGroupsInput>
  }

  export type QuizSectionCreateWithoutQuestionGroupsInput = {
    title: string
    description?: string | null
    orderIndex?: number
    quiz: QuizCreateNestedOneWithoutSectionsInput
    questions?: QuizQuestionCreateNestedManyWithoutSectionInput
  }

  export type QuizSectionUncheckedCreateWithoutQuestionGroupsInput = {
    id?: number
    quizId: number
    title: string
    description?: string | null
    orderIndex?: number
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutSectionInput
  }

  export type QuizSectionCreateOrConnectWithoutQuestionGroupsInput = {
    where: QuizSectionWhereUniqueInput
    create: XOR<QuizSectionCreateWithoutQuestionGroupsInput, QuizSectionUncheckedCreateWithoutQuestionGroupsInput>
  }

  export type QuizQuestionCreateWithoutGroupInput = {
    content: string
    explanation?: string | null
    questionType?: string
    points?: Decimal | DecimalJsLike | number | string
    orderIndex?: number
    quiz: QuizCreateNestedOneWithoutQuestionsInput
    section?: QuizSectionCreateNestedOneWithoutQuestionsInput
    options?: QuizOptionCreateNestedManyWithoutQuestionInput
    answers?: QuizAnswerCreateNestedManyWithoutQuestionInput
    medias?: QuizQuestionMediaCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionUncheckedCreateWithoutGroupInput = {
    id?: number
    quizId: number
    sectionId?: number | null
    content: string
    explanation?: string | null
    questionType?: string
    points?: Decimal | DecimalJsLike | number | string
    orderIndex?: number
    options?: QuizOptionUncheckedCreateNestedManyWithoutQuestionInput
    answers?: QuizAnswerUncheckedCreateNestedManyWithoutQuestionInput
    medias?: QuizQuestionMediaUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionCreateOrConnectWithoutGroupInput = {
    where: QuizQuestionWhereUniqueInput
    create: XOR<QuizQuestionCreateWithoutGroupInput, QuizQuestionUncheckedCreateWithoutGroupInput>
  }

  export type QuizQuestionCreateManyGroupInputEnvelope = {
    data: QuizQuestionCreateManyGroupInput | QuizQuestionCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type QuizQuestionGroupMediaCreateWithoutGroupInput = {
    createdAt?: Date | string
    media: MediaCreateNestedOneWithoutQuizQuestionGroupMediasInput
  }

  export type QuizQuestionGroupMediaUncheckedCreateWithoutGroupInput = {
    id?: number
    mediaId: number
    createdAt?: Date | string
  }

  export type QuizQuestionGroupMediaCreateOrConnectWithoutGroupInput = {
    where: QuizQuestionGroupMediaWhereUniqueInput
    create: XOR<QuizQuestionGroupMediaCreateWithoutGroupInput, QuizQuestionGroupMediaUncheckedCreateWithoutGroupInput>
  }

  export type QuizQuestionGroupMediaCreateManyGroupInputEnvelope = {
    data: QuizQuestionGroupMediaCreateManyGroupInput | QuizQuestionGroupMediaCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type QuizUpsertWithoutQuestionGroupsInput = {
    update: XOR<QuizUpdateWithoutQuestionGroupsInput, QuizUncheckedUpdateWithoutQuestionGroupsInput>
    create: XOR<QuizCreateWithoutQuestionGroupsInput, QuizUncheckedCreateWithoutQuestionGroupsInput>
    where?: QuizWhereInput
  }

  export type QuizUpdateToOneWithWhereWithoutQuestionGroupsInput = {
    where?: QuizWhereInput
    data: XOR<QuizUpdateWithoutQuestionGroupsInput, QuizUncheckedUpdateWithoutQuestionGroupsInput>
  }

  export type QuizUpdateWithoutQuestionGroupsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    maxAttempts?: IntFieldUpdateOperationsInput | number
    shuffleQuestions?: BoolFieldUpdateOperationsInput | boolean
    shuffleOptions?: BoolFieldUpdateOperationsInput | boolean
    gradingMethod?: StringFieldUpdateOperationsInput | string
    showAnswersAfter?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson?: LessonUpdateOneRequiredWithoutQuizzesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedQuizzesNestedInput
    sections?: QuizSectionUpdateManyWithoutQuizNestedInput
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
    attempts?: QuizAttemptUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutQuestionGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    maxAttempts?: IntFieldUpdateOperationsInput | number
    shuffleQuestions?: BoolFieldUpdateOperationsInput | boolean
    shuffleOptions?: BoolFieldUpdateOperationsInput | boolean
    gradingMethod?: StringFieldUpdateOperationsInput | string
    showAnswersAfter?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sections?: QuizSectionUncheckedUpdateManyWithoutQuizNestedInput
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
    attempts?: QuizAttemptUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizSectionUpsertWithoutQuestionGroupsInput = {
    update: XOR<QuizSectionUpdateWithoutQuestionGroupsInput, QuizSectionUncheckedUpdateWithoutQuestionGroupsInput>
    create: XOR<QuizSectionCreateWithoutQuestionGroupsInput, QuizSectionUncheckedCreateWithoutQuestionGroupsInput>
    where?: QuizSectionWhereInput
  }

  export type QuizSectionUpdateToOneWithWhereWithoutQuestionGroupsInput = {
    where?: QuizSectionWhereInput
    data: XOR<QuizSectionUpdateWithoutQuestionGroupsInput, QuizSectionUncheckedUpdateWithoutQuestionGroupsInput>
  }

  export type QuizSectionUpdateWithoutQuestionGroupsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    quiz?: QuizUpdateOneRequiredWithoutSectionsNestedInput
    questions?: QuizQuestionUpdateManyWithoutSectionNestedInput
  }

  export type QuizSectionUncheckedUpdateWithoutQuestionGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    questions?: QuizQuestionUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type QuizQuestionUpsertWithWhereUniqueWithoutGroupInput = {
    where: QuizQuestionWhereUniqueInput
    update: XOR<QuizQuestionUpdateWithoutGroupInput, QuizQuestionUncheckedUpdateWithoutGroupInput>
    create: XOR<QuizQuestionCreateWithoutGroupInput, QuizQuestionUncheckedCreateWithoutGroupInput>
  }

  export type QuizQuestionUpdateWithWhereUniqueWithoutGroupInput = {
    where: QuizQuestionWhereUniqueInput
    data: XOR<QuizQuestionUpdateWithoutGroupInput, QuizQuestionUncheckedUpdateWithoutGroupInput>
  }

  export type QuizQuestionUpdateManyWithWhereWithoutGroupInput = {
    where: QuizQuestionScalarWhereInput
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyWithoutGroupInput>
  }

  export type QuizQuestionGroupMediaUpsertWithWhereUniqueWithoutGroupInput = {
    where: QuizQuestionGroupMediaWhereUniqueInput
    update: XOR<QuizQuestionGroupMediaUpdateWithoutGroupInput, QuizQuestionGroupMediaUncheckedUpdateWithoutGroupInput>
    create: XOR<QuizQuestionGroupMediaCreateWithoutGroupInput, QuizQuestionGroupMediaUncheckedCreateWithoutGroupInput>
  }

  export type QuizQuestionGroupMediaUpdateWithWhereUniqueWithoutGroupInput = {
    where: QuizQuestionGroupMediaWhereUniqueInput
    data: XOR<QuizQuestionGroupMediaUpdateWithoutGroupInput, QuizQuestionGroupMediaUncheckedUpdateWithoutGroupInput>
  }

  export type QuizQuestionGroupMediaUpdateManyWithWhereWithoutGroupInput = {
    where: QuizQuestionGroupMediaScalarWhereInput
    data: XOR<QuizQuestionGroupMediaUpdateManyMutationInput, QuizQuestionGroupMediaUncheckedUpdateManyWithoutGroupInput>
  }

  export type QuizCreateWithoutQuestionsInput = {
    title: string
    description?: string | null
    timeLimitSec?: number | null
    maxAttempts?: number
    shuffleQuestions?: boolean
    shuffleOptions?: boolean
    gradingMethod?: string
    showAnswersAfter?: string
    dueAt?: Date | string | null
    isPublished?: boolean
    totalPoints?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lesson: LessonCreateNestedOneWithoutQuizzesInput
    creator: UserCreateNestedOneWithoutCreatedQuizzesInput
    sections?: QuizSectionCreateNestedManyWithoutQuizInput
    questionGroups?: QuizQuestionGroupCreateNestedManyWithoutQuizInput
    attempts?: QuizAttemptCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutQuestionsInput = {
    id?: number
    lessonId: number
    title: string
    description?: string | null
    timeLimitSec?: number | null
    maxAttempts?: number
    shuffleQuestions?: boolean
    shuffleOptions?: boolean
    gradingMethod?: string
    showAnswersAfter?: string
    dueAt?: Date | string | null
    isPublished?: boolean
    totalPoints?: Decimal | DecimalJsLike | number | string
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sections?: QuizSectionUncheckedCreateNestedManyWithoutQuizInput
    questionGroups?: QuizQuestionGroupUncheckedCreateNestedManyWithoutQuizInput
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutQuestionsInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
  }

  export type QuizSectionCreateWithoutQuestionsInput = {
    title: string
    description?: string | null
    orderIndex?: number
    quiz: QuizCreateNestedOneWithoutSectionsInput
    questionGroups?: QuizQuestionGroupCreateNestedManyWithoutSectionInput
  }

  export type QuizSectionUncheckedCreateWithoutQuestionsInput = {
    id?: number
    quizId: number
    title: string
    description?: string | null
    orderIndex?: number
    questionGroups?: QuizQuestionGroupUncheckedCreateNestedManyWithoutSectionInput
  }

  export type QuizSectionCreateOrConnectWithoutQuestionsInput = {
    where: QuizSectionWhereUniqueInput
    create: XOR<QuizSectionCreateWithoutQuestionsInput, QuizSectionUncheckedCreateWithoutQuestionsInput>
  }

  export type QuizQuestionGroupCreateWithoutQuestionsInput = {
    title?: string | null
    introText?: string | null
    orderIndex?: number
    shuffleInside?: boolean
    pointsPolicy?: string
    createdAt?: Date | string
    quiz: QuizCreateNestedOneWithoutQuestionGroupsInput
    section?: QuizSectionCreateNestedOneWithoutQuestionGroupsInput
    medias?: QuizQuestionGroupMediaCreateNestedManyWithoutGroupInput
  }

  export type QuizQuestionGroupUncheckedCreateWithoutQuestionsInput = {
    id?: number
    quizId: number
    sectionId?: number | null
    title?: string | null
    introText?: string | null
    orderIndex?: number
    shuffleInside?: boolean
    pointsPolicy?: string
    createdAt?: Date | string
    medias?: QuizQuestionGroupMediaUncheckedCreateNestedManyWithoutGroupInput
  }

  export type QuizQuestionGroupCreateOrConnectWithoutQuestionsInput = {
    where: QuizQuestionGroupWhereUniqueInput
    create: XOR<QuizQuestionGroupCreateWithoutQuestionsInput, QuizQuestionGroupUncheckedCreateWithoutQuestionsInput>
  }

  export type QuizOptionCreateWithoutQuestionInput = {
    content: string
    isCorrect?: boolean
    orderIndex?: number
    answers?: QuizAnswerCreateNestedManyWithoutOptionInput
    medias?: QuizOptionMediaCreateNestedManyWithoutOptionInput
  }

  export type QuizOptionUncheckedCreateWithoutQuestionInput = {
    id?: number
    content: string
    isCorrect?: boolean
    orderIndex?: number
    answers?: QuizAnswerUncheckedCreateNestedManyWithoutOptionInput
    medias?: QuizOptionMediaUncheckedCreateNestedManyWithoutOptionInput
  }

  export type QuizOptionCreateOrConnectWithoutQuestionInput = {
    where: QuizOptionWhereUniqueInput
    create: XOR<QuizOptionCreateWithoutQuestionInput, QuizOptionUncheckedCreateWithoutQuestionInput>
  }

  export type QuizOptionCreateManyQuestionInputEnvelope = {
    data: QuizOptionCreateManyQuestionInput | QuizOptionCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type QuizAnswerCreateWithoutQuestionInput = {
    attempt: QuizAttemptCreateNestedOneWithoutAnswersInput
    option: QuizOptionCreateNestedOneWithoutAnswersInput
  }

  export type QuizAnswerUncheckedCreateWithoutQuestionInput = {
    attemptId: number
    optionId: number
  }

  export type QuizAnswerCreateOrConnectWithoutQuestionInput = {
    where: QuizAnswerWhereUniqueInput
    create: XOR<QuizAnswerCreateWithoutQuestionInput, QuizAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type QuizAnswerCreateManyQuestionInputEnvelope = {
    data: QuizAnswerCreateManyQuestionInput | QuizAnswerCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type QuizQuestionMediaCreateWithoutQuestionInput = {
    createdAt?: Date | string
    media: MediaCreateNestedOneWithoutQuizQuestionMediasInput
  }

  export type QuizQuestionMediaUncheckedCreateWithoutQuestionInput = {
    id?: number
    mediaId: number
    createdAt?: Date | string
  }

  export type QuizQuestionMediaCreateOrConnectWithoutQuestionInput = {
    where: QuizQuestionMediaWhereUniqueInput
    create: XOR<QuizQuestionMediaCreateWithoutQuestionInput, QuizQuestionMediaUncheckedCreateWithoutQuestionInput>
  }

  export type QuizQuestionMediaCreateManyQuestionInputEnvelope = {
    data: QuizQuestionMediaCreateManyQuestionInput | QuizQuestionMediaCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type QuizUpsertWithoutQuestionsInput = {
    update: XOR<QuizUpdateWithoutQuestionsInput, QuizUncheckedUpdateWithoutQuestionsInput>
    create: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
    where?: QuizWhereInput
  }

  export type QuizUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: QuizWhereInput
    data: XOR<QuizUpdateWithoutQuestionsInput, QuizUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuizUpdateWithoutQuestionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    maxAttempts?: IntFieldUpdateOperationsInput | number
    shuffleQuestions?: BoolFieldUpdateOperationsInput | boolean
    shuffleOptions?: BoolFieldUpdateOperationsInput | boolean
    gradingMethod?: StringFieldUpdateOperationsInput | string
    showAnswersAfter?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson?: LessonUpdateOneRequiredWithoutQuizzesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedQuizzesNestedInput
    sections?: QuizSectionUpdateManyWithoutQuizNestedInput
    questionGroups?: QuizQuestionGroupUpdateManyWithoutQuizNestedInput
    attempts?: QuizAttemptUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    maxAttempts?: IntFieldUpdateOperationsInput | number
    shuffleQuestions?: BoolFieldUpdateOperationsInput | boolean
    shuffleOptions?: BoolFieldUpdateOperationsInput | boolean
    gradingMethod?: StringFieldUpdateOperationsInput | string
    showAnswersAfter?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sections?: QuizSectionUncheckedUpdateManyWithoutQuizNestedInput
    questionGroups?: QuizQuestionGroupUncheckedUpdateManyWithoutQuizNestedInput
    attempts?: QuizAttemptUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizSectionUpsertWithoutQuestionsInput = {
    update: XOR<QuizSectionUpdateWithoutQuestionsInput, QuizSectionUncheckedUpdateWithoutQuestionsInput>
    create: XOR<QuizSectionCreateWithoutQuestionsInput, QuizSectionUncheckedCreateWithoutQuestionsInput>
    where?: QuizSectionWhereInput
  }

  export type QuizSectionUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: QuizSectionWhereInput
    data: XOR<QuizSectionUpdateWithoutQuestionsInput, QuizSectionUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuizSectionUpdateWithoutQuestionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    quiz?: QuizUpdateOneRequiredWithoutSectionsNestedInput
    questionGroups?: QuizQuestionGroupUpdateManyWithoutSectionNestedInput
  }

  export type QuizSectionUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    questionGroups?: QuizQuestionGroupUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type QuizQuestionGroupUpsertWithoutQuestionsInput = {
    update: XOR<QuizQuestionGroupUpdateWithoutQuestionsInput, QuizQuestionGroupUncheckedUpdateWithoutQuestionsInput>
    create: XOR<QuizQuestionGroupCreateWithoutQuestionsInput, QuizQuestionGroupUncheckedCreateWithoutQuestionsInput>
    where?: QuizQuestionGroupWhereInput
  }

  export type QuizQuestionGroupUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: QuizQuestionGroupWhereInput
    data: XOR<QuizQuestionGroupUpdateWithoutQuestionsInput, QuizQuestionGroupUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuizQuestionGroupUpdateWithoutQuestionsInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    introText?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    shuffleInside?: BoolFieldUpdateOperationsInput | boolean
    pointsPolicy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quiz?: QuizUpdateOneRequiredWithoutQuestionGroupsNestedInput
    section?: QuizSectionUpdateOneWithoutQuestionGroupsNestedInput
    medias?: QuizQuestionGroupMediaUpdateManyWithoutGroupNestedInput
  }

  export type QuizQuestionGroupUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    sectionId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    introText?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    shuffleInside?: BoolFieldUpdateOperationsInput | boolean
    pointsPolicy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medias?: QuizQuestionGroupMediaUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type QuizOptionUpsertWithWhereUniqueWithoutQuestionInput = {
    where: QuizOptionWhereUniqueInput
    update: XOR<QuizOptionUpdateWithoutQuestionInput, QuizOptionUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuizOptionCreateWithoutQuestionInput, QuizOptionUncheckedCreateWithoutQuestionInput>
  }

  export type QuizOptionUpdateWithWhereUniqueWithoutQuestionInput = {
    where: QuizOptionWhereUniqueInput
    data: XOR<QuizOptionUpdateWithoutQuestionInput, QuizOptionUncheckedUpdateWithoutQuestionInput>
  }

  export type QuizOptionUpdateManyWithWhereWithoutQuestionInput = {
    where: QuizOptionScalarWhereInput
    data: XOR<QuizOptionUpdateManyMutationInput, QuizOptionUncheckedUpdateManyWithoutQuestionInput>
  }

  export type QuizOptionScalarWhereInput = {
    AND?: QuizOptionScalarWhereInput | QuizOptionScalarWhereInput[]
    OR?: QuizOptionScalarWhereInput[]
    NOT?: QuizOptionScalarWhereInput | QuizOptionScalarWhereInput[]
    id?: IntFilter<"QuizOption"> | number
    questionId?: IntFilter<"QuizOption"> | number
    content?: StringFilter<"QuizOption"> | string
    isCorrect?: BoolFilter<"QuizOption"> | boolean
    orderIndex?: IntFilter<"QuizOption"> | number
  }

  export type QuizAnswerUpsertWithWhereUniqueWithoutQuestionInput = {
    where: QuizAnswerWhereUniqueInput
    update: XOR<QuizAnswerUpdateWithoutQuestionInput, QuizAnswerUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuizAnswerCreateWithoutQuestionInput, QuizAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type QuizAnswerUpdateWithWhereUniqueWithoutQuestionInput = {
    where: QuizAnswerWhereUniqueInput
    data: XOR<QuizAnswerUpdateWithoutQuestionInput, QuizAnswerUncheckedUpdateWithoutQuestionInput>
  }

  export type QuizAnswerUpdateManyWithWhereWithoutQuestionInput = {
    where: QuizAnswerScalarWhereInput
    data: XOR<QuizAnswerUpdateManyMutationInput, QuizAnswerUncheckedUpdateManyWithoutQuestionInput>
  }

  export type QuizAnswerScalarWhereInput = {
    AND?: QuizAnswerScalarWhereInput | QuizAnswerScalarWhereInput[]
    OR?: QuizAnswerScalarWhereInput[]
    NOT?: QuizAnswerScalarWhereInput | QuizAnswerScalarWhereInput[]
    attemptId?: IntFilter<"QuizAnswer"> | number
    questionId?: IntFilter<"QuizAnswer"> | number
    optionId?: IntFilter<"QuizAnswer"> | number
  }

  export type QuizQuestionMediaUpsertWithWhereUniqueWithoutQuestionInput = {
    where: QuizQuestionMediaWhereUniqueInput
    update: XOR<QuizQuestionMediaUpdateWithoutQuestionInput, QuizQuestionMediaUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuizQuestionMediaCreateWithoutQuestionInput, QuizQuestionMediaUncheckedCreateWithoutQuestionInput>
  }

  export type QuizQuestionMediaUpdateWithWhereUniqueWithoutQuestionInput = {
    where: QuizQuestionMediaWhereUniqueInput
    data: XOR<QuizQuestionMediaUpdateWithoutQuestionInput, QuizQuestionMediaUncheckedUpdateWithoutQuestionInput>
  }

  export type QuizQuestionMediaUpdateManyWithWhereWithoutQuestionInput = {
    where: QuizQuestionMediaScalarWhereInput
    data: XOR<QuizQuestionMediaUpdateManyMutationInput, QuizQuestionMediaUncheckedUpdateManyWithoutQuestionInput>
  }

  export type QuizQuestionCreateWithoutOptionsInput = {
    content: string
    explanation?: string | null
    questionType?: string
    points?: Decimal | DecimalJsLike | number | string
    orderIndex?: number
    quiz: QuizCreateNestedOneWithoutQuestionsInput
    section?: QuizSectionCreateNestedOneWithoutQuestionsInput
    group?: QuizQuestionGroupCreateNestedOneWithoutQuestionsInput
    answers?: QuizAnswerCreateNestedManyWithoutQuestionInput
    medias?: QuizQuestionMediaCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionUncheckedCreateWithoutOptionsInput = {
    id?: number
    quizId: number
    sectionId?: number | null
    groupId?: number | null
    content: string
    explanation?: string | null
    questionType?: string
    points?: Decimal | DecimalJsLike | number | string
    orderIndex?: number
    answers?: QuizAnswerUncheckedCreateNestedManyWithoutQuestionInput
    medias?: QuizQuestionMediaUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionCreateOrConnectWithoutOptionsInput = {
    where: QuizQuestionWhereUniqueInput
    create: XOR<QuizQuestionCreateWithoutOptionsInput, QuizQuestionUncheckedCreateWithoutOptionsInput>
  }

  export type QuizAnswerCreateWithoutOptionInput = {
    attempt: QuizAttemptCreateNestedOneWithoutAnswersInput
    question: QuizQuestionCreateNestedOneWithoutAnswersInput
  }

  export type QuizAnswerUncheckedCreateWithoutOptionInput = {
    attemptId: number
    questionId: number
  }

  export type QuizAnswerCreateOrConnectWithoutOptionInput = {
    where: QuizAnswerWhereUniqueInput
    create: XOR<QuizAnswerCreateWithoutOptionInput, QuizAnswerUncheckedCreateWithoutOptionInput>
  }

  export type QuizAnswerCreateManyOptionInputEnvelope = {
    data: QuizAnswerCreateManyOptionInput | QuizAnswerCreateManyOptionInput[]
    skipDuplicates?: boolean
  }

  export type QuizOptionMediaCreateWithoutOptionInput = {
    createdAt?: Date | string
    media: MediaCreateNestedOneWithoutQuizOptionMediasInput
  }

  export type QuizOptionMediaUncheckedCreateWithoutOptionInput = {
    id?: number
    mediaId: number
    createdAt?: Date | string
  }

  export type QuizOptionMediaCreateOrConnectWithoutOptionInput = {
    where: QuizOptionMediaWhereUniqueInput
    create: XOR<QuizOptionMediaCreateWithoutOptionInput, QuizOptionMediaUncheckedCreateWithoutOptionInput>
  }

  export type QuizOptionMediaCreateManyOptionInputEnvelope = {
    data: QuizOptionMediaCreateManyOptionInput | QuizOptionMediaCreateManyOptionInput[]
    skipDuplicates?: boolean
  }

  export type QuizQuestionUpsertWithoutOptionsInput = {
    update: XOR<QuizQuestionUpdateWithoutOptionsInput, QuizQuestionUncheckedUpdateWithoutOptionsInput>
    create: XOR<QuizQuestionCreateWithoutOptionsInput, QuizQuestionUncheckedCreateWithoutOptionsInput>
    where?: QuizQuestionWhereInput
  }

  export type QuizQuestionUpdateToOneWithWhereWithoutOptionsInput = {
    where?: QuizQuestionWhereInput
    data: XOR<QuizQuestionUpdateWithoutOptionsInput, QuizQuestionUncheckedUpdateWithoutOptionsInput>
  }

  export type QuizQuestionUpdateWithoutOptionsInput = {
    content?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: StringFieldUpdateOperationsInput | string
    points?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    quiz?: QuizUpdateOneRequiredWithoutQuestionsNestedInput
    section?: QuizSectionUpdateOneWithoutQuestionsNestedInput
    group?: QuizQuestionGroupUpdateOneWithoutQuestionsNestedInput
    answers?: QuizAnswerUpdateManyWithoutQuestionNestedInput
    medias?: QuizQuestionMediaUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateWithoutOptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    sectionId?: NullableIntFieldUpdateOperationsInput | number | null
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: StringFieldUpdateOperationsInput | string
    points?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    answers?: QuizAnswerUncheckedUpdateManyWithoutQuestionNestedInput
    medias?: QuizQuestionMediaUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuizAnswerUpsertWithWhereUniqueWithoutOptionInput = {
    where: QuizAnswerWhereUniqueInput
    update: XOR<QuizAnswerUpdateWithoutOptionInput, QuizAnswerUncheckedUpdateWithoutOptionInput>
    create: XOR<QuizAnswerCreateWithoutOptionInput, QuizAnswerUncheckedCreateWithoutOptionInput>
  }

  export type QuizAnswerUpdateWithWhereUniqueWithoutOptionInput = {
    where: QuizAnswerWhereUniqueInput
    data: XOR<QuizAnswerUpdateWithoutOptionInput, QuizAnswerUncheckedUpdateWithoutOptionInput>
  }

  export type QuizAnswerUpdateManyWithWhereWithoutOptionInput = {
    where: QuizAnswerScalarWhereInput
    data: XOR<QuizAnswerUpdateManyMutationInput, QuizAnswerUncheckedUpdateManyWithoutOptionInput>
  }

  export type QuizOptionMediaUpsertWithWhereUniqueWithoutOptionInput = {
    where: QuizOptionMediaWhereUniqueInput
    update: XOR<QuizOptionMediaUpdateWithoutOptionInput, QuizOptionMediaUncheckedUpdateWithoutOptionInput>
    create: XOR<QuizOptionMediaCreateWithoutOptionInput, QuizOptionMediaUncheckedCreateWithoutOptionInput>
  }

  export type QuizOptionMediaUpdateWithWhereUniqueWithoutOptionInput = {
    where: QuizOptionMediaWhereUniqueInput
    data: XOR<QuizOptionMediaUpdateWithoutOptionInput, QuizOptionMediaUncheckedUpdateWithoutOptionInput>
  }

  export type QuizOptionMediaUpdateManyWithWhereWithoutOptionInput = {
    where: QuizOptionMediaScalarWhereInput
    data: XOR<QuizOptionMediaUpdateManyMutationInput, QuizOptionMediaUncheckedUpdateManyWithoutOptionInput>
  }

  export type QuizCreateWithoutAttemptsInput = {
    title: string
    description?: string | null
    timeLimitSec?: number | null
    maxAttempts?: number
    shuffleQuestions?: boolean
    shuffleOptions?: boolean
    gradingMethod?: string
    showAnswersAfter?: string
    dueAt?: Date | string | null
    isPublished?: boolean
    totalPoints?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lesson: LessonCreateNestedOneWithoutQuizzesInput
    creator: UserCreateNestedOneWithoutCreatedQuizzesInput
    sections?: QuizSectionCreateNestedManyWithoutQuizInput
    questionGroups?: QuizQuestionGroupCreateNestedManyWithoutQuizInput
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutAttemptsInput = {
    id?: number
    lessonId: number
    title: string
    description?: string | null
    timeLimitSec?: number | null
    maxAttempts?: number
    shuffleQuestions?: boolean
    shuffleOptions?: boolean
    gradingMethod?: string
    showAnswersAfter?: string
    dueAt?: Date | string | null
    isPublished?: boolean
    totalPoints?: Decimal | DecimalJsLike | number | string
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sections?: QuizSectionUncheckedCreateNestedManyWithoutQuizInput
    questionGroups?: QuizQuestionGroupUncheckedCreateNestedManyWithoutQuizInput
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutAttemptsInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutAttemptsInput, QuizUncheckedCreateWithoutAttemptsInput>
  }

  export type UserCreateWithoutQuizAttemptsInput = {
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avatarMedia?: MediaCreateNestedOneWithoutUserAvatarsInput
    uploadedMedia?: MediaCreateNestedManyWithoutUploaderInput
    taughtClassrooms?: ClassroomCreateNestedManyWithoutTutorInput
    createdClassrooms?: ClassroomCreateNestedManyWithoutCreatorInput
    classroomStudents?: ClassroomStudentCreateNestedManyWithoutStudentInput
    joinRequests?: JoinRequestCreateNestedManyWithoutStudentInput
    uploadedMaterials?: MaterialCreateNestedManyWithoutUploaderInput
    createdExercises?: ExerciseCreateNestedManyWithoutCreatorInput
    exerciseSubmissions?: ExerciseSubmissionCreateNestedManyWithoutStudentInput
    createdQuizzes?: QuizCreateNestedManyWithoutCreatorInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuizAttemptsInput = {
    id?: number
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    avatarMediaId?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedMedia?: MediaUncheckedCreateNestedManyWithoutUploaderInput
    taughtClassrooms?: ClassroomUncheckedCreateNestedManyWithoutTutorInput
    createdClassrooms?: ClassroomUncheckedCreateNestedManyWithoutCreatorInput
    classroomStudents?: ClassroomStudentUncheckedCreateNestedManyWithoutStudentInput
    joinRequests?: JoinRequestUncheckedCreateNestedManyWithoutStudentInput
    uploadedMaterials?: MaterialUncheckedCreateNestedManyWithoutUploaderInput
    createdExercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutStudentInput
    createdQuizzes?: QuizUncheckedCreateNestedManyWithoutCreatorInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuizAttemptsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuizAttemptsInput, UserUncheckedCreateWithoutQuizAttemptsInput>
  }

  export type QuizAnswerCreateWithoutAttemptInput = {
    question: QuizQuestionCreateNestedOneWithoutAnswersInput
    option: QuizOptionCreateNestedOneWithoutAnswersInput
  }

  export type QuizAnswerUncheckedCreateWithoutAttemptInput = {
    questionId: number
    optionId: number
  }

  export type QuizAnswerCreateOrConnectWithoutAttemptInput = {
    where: QuizAnswerWhereUniqueInput
    create: XOR<QuizAnswerCreateWithoutAttemptInput, QuizAnswerUncheckedCreateWithoutAttemptInput>
  }

  export type QuizAnswerCreateManyAttemptInputEnvelope = {
    data: QuizAnswerCreateManyAttemptInput | QuizAnswerCreateManyAttemptInput[]
    skipDuplicates?: boolean
  }

  export type QuizUpsertWithoutAttemptsInput = {
    update: XOR<QuizUpdateWithoutAttemptsInput, QuizUncheckedUpdateWithoutAttemptsInput>
    create: XOR<QuizCreateWithoutAttemptsInput, QuizUncheckedCreateWithoutAttemptsInput>
    where?: QuizWhereInput
  }

  export type QuizUpdateToOneWithWhereWithoutAttemptsInput = {
    where?: QuizWhereInput
    data: XOR<QuizUpdateWithoutAttemptsInput, QuizUncheckedUpdateWithoutAttemptsInput>
  }

  export type QuizUpdateWithoutAttemptsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    maxAttempts?: IntFieldUpdateOperationsInput | number
    shuffleQuestions?: BoolFieldUpdateOperationsInput | boolean
    shuffleOptions?: BoolFieldUpdateOperationsInput | boolean
    gradingMethod?: StringFieldUpdateOperationsInput | string
    showAnswersAfter?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson?: LessonUpdateOneRequiredWithoutQuizzesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedQuizzesNestedInput
    sections?: QuizSectionUpdateManyWithoutQuizNestedInput
    questionGroups?: QuizQuestionGroupUpdateManyWithoutQuizNestedInput
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutAttemptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    maxAttempts?: IntFieldUpdateOperationsInput | number
    shuffleQuestions?: BoolFieldUpdateOperationsInput | boolean
    shuffleOptions?: BoolFieldUpdateOperationsInput | boolean
    gradingMethod?: StringFieldUpdateOperationsInput | string
    showAnswersAfter?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sections?: QuizSectionUncheckedUpdateManyWithoutQuizNestedInput
    questionGroups?: QuizQuestionGroupUncheckedUpdateManyWithoutQuizNestedInput
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type UserUpsertWithoutQuizAttemptsInput = {
    update: XOR<UserUpdateWithoutQuizAttemptsInput, UserUncheckedUpdateWithoutQuizAttemptsInput>
    create: XOR<UserCreateWithoutQuizAttemptsInput, UserUncheckedCreateWithoutQuizAttemptsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuizAttemptsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuizAttemptsInput, UserUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type UserUpdateWithoutQuizAttemptsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avatarMedia?: MediaUpdateOneWithoutUserAvatarsNestedInput
    uploadedMedia?: MediaUpdateManyWithoutUploaderNestedInput
    taughtClassrooms?: ClassroomUpdateManyWithoutTutorNestedInput
    createdClassrooms?: ClassroomUpdateManyWithoutCreatorNestedInput
    classroomStudents?: ClassroomStudentUpdateManyWithoutStudentNestedInput
    joinRequests?: JoinRequestUpdateManyWithoutStudentNestedInput
    uploadedMaterials?: MaterialUpdateManyWithoutUploaderNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    exerciseSubmissions?: ExerciseSubmissionUpdateManyWithoutStudentNestedInput
    createdQuizzes?: QuizUpdateManyWithoutCreatorNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuizAttemptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    avatarMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedMedia?: MediaUncheckedUpdateManyWithoutUploaderNestedInput
    taughtClassrooms?: ClassroomUncheckedUpdateManyWithoutTutorNestedInput
    createdClassrooms?: ClassroomUncheckedUpdateManyWithoutCreatorNestedInput
    classroomStudents?: ClassroomStudentUncheckedUpdateManyWithoutStudentNestedInput
    joinRequests?: JoinRequestUncheckedUpdateManyWithoutStudentNestedInput
    uploadedMaterials?: MaterialUncheckedUpdateManyWithoutUploaderNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    createdQuizzes?: QuizUncheckedUpdateManyWithoutCreatorNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type QuizAnswerUpsertWithWhereUniqueWithoutAttemptInput = {
    where: QuizAnswerWhereUniqueInput
    update: XOR<QuizAnswerUpdateWithoutAttemptInput, QuizAnswerUncheckedUpdateWithoutAttemptInput>
    create: XOR<QuizAnswerCreateWithoutAttemptInput, QuizAnswerUncheckedCreateWithoutAttemptInput>
  }

  export type QuizAnswerUpdateWithWhereUniqueWithoutAttemptInput = {
    where: QuizAnswerWhereUniqueInput
    data: XOR<QuizAnswerUpdateWithoutAttemptInput, QuizAnswerUncheckedUpdateWithoutAttemptInput>
  }

  export type QuizAnswerUpdateManyWithWhereWithoutAttemptInput = {
    where: QuizAnswerScalarWhereInput
    data: XOR<QuizAnswerUpdateManyMutationInput, QuizAnswerUncheckedUpdateManyWithoutAttemptInput>
  }

  export type QuizAttemptCreateWithoutAnswersInput = {
    startedAt?: Date | string
    submittedAt?: Date | string | null
    status?: string
    scoreRaw?: Decimal | DecimalJsLike | number | string | null
    scoreScaled10?: Decimal | DecimalJsLike | number | string | null
    quiz: QuizCreateNestedOneWithoutAttemptsInput
    student: UserCreateNestedOneWithoutQuizAttemptsInput
  }

  export type QuizAttemptUncheckedCreateWithoutAnswersInput = {
    id?: number
    quizId: number
    studentId: number
    startedAt?: Date | string
    submittedAt?: Date | string | null
    status?: string
    scoreRaw?: Decimal | DecimalJsLike | number | string | null
    scoreScaled10?: Decimal | DecimalJsLike | number | string | null
  }

  export type QuizAttemptCreateOrConnectWithoutAnswersInput = {
    where: QuizAttemptWhereUniqueInput
    create: XOR<QuizAttemptCreateWithoutAnswersInput, QuizAttemptUncheckedCreateWithoutAnswersInput>
  }

  export type QuizQuestionCreateWithoutAnswersInput = {
    content: string
    explanation?: string | null
    questionType?: string
    points?: Decimal | DecimalJsLike | number | string
    orderIndex?: number
    quiz: QuizCreateNestedOneWithoutQuestionsInput
    section?: QuizSectionCreateNestedOneWithoutQuestionsInput
    group?: QuizQuestionGroupCreateNestedOneWithoutQuestionsInput
    options?: QuizOptionCreateNestedManyWithoutQuestionInput
    medias?: QuizQuestionMediaCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionUncheckedCreateWithoutAnswersInput = {
    id?: number
    quizId: number
    sectionId?: number | null
    groupId?: number | null
    content: string
    explanation?: string | null
    questionType?: string
    points?: Decimal | DecimalJsLike | number | string
    orderIndex?: number
    options?: QuizOptionUncheckedCreateNestedManyWithoutQuestionInput
    medias?: QuizQuestionMediaUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionCreateOrConnectWithoutAnswersInput = {
    where: QuizQuestionWhereUniqueInput
    create: XOR<QuizQuestionCreateWithoutAnswersInput, QuizQuestionUncheckedCreateWithoutAnswersInput>
  }

  export type QuizOptionCreateWithoutAnswersInput = {
    content: string
    isCorrect?: boolean
    orderIndex?: number
    question: QuizQuestionCreateNestedOneWithoutOptionsInput
    medias?: QuizOptionMediaCreateNestedManyWithoutOptionInput
  }

  export type QuizOptionUncheckedCreateWithoutAnswersInput = {
    id?: number
    questionId: number
    content: string
    isCorrect?: boolean
    orderIndex?: number
    medias?: QuizOptionMediaUncheckedCreateNestedManyWithoutOptionInput
  }

  export type QuizOptionCreateOrConnectWithoutAnswersInput = {
    where: QuizOptionWhereUniqueInput
    create: XOR<QuizOptionCreateWithoutAnswersInput, QuizOptionUncheckedCreateWithoutAnswersInput>
  }

  export type QuizAttemptUpsertWithoutAnswersInput = {
    update: XOR<QuizAttemptUpdateWithoutAnswersInput, QuizAttemptUncheckedUpdateWithoutAnswersInput>
    create: XOR<QuizAttemptCreateWithoutAnswersInput, QuizAttemptUncheckedCreateWithoutAnswersInput>
    where?: QuizAttemptWhereInput
  }

  export type QuizAttemptUpdateToOneWithWhereWithoutAnswersInput = {
    where?: QuizAttemptWhereInput
    data: XOR<QuizAttemptUpdateWithoutAnswersInput, QuizAttemptUncheckedUpdateWithoutAnswersInput>
  }

  export type QuizAttemptUpdateWithoutAnswersInput = {
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    scoreRaw?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    scoreScaled10?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quiz?: QuizUpdateOneRequiredWithoutAttemptsNestedInput
    student?: UserUpdateOneRequiredWithoutQuizAttemptsNestedInput
  }

  export type QuizAttemptUncheckedUpdateWithoutAnswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    scoreRaw?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    scoreScaled10?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type QuizQuestionUpsertWithoutAnswersInput = {
    update: XOR<QuizQuestionUpdateWithoutAnswersInput, QuizQuestionUncheckedUpdateWithoutAnswersInput>
    create: XOR<QuizQuestionCreateWithoutAnswersInput, QuizQuestionUncheckedCreateWithoutAnswersInput>
    where?: QuizQuestionWhereInput
  }

  export type QuizQuestionUpdateToOneWithWhereWithoutAnswersInput = {
    where?: QuizQuestionWhereInput
    data: XOR<QuizQuestionUpdateWithoutAnswersInput, QuizQuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type QuizQuestionUpdateWithoutAnswersInput = {
    content?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: StringFieldUpdateOperationsInput | string
    points?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    quiz?: QuizUpdateOneRequiredWithoutQuestionsNestedInput
    section?: QuizSectionUpdateOneWithoutQuestionsNestedInput
    group?: QuizQuestionGroupUpdateOneWithoutQuestionsNestedInput
    options?: QuizOptionUpdateManyWithoutQuestionNestedInput
    medias?: QuizQuestionMediaUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateWithoutAnswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    sectionId?: NullableIntFieldUpdateOperationsInput | number | null
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: StringFieldUpdateOperationsInput | string
    points?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    options?: QuizOptionUncheckedUpdateManyWithoutQuestionNestedInput
    medias?: QuizQuestionMediaUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuizOptionUpsertWithoutAnswersInput = {
    update: XOR<QuizOptionUpdateWithoutAnswersInput, QuizOptionUncheckedUpdateWithoutAnswersInput>
    create: XOR<QuizOptionCreateWithoutAnswersInput, QuizOptionUncheckedCreateWithoutAnswersInput>
    where?: QuizOptionWhereInput
  }

  export type QuizOptionUpdateToOneWithWhereWithoutAnswersInput = {
    where?: QuizOptionWhereInput
    data: XOR<QuizOptionUpdateWithoutAnswersInput, QuizOptionUncheckedUpdateWithoutAnswersInput>
  }

  export type QuizOptionUpdateWithoutAnswersInput = {
    content?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
    question?: QuizQuestionUpdateOneRequiredWithoutOptionsNestedInput
    medias?: QuizOptionMediaUpdateManyWithoutOptionNestedInput
  }

  export type QuizOptionUncheckedUpdateWithoutAnswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
    medias?: QuizOptionMediaUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type QuizQuestionGroupCreateWithoutMediasInput = {
    title?: string | null
    introText?: string | null
    orderIndex?: number
    shuffleInside?: boolean
    pointsPolicy?: string
    createdAt?: Date | string
    quiz: QuizCreateNestedOneWithoutQuestionGroupsInput
    section?: QuizSectionCreateNestedOneWithoutQuestionGroupsInput
    questions?: QuizQuestionCreateNestedManyWithoutGroupInput
  }

  export type QuizQuestionGroupUncheckedCreateWithoutMediasInput = {
    id?: number
    quizId: number
    sectionId?: number | null
    title?: string | null
    introText?: string | null
    orderIndex?: number
    shuffleInside?: boolean
    pointsPolicy?: string
    createdAt?: Date | string
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutGroupInput
  }

  export type QuizQuestionGroupCreateOrConnectWithoutMediasInput = {
    where: QuizQuestionGroupWhereUniqueInput
    create: XOR<QuizQuestionGroupCreateWithoutMediasInput, QuizQuestionGroupUncheckedCreateWithoutMediasInput>
  }

  export type MediaCreateWithoutQuizQuestionGroupMediasInput = {
    disk: string
    bucket?: string | null
    objectKey: string
    mimeType?: string | null
    sizeBytes?: bigint | number | null
    visibility?: string
    createdAt?: Date | string
    uploader?: UserCreateNestedOneWithoutUploadedMediaInput
    userAvatars?: UserCreateNestedManyWithoutAvatarMediaInput
    classroomCovers?: ClassroomCreateNestedManyWithoutCoverMediaInput
    materials?: MaterialCreateNestedManyWithoutMediaInput
    exerciseAttachments?: ExerciseCreateNestedManyWithoutAttachMediaInput
    exerciseSubmissions?: ExerciseSubmissionCreateNestedManyWithoutMediaInput
    quizQuestionMedias?: QuizQuestionMediaCreateNestedManyWithoutMediaInput
    quizOptionMedias?: QuizOptionMediaCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutQuizQuestionGroupMediasInput = {
    id?: number
    disk: string
    bucket?: string | null
    objectKey: string
    mimeType?: string | null
    sizeBytes?: bigint | number | null
    visibility?: string
    uploadedBy?: number | null
    createdAt?: Date | string
    userAvatars?: UserUncheckedCreateNestedManyWithoutAvatarMediaInput
    classroomCovers?: ClassroomUncheckedCreateNestedManyWithoutCoverMediaInput
    materials?: MaterialUncheckedCreateNestedManyWithoutMediaInput
    exerciseAttachments?: ExerciseUncheckedCreateNestedManyWithoutAttachMediaInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutMediaInput
    quizQuestionMedias?: QuizQuestionMediaUncheckedCreateNestedManyWithoutMediaInput
    quizOptionMedias?: QuizOptionMediaUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutQuizQuestionGroupMediasInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutQuizQuestionGroupMediasInput, MediaUncheckedCreateWithoutQuizQuestionGroupMediasInput>
  }

  export type QuizQuestionGroupUpsertWithoutMediasInput = {
    update: XOR<QuizQuestionGroupUpdateWithoutMediasInput, QuizQuestionGroupUncheckedUpdateWithoutMediasInput>
    create: XOR<QuizQuestionGroupCreateWithoutMediasInput, QuizQuestionGroupUncheckedCreateWithoutMediasInput>
    where?: QuizQuestionGroupWhereInput
  }

  export type QuizQuestionGroupUpdateToOneWithWhereWithoutMediasInput = {
    where?: QuizQuestionGroupWhereInput
    data: XOR<QuizQuestionGroupUpdateWithoutMediasInput, QuizQuestionGroupUncheckedUpdateWithoutMediasInput>
  }

  export type QuizQuestionGroupUpdateWithoutMediasInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    introText?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    shuffleInside?: BoolFieldUpdateOperationsInput | boolean
    pointsPolicy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quiz?: QuizUpdateOneRequiredWithoutQuestionGroupsNestedInput
    section?: QuizSectionUpdateOneWithoutQuestionGroupsNestedInput
    questions?: QuizQuestionUpdateManyWithoutGroupNestedInput
  }

  export type QuizQuestionGroupUncheckedUpdateWithoutMediasInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    sectionId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    introText?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    shuffleInside?: BoolFieldUpdateOperationsInput | boolean
    pointsPolicy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuizQuestionUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type MediaUpsertWithoutQuizQuestionGroupMediasInput = {
    update: XOR<MediaUpdateWithoutQuizQuestionGroupMediasInput, MediaUncheckedUpdateWithoutQuizQuestionGroupMediasInput>
    create: XOR<MediaCreateWithoutQuizQuestionGroupMediasInput, MediaUncheckedCreateWithoutQuizQuestionGroupMediasInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutQuizQuestionGroupMediasInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutQuizQuestionGroupMediasInput, MediaUncheckedUpdateWithoutQuizQuestionGroupMediasInput>
  }

  export type MediaUpdateWithoutQuizQuestionGroupMediasInput = {
    disk?: StringFieldUpdateOperationsInput | string
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    objectKey?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneWithoutUploadedMediaNestedInput
    userAvatars?: UserUpdateManyWithoutAvatarMediaNestedInput
    classroomCovers?: ClassroomUpdateManyWithoutCoverMediaNestedInput
    materials?: MaterialUpdateManyWithoutMediaNestedInput
    exerciseAttachments?: ExerciseUpdateManyWithoutAttachMediaNestedInput
    exerciseSubmissions?: ExerciseSubmissionUpdateManyWithoutMediaNestedInput
    quizQuestionMedias?: QuizQuestionMediaUpdateManyWithoutMediaNestedInput
    quizOptionMedias?: QuizOptionMediaUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutQuizQuestionGroupMediasInput = {
    id?: IntFieldUpdateOperationsInput | number
    disk?: StringFieldUpdateOperationsInput | string
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    objectKey?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    visibility?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAvatars?: UserUncheckedUpdateManyWithoutAvatarMediaNestedInput
    classroomCovers?: ClassroomUncheckedUpdateManyWithoutCoverMediaNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutMediaNestedInput
    exerciseAttachments?: ExerciseUncheckedUpdateManyWithoutAttachMediaNestedInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedUpdateManyWithoutMediaNestedInput
    quizQuestionMedias?: QuizQuestionMediaUncheckedUpdateManyWithoutMediaNestedInput
    quizOptionMedias?: QuizOptionMediaUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type QuizQuestionCreateWithoutMediasInput = {
    content: string
    explanation?: string | null
    questionType?: string
    points?: Decimal | DecimalJsLike | number | string
    orderIndex?: number
    quiz: QuizCreateNestedOneWithoutQuestionsInput
    section?: QuizSectionCreateNestedOneWithoutQuestionsInput
    group?: QuizQuestionGroupCreateNestedOneWithoutQuestionsInput
    options?: QuizOptionCreateNestedManyWithoutQuestionInput
    answers?: QuizAnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionUncheckedCreateWithoutMediasInput = {
    id?: number
    quizId: number
    sectionId?: number | null
    groupId?: number | null
    content: string
    explanation?: string | null
    questionType?: string
    points?: Decimal | DecimalJsLike | number | string
    orderIndex?: number
    options?: QuizOptionUncheckedCreateNestedManyWithoutQuestionInput
    answers?: QuizAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuizQuestionCreateOrConnectWithoutMediasInput = {
    where: QuizQuestionWhereUniqueInput
    create: XOR<QuizQuestionCreateWithoutMediasInput, QuizQuestionUncheckedCreateWithoutMediasInput>
  }

  export type MediaCreateWithoutQuizQuestionMediasInput = {
    disk: string
    bucket?: string | null
    objectKey: string
    mimeType?: string | null
    sizeBytes?: bigint | number | null
    visibility?: string
    createdAt?: Date | string
    uploader?: UserCreateNestedOneWithoutUploadedMediaInput
    userAvatars?: UserCreateNestedManyWithoutAvatarMediaInput
    classroomCovers?: ClassroomCreateNestedManyWithoutCoverMediaInput
    materials?: MaterialCreateNestedManyWithoutMediaInput
    exerciseAttachments?: ExerciseCreateNestedManyWithoutAttachMediaInput
    exerciseSubmissions?: ExerciseSubmissionCreateNestedManyWithoutMediaInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaCreateNestedManyWithoutMediaInput
    quizOptionMedias?: QuizOptionMediaCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutQuizQuestionMediasInput = {
    id?: number
    disk: string
    bucket?: string | null
    objectKey: string
    mimeType?: string | null
    sizeBytes?: bigint | number | null
    visibility?: string
    uploadedBy?: number | null
    createdAt?: Date | string
    userAvatars?: UserUncheckedCreateNestedManyWithoutAvatarMediaInput
    classroomCovers?: ClassroomUncheckedCreateNestedManyWithoutCoverMediaInput
    materials?: MaterialUncheckedCreateNestedManyWithoutMediaInput
    exerciseAttachments?: ExerciseUncheckedCreateNestedManyWithoutAttachMediaInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutMediaInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaUncheckedCreateNestedManyWithoutMediaInput
    quizOptionMedias?: QuizOptionMediaUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutQuizQuestionMediasInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutQuizQuestionMediasInput, MediaUncheckedCreateWithoutQuizQuestionMediasInput>
  }

  export type QuizQuestionUpsertWithoutMediasInput = {
    update: XOR<QuizQuestionUpdateWithoutMediasInput, QuizQuestionUncheckedUpdateWithoutMediasInput>
    create: XOR<QuizQuestionCreateWithoutMediasInput, QuizQuestionUncheckedCreateWithoutMediasInput>
    where?: QuizQuestionWhereInput
  }

  export type QuizQuestionUpdateToOneWithWhereWithoutMediasInput = {
    where?: QuizQuestionWhereInput
    data: XOR<QuizQuestionUpdateWithoutMediasInput, QuizQuestionUncheckedUpdateWithoutMediasInput>
  }

  export type QuizQuestionUpdateWithoutMediasInput = {
    content?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: StringFieldUpdateOperationsInput | string
    points?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    quiz?: QuizUpdateOneRequiredWithoutQuestionsNestedInput
    section?: QuizSectionUpdateOneWithoutQuestionsNestedInput
    group?: QuizQuestionGroupUpdateOneWithoutQuestionsNestedInput
    options?: QuizOptionUpdateManyWithoutQuestionNestedInput
    answers?: QuizAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateWithoutMediasInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    sectionId?: NullableIntFieldUpdateOperationsInput | number | null
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: StringFieldUpdateOperationsInput | string
    points?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    options?: QuizOptionUncheckedUpdateManyWithoutQuestionNestedInput
    answers?: QuizAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type MediaUpsertWithoutQuizQuestionMediasInput = {
    update: XOR<MediaUpdateWithoutQuizQuestionMediasInput, MediaUncheckedUpdateWithoutQuizQuestionMediasInput>
    create: XOR<MediaCreateWithoutQuizQuestionMediasInput, MediaUncheckedCreateWithoutQuizQuestionMediasInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutQuizQuestionMediasInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutQuizQuestionMediasInput, MediaUncheckedUpdateWithoutQuizQuestionMediasInput>
  }

  export type MediaUpdateWithoutQuizQuestionMediasInput = {
    disk?: StringFieldUpdateOperationsInput | string
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    objectKey?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneWithoutUploadedMediaNestedInput
    userAvatars?: UserUpdateManyWithoutAvatarMediaNestedInput
    classroomCovers?: ClassroomUpdateManyWithoutCoverMediaNestedInput
    materials?: MaterialUpdateManyWithoutMediaNestedInput
    exerciseAttachments?: ExerciseUpdateManyWithoutAttachMediaNestedInput
    exerciseSubmissions?: ExerciseSubmissionUpdateManyWithoutMediaNestedInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaUpdateManyWithoutMediaNestedInput
    quizOptionMedias?: QuizOptionMediaUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutQuizQuestionMediasInput = {
    id?: IntFieldUpdateOperationsInput | number
    disk?: StringFieldUpdateOperationsInput | string
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    objectKey?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    visibility?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAvatars?: UserUncheckedUpdateManyWithoutAvatarMediaNestedInput
    classroomCovers?: ClassroomUncheckedUpdateManyWithoutCoverMediaNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutMediaNestedInput
    exerciseAttachments?: ExerciseUncheckedUpdateManyWithoutAttachMediaNestedInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedUpdateManyWithoutMediaNestedInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaUncheckedUpdateManyWithoutMediaNestedInput
    quizOptionMedias?: QuizOptionMediaUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type QuizOptionCreateWithoutMediasInput = {
    content: string
    isCorrect?: boolean
    orderIndex?: number
    question: QuizQuestionCreateNestedOneWithoutOptionsInput
    answers?: QuizAnswerCreateNestedManyWithoutOptionInput
  }

  export type QuizOptionUncheckedCreateWithoutMediasInput = {
    id?: number
    questionId: number
    content: string
    isCorrect?: boolean
    orderIndex?: number
    answers?: QuizAnswerUncheckedCreateNestedManyWithoutOptionInput
  }

  export type QuizOptionCreateOrConnectWithoutMediasInput = {
    where: QuizOptionWhereUniqueInput
    create: XOR<QuizOptionCreateWithoutMediasInput, QuizOptionUncheckedCreateWithoutMediasInput>
  }

  export type MediaCreateWithoutQuizOptionMediasInput = {
    disk: string
    bucket?: string | null
    objectKey: string
    mimeType?: string | null
    sizeBytes?: bigint | number | null
    visibility?: string
    createdAt?: Date | string
    uploader?: UserCreateNestedOneWithoutUploadedMediaInput
    userAvatars?: UserCreateNestedManyWithoutAvatarMediaInput
    classroomCovers?: ClassroomCreateNestedManyWithoutCoverMediaInput
    materials?: MaterialCreateNestedManyWithoutMediaInput
    exerciseAttachments?: ExerciseCreateNestedManyWithoutAttachMediaInput
    exerciseSubmissions?: ExerciseSubmissionCreateNestedManyWithoutMediaInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaCreateNestedManyWithoutMediaInput
    quizQuestionMedias?: QuizQuestionMediaCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutQuizOptionMediasInput = {
    id?: number
    disk: string
    bucket?: string | null
    objectKey: string
    mimeType?: string | null
    sizeBytes?: bigint | number | null
    visibility?: string
    uploadedBy?: number | null
    createdAt?: Date | string
    userAvatars?: UserUncheckedCreateNestedManyWithoutAvatarMediaInput
    classroomCovers?: ClassroomUncheckedCreateNestedManyWithoutCoverMediaInput
    materials?: MaterialUncheckedCreateNestedManyWithoutMediaInput
    exerciseAttachments?: ExerciseUncheckedCreateNestedManyWithoutAttachMediaInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedCreateNestedManyWithoutMediaInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaUncheckedCreateNestedManyWithoutMediaInput
    quizQuestionMedias?: QuizQuestionMediaUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutQuizOptionMediasInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutQuizOptionMediasInput, MediaUncheckedCreateWithoutQuizOptionMediasInput>
  }

  export type QuizOptionUpsertWithoutMediasInput = {
    update: XOR<QuizOptionUpdateWithoutMediasInput, QuizOptionUncheckedUpdateWithoutMediasInput>
    create: XOR<QuizOptionCreateWithoutMediasInput, QuizOptionUncheckedCreateWithoutMediasInput>
    where?: QuizOptionWhereInput
  }

  export type QuizOptionUpdateToOneWithWhereWithoutMediasInput = {
    where?: QuizOptionWhereInput
    data: XOR<QuizOptionUpdateWithoutMediasInput, QuizOptionUncheckedUpdateWithoutMediasInput>
  }

  export type QuizOptionUpdateWithoutMediasInput = {
    content?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
    question?: QuizQuestionUpdateOneRequiredWithoutOptionsNestedInput
    answers?: QuizAnswerUpdateManyWithoutOptionNestedInput
  }

  export type QuizOptionUncheckedUpdateWithoutMediasInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
    answers?: QuizAnswerUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type MediaUpsertWithoutQuizOptionMediasInput = {
    update: XOR<MediaUpdateWithoutQuizOptionMediasInput, MediaUncheckedUpdateWithoutQuizOptionMediasInput>
    create: XOR<MediaCreateWithoutQuizOptionMediasInput, MediaUncheckedCreateWithoutQuizOptionMediasInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutQuizOptionMediasInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutQuizOptionMediasInput, MediaUncheckedUpdateWithoutQuizOptionMediasInput>
  }

  export type MediaUpdateWithoutQuizOptionMediasInput = {
    disk?: StringFieldUpdateOperationsInput | string
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    objectKey?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneWithoutUploadedMediaNestedInput
    userAvatars?: UserUpdateManyWithoutAvatarMediaNestedInput
    classroomCovers?: ClassroomUpdateManyWithoutCoverMediaNestedInput
    materials?: MaterialUpdateManyWithoutMediaNestedInput
    exerciseAttachments?: ExerciseUpdateManyWithoutAttachMediaNestedInput
    exerciseSubmissions?: ExerciseSubmissionUpdateManyWithoutMediaNestedInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaUpdateManyWithoutMediaNestedInput
    quizQuestionMedias?: QuizQuestionMediaUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutQuizOptionMediasInput = {
    id?: IntFieldUpdateOperationsInput | number
    disk?: StringFieldUpdateOperationsInput | string
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    objectKey?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    visibility?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAvatars?: UserUncheckedUpdateManyWithoutAvatarMediaNestedInput
    classroomCovers?: ClassroomUncheckedUpdateManyWithoutCoverMediaNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutMediaNestedInput
    exerciseAttachments?: ExerciseUncheckedUpdateManyWithoutAttachMediaNestedInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedUpdateManyWithoutMediaNestedInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaUncheckedUpdateManyWithoutMediaNestedInput
    quizQuestionMedias?: QuizQuestionMediaUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type UserCreateManyAvatarMediaInput = {
    id?: number
    fullName: string
    email: string
    passwordHash: string
    phone: string
    role?: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassroomCreateManyCoverMediaInput = {
    id?: number
    name: string
    description?: string | null
    tutorId: number
    isArchived?: boolean
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaterialCreateManyMediaInput = {
    id?: number
    lessonId: number
    title: string
    uploadedBy: number
    uploadedAt?: Date | string
  }

  export type ExerciseCreateManyAttachMediaInput = {
    id?: number
    lessonId: number
    title: string
    description?: string | null
    dueAt?: Date | string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ExerciseSubmissionCreateManyMediaInput = {
    id?: number
    exerciseId: number
    studentId: number
    submittedAt?: Date | string
    score?: Decimal | DecimalJsLike | number | string | null
    comment?: string | null
    gradedAt?: Date | string | null
  }

  export type QuizQuestionGroupMediaCreateManyMediaInput = {
    id?: number
    groupId: number
    createdAt?: Date | string
  }

  export type QuizQuestionMediaCreateManyMediaInput = {
    id?: number
    questionId: number
    createdAt?: Date | string
  }

  export type QuizOptionMediaCreateManyMediaInput = {
    id?: number
    optionId: number
    createdAt?: Date | string
  }

  export type UserUpdateWithoutAvatarMediaInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedMedia?: MediaUpdateManyWithoutUploaderNestedInput
    taughtClassrooms?: ClassroomUpdateManyWithoutTutorNestedInput
    createdClassrooms?: ClassroomUpdateManyWithoutCreatorNestedInput
    classroomStudents?: ClassroomStudentUpdateManyWithoutStudentNestedInput
    joinRequests?: JoinRequestUpdateManyWithoutStudentNestedInput
    uploadedMaterials?: MaterialUpdateManyWithoutUploaderNestedInput
    createdExercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    exerciseSubmissions?: ExerciseSubmissionUpdateManyWithoutStudentNestedInput
    createdQuizzes?: QuizUpdateManyWithoutCreatorNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutStudentNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAvatarMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedMedia?: MediaUncheckedUpdateManyWithoutUploaderNestedInput
    taughtClassrooms?: ClassroomUncheckedUpdateManyWithoutTutorNestedInput
    createdClassrooms?: ClassroomUncheckedUpdateManyWithoutCreatorNestedInput
    classroomStudents?: ClassroomStudentUncheckedUpdateManyWithoutStudentNestedInput
    joinRequests?: JoinRequestUncheckedUpdateManyWithoutStudentNestedInput
    uploadedMaterials?: MaterialUncheckedUpdateManyWithoutUploaderNestedInput
    createdExercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    createdQuizzes?: QuizUncheckedUpdateManyWithoutCreatorNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutStudentNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutAvatarMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomUpdateWithoutCoverMediaInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tutor?: UserUpdateOneRequiredWithoutTaughtClassroomsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedClassroomsNestedInput
    classroomStudents?: ClassroomStudentUpdateManyWithoutClassroomNestedInput
    joinRequests?: JoinRequestUpdateManyWithoutClassroomNestedInput
    lessons?: LessonUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateWithoutCoverMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tutorId?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classroomStudents?: ClassroomStudentUncheckedUpdateManyWithoutClassroomNestedInput
    joinRequests?: JoinRequestUncheckedUpdateManyWithoutClassroomNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateManyWithoutCoverMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tutorId?: IntFieldUpdateOperationsInput | number
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUpdateWithoutMediaInput = {
    title?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneWithoutMaterialsNestedInput
    uploader?: UserUpdateOneRequiredWithoutUploadedMaterialsNestedInput
  }

  export type MaterialUncheckedUpdateWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    uploadedBy?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUncheckedUpdateManyWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    uploadedBy?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseUpdateWithoutAttachMediaInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson?: LessonUpdateOneWithoutExercisesNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedExercisesNestedInput
    submissions?: ExerciseSubmissionUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutAttachMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissions?: ExerciseSubmissionUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateManyWithoutAttachMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExerciseSubmissionUpdateWithoutMediaInput = {
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exercise?: ExerciseUpdateOneRequiredWithoutSubmissionsNestedInput
    student?: UserUpdateOneRequiredWithoutExerciseSubmissionsNestedInput
  }

  export type ExerciseSubmissionUncheckedUpdateWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    exerciseId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExerciseSubmissionUncheckedUpdateManyWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    exerciseId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizQuestionGroupMediaUpdateWithoutMediaInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: QuizQuestionGroupUpdateOneRequiredWithoutMediasNestedInput
  }

  export type QuizQuestionGroupMediaUncheckedUpdateWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionGroupMediaUncheckedUpdateManyWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionMediaUpdateWithoutMediaInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuizQuestionUpdateOneRequiredWithoutMediasNestedInput
  }

  export type QuizQuestionMediaUncheckedUpdateWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionMediaUncheckedUpdateManyWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizOptionMediaUpdateWithoutMediaInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    option?: QuizOptionUpdateOneRequiredWithoutMediasNestedInput
  }

  export type QuizOptionMediaUncheckedUpdateWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    optionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizOptionMediaUncheckedUpdateManyWithoutMediaInput = {
    id?: IntFieldUpdateOperationsInput | number
    optionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaCreateManyUploaderInput = {
    id?: number
    disk: string
    bucket?: string | null
    objectKey: string
    mimeType?: string | null
    sizeBytes?: bigint | number | null
    visibility?: string
    createdAt?: Date | string
  }

  export type ClassroomCreateManyTutorInput = {
    id?: number
    name: string
    description?: string | null
    coverMediaId?: number | null
    isArchived?: boolean
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassroomCreateManyCreatorInput = {
    id?: number
    name: string
    description?: string | null
    tutorId: number
    coverMediaId?: number | null
    isArchived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassroomStudentCreateManyStudentInput = {
    classroomId: number
    joinedAt?: Date | string
    status?: number
  }

  export type JoinRequestCreateManyStudentInput = {
    id?: number
    classroomId: number
    status?: string
    requestedAt?: Date | string
    handledAt?: Date | string | null
  }

  export type MaterialCreateManyUploaderInput = {
    id?: number
    lessonId: number
    title: string
    mediaId: number
    uploadedAt?: Date | string
  }

  export type ExerciseCreateManyCreatorInput = {
    id?: number
    lessonId: number
    title: string
    description?: string | null
    attachMediaId?: number | null
    dueAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ExerciseSubmissionCreateManyStudentInput = {
    id?: number
    exerciseId: number
    mediaId: number
    submittedAt?: Date | string
    score?: Decimal | DecimalJsLike | number | string | null
    comment?: string | null
    gradedAt?: Date | string | null
  }

  export type QuizCreateManyCreatorInput = {
    id?: number
    lessonId: number
    title: string
    description?: string | null
    timeLimitSec?: number | null
    maxAttempts?: number
    shuffleQuestions?: boolean
    shuffleOptions?: boolean
    gradingMethod?: string
    showAnswersAfter?: string
    dueAt?: Date | string | null
    isPublished?: boolean
    totalPoints?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type QuizAttemptCreateManyStudentInput = {
    id?: number
    quizId: number
    startedAt?: Date | string
    submittedAt?: Date | string | null
    status?: string
    scoreRaw?: Decimal | DecimalJsLike | number | string | null
    scoreScaled10?: Decimal | DecimalJsLike | number | string | null
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: bigint | number
    tokenHash: string
    issuedAt?: Date | string
    expiresAt: Date | string
    revokedAt?: Date | string | null
    replacedByHash?: string | null
  }

  export type MediaUpdateWithoutUploaderInput = {
    disk?: StringFieldUpdateOperationsInput | string
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    objectKey?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAvatars?: UserUpdateManyWithoutAvatarMediaNestedInput
    classroomCovers?: ClassroomUpdateManyWithoutCoverMediaNestedInput
    materials?: MaterialUpdateManyWithoutMediaNestedInput
    exerciseAttachments?: ExerciseUpdateManyWithoutAttachMediaNestedInput
    exerciseSubmissions?: ExerciseSubmissionUpdateManyWithoutMediaNestedInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaUpdateManyWithoutMediaNestedInput
    quizQuestionMedias?: QuizQuestionMediaUpdateManyWithoutMediaNestedInput
    quizOptionMedias?: QuizOptionMediaUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    disk?: StringFieldUpdateOperationsInput | string
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    objectKey?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAvatars?: UserUncheckedUpdateManyWithoutAvatarMediaNestedInput
    classroomCovers?: ClassroomUncheckedUpdateManyWithoutCoverMediaNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutMediaNestedInput
    exerciseAttachments?: ExerciseUncheckedUpdateManyWithoutAttachMediaNestedInput
    exerciseSubmissions?: ExerciseSubmissionUncheckedUpdateManyWithoutMediaNestedInput
    quizQuestionGroupMedias?: QuizQuestionGroupMediaUncheckedUpdateManyWithoutMediaNestedInput
    quizQuestionMedias?: QuizQuestionMediaUncheckedUpdateManyWithoutMediaNestedInput
    quizOptionMedias?: QuizOptionMediaUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateManyWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    disk?: StringFieldUpdateOperationsInput | string
    bucket?: NullableStringFieldUpdateOperationsInput | string | null
    objectKey?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    visibility?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomUpdateWithoutTutorInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedClassroomsNestedInput
    coverMedia?: MediaUpdateOneWithoutClassroomCoversNestedInput
    classroomStudents?: ClassroomStudentUpdateManyWithoutClassroomNestedInput
    joinRequests?: JoinRequestUpdateManyWithoutClassroomNestedInput
    lessons?: LessonUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateWithoutTutorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classroomStudents?: ClassroomStudentUncheckedUpdateManyWithoutClassroomNestedInput
    joinRequests?: JoinRequestUncheckedUpdateManyWithoutClassroomNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateManyWithoutTutorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    coverMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomUpdateWithoutCreatorInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tutor?: UserUpdateOneRequiredWithoutTaughtClassroomsNestedInput
    coverMedia?: MediaUpdateOneWithoutClassroomCoversNestedInput
    classroomStudents?: ClassroomStudentUpdateManyWithoutClassroomNestedInput
    joinRequests?: JoinRequestUpdateManyWithoutClassroomNestedInput
    lessons?: LessonUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tutorId?: IntFieldUpdateOperationsInput | number
    coverMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classroomStudents?: ClassroomStudentUncheckedUpdateManyWithoutClassroomNestedInput
    joinRequests?: JoinRequestUncheckedUpdateManyWithoutClassroomNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tutorId?: IntFieldUpdateOperationsInput | number
    coverMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomStudentUpdateWithoutStudentInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    classroom?: ClassroomUpdateOneRequiredWithoutClassroomStudentsNestedInput
  }

  export type ClassroomStudentUncheckedUpdateWithoutStudentInput = {
    classroomId?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type ClassroomStudentUncheckedUpdateManyWithoutStudentInput = {
    classroomId?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type JoinRequestUpdateWithoutStudentInput = {
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classroom?: ClassroomUpdateOneRequiredWithoutJoinRequestsNestedInput
  }

  export type JoinRequestUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JoinRequestUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MaterialUpdateWithoutUploaderInput = {
    title?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneWithoutMaterialsNestedInput
    media?: MediaUpdateOneRequiredWithoutMaterialsNestedInput
  }

  export type MaterialUncheckedUpdateWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    mediaId?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUncheckedUpdateManyWithoutUploaderInput = {
    id?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    mediaId?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseUpdateWithoutCreatorInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson?: LessonUpdateOneWithoutExercisesNestedInput
    attachMedia?: MediaUpdateOneWithoutExerciseAttachmentsNestedInput
    submissions?: ExerciseSubmissionUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissions?: ExerciseSubmissionUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExerciseSubmissionUpdateWithoutStudentInput = {
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    exercise?: ExerciseUpdateOneRequiredWithoutSubmissionsNestedInput
    media?: MediaUpdateOneRequiredWithoutExerciseSubmissionsNestedInput
  }

  export type ExerciseSubmissionUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    exerciseId?: IntFieldUpdateOperationsInput | number
    mediaId?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExerciseSubmissionUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    exerciseId?: IntFieldUpdateOperationsInput | number
    mediaId?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizUpdateWithoutCreatorInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    maxAttempts?: IntFieldUpdateOperationsInput | number
    shuffleQuestions?: BoolFieldUpdateOperationsInput | boolean
    shuffleOptions?: BoolFieldUpdateOperationsInput | boolean
    gradingMethod?: StringFieldUpdateOperationsInput | string
    showAnswersAfter?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson?: LessonUpdateOneRequiredWithoutQuizzesNestedInput
    sections?: QuizSectionUpdateManyWithoutQuizNestedInput
    questionGroups?: QuizQuestionGroupUpdateManyWithoutQuizNestedInput
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
    attempts?: QuizAttemptUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    maxAttempts?: IntFieldUpdateOperationsInput | number
    shuffleQuestions?: BoolFieldUpdateOperationsInput | boolean
    shuffleOptions?: BoolFieldUpdateOperationsInput | boolean
    gradingMethod?: StringFieldUpdateOperationsInput | string
    showAnswersAfter?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sections?: QuizSectionUncheckedUpdateManyWithoutQuizNestedInput
    questionGroups?: QuizQuestionGroupUncheckedUpdateManyWithoutQuizNestedInput
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
    attempts?: QuizAttemptUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    lessonId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    maxAttempts?: IntFieldUpdateOperationsInput | number
    shuffleQuestions?: BoolFieldUpdateOperationsInput | boolean
    shuffleOptions?: BoolFieldUpdateOperationsInput | boolean
    gradingMethod?: StringFieldUpdateOperationsInput | string
    showAnswersAfter?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizAttemptUpdateWithoutStudentInput = {
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    scoreRaw?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    scoreScaled10?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    quiz?: QuizUpdateOneRequiredWithoutAttemptsNestedInput
    answers?: QuizAnswerUpdateManyWithoutAttemptNestedInput
  }

  export type QuizAttemptUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    scoreRaw?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    scoreScaled10?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    answers?: QuizAnswerUncheckedUpdateManyWithoutAttemptNestedInput
  }

  export type QuizAttemptUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    scoreRaw?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    scoreScaled10?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tokenHash?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replacedByHash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tokenHash?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replacedByHash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    tokenHash?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replacedByHash?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassroomStudentCreateManyClassroomInput = {
    studentId: number
    joinedAt?: Date | string
    status?: number
  }

  export type JoinRequestCreateManyClassroomInput = {
    id?: number
    studentId: number
    status?: string
    requestedAt?: Date | string
    handledAt?: Date | string | null
  }

  export type LessonCreateManyClassroomInput = {
    id?: number
    parentId?: number | null
    title: string
    content?: string | null
    lessonType?: $Enums.LessonType
    orderIndex?: number
    publishedAt?: Date | string | null
  }

  export type ClassroomStudentUpdateWithoutClassroomInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
    student?: UserUpdateOneRequiredWithoutClassroomStudentsNestedInput
  }

  export type ClassroomStudentUncheckedUpdateWithoutClassroomInput = {
    studentId?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type ClassroomStudentUncheckedUpdateManyWithoutClassroomInput = {
    studentId?: IntFieldUpdateOperationsInput | number
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: IntFieldUpdateOperationsInput | number
  }

  export type JoinRequestUpdateWithoutClassroomInput = {
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student?: UserUpdateOneRequiredWithoutJoinRequestsNestedInput
  }

  export type JoinRequestUncheckedUpdateWithoutClassroomInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JoinRequestUncheckedUpdateManyWithoutClassroomInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LessonUpdateWithoutClassroomInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    lessonType?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    orderIndex?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    materials?: MaterialUpdateManyWithoutLessonNestedInput
    exercises?: ExerciseUpdateManyWithoutLessonNestedInput
    quizzes?: QuizUpdateManyWithoutLessonNestedInput
    parent?: LessonUpdateOneWithoutSubLessonsNestedInput
    subLessons?: LessonUpdateManyWithoutParentNestedInput
  }

  export type LessonUncheckedUpdateWithoutClassroomInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    lessonType?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    orderIndex?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    materials?: MaterialUncheckedUpdateManyWithoutLessonNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutLessonNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutLessonNestedInput
    subLessons?: LessonUncheckedUpdateManyWithoutParentNestedInput
  }

  export type LessonUncheckedUpdateManyWithoutClassroomInput = {
    id?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    lessonType?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    orderIndex?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MaterialCreateManyLessonInput = {
    id?: number
    title: string
    mediaId: number
    uploadedBy: number
    uploadedAt?: Date | string
  }

  export type ExerciseCreateManyLessonInput = {
    id?: number
    title: string
    description?: string | null
    attachMediaId?: number | null
    dueAt?: Date | string | null
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type QuizCreateManyLessonInput = {
    id?: number
    title: string
    description?: string | null
    timeLimitSec?: number | null
    maxAttempts?: number
    shuffleQuestions?: boolean
    shuffleOptions?: boolean
    gradingMethod?: string
    showAnswersAfter?: string
    dueAt?: Date | string | null
    isPublished?: boolean
    totalPoints?: Decimal | DecimalJsLike | number | string
    createdBy: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LessonCreateManyParentInput = {
    id?: number
    classroomId: number
    title: string
    content?: string | null
    lessonType?: $Enums.LessonType
    orderIndex?: number
    publishedAt?: Date | string | null
  }

  export type MaterialUpdateWithoutLessonInput = {
    title?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: MediaUpdateOneRequiredWithoutMaterialsNestedInput
    uploader?: UserUpdateOneRequiredWithoutUploadedMaterialsNestedInput
  }

  export type MaterialUncheckedUpdateWithoutLessonInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    mediaId?: IntFieldUpdateOperationsInput | number
    uploadedBy?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUncheckedUpdateManyWithoutLessonInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    mediaId?: IntFieldUpdateOperationsInput | number
    uploadedBy?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseUpdateWithoutLessonInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachMedia?: MediaUpdateOneWithoutExerciseAttachmentsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedExercisesNestedInput
    submissions?: ExerciseSubmissionUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutLessonInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissions?: ExerciseSubmissionUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateManyWithoutLessonInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attachMediaId?: NullableIntFieldUpdateOperationsInput | number | null
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizUpdateWithoutLessonInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    maxAttempts?: IntFieldUpdateOperationsInput | number
    shuffleQuestions?: BoolFieldUpdateOperationsInput | boolean
    shuffleOptions?: BoolFieldUpdateOperationsInput | boolean
    gradingMethod?: StringFieldUpdateOperationsInput | string
    showAnswersAfter?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneRequiredWithoutCreatedQuizzesNestedInput
    sections?: QuizSectionUpdateManyWithoutQuizNestedInput
    questionGroups?: QuizQuestionGroupUpdateManyWithoutQuizNestedInput
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
    attempts?: QuizAttemptUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutLessonInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    maxAttempts?: IntFieldUpdateOperationsInput | number
    shuffleQuestions?: BoolFieldUpdateOperationsInput | boolean
    shuffleOptions?: BoolFieldUpdateOperationsInput | boolean
    gradingMethod?: StringFieldUpdateOperationsInput | string
    showAnswersAfter?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sections?: QuizSectionUncheckedUpdateManyWithoutQuizNestedInput
    questionGroups?: QuizQuestionGroupUncheckedUpdateManyWithoutQuizNestedInput
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
    attempts?: QuizAttemptUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateManyWithoutLessonInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    maxAttempts?: IntFieldUpdateOperationsInput | number
    shuffleQuestions?: BoolFieldUpdateOperationsInput | boolean
    shuffleOptions?: BoolFieldUpdateOperationsInput | boolean
    gradingMethod?: StringFieldUpdateOperationsInput | string
    showAnswersAfter?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    totalPoints?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LessonUpdateWithoutParentInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    lessonType?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    orderIndex?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classroom?: ClassroomUpdateOneRequiredWithoutLessonsNestedInput
    materials?: MaterialUpdateManyWithoutLessonNestedInput
    exercises?: ExerciseUpdateManyWithoutLessonNestedInput
    quizzes?: QuizUpdateManyWithoutLessonNestedInput
    subLessons?: LessonUpdateManyWithoutParentNestedInput
  }

  export type LessonUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    lessonType?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    orderIndex?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    materials?: MaterialUncheckedUpdateManyWithoutLessonNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutLessonNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutLessonNestedInput
    subLessons?: LessonUncheckedUpdateManyWithoutParentNestedInput
  }

  export type LessonUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    classroomId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    lessonType?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    orderIndex?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExerciseSubmissionCreateManyExerciseInput = {
    id?: number
    studentId: number
    mediaId: number
    submittedAt?: Date | string
    score?: Decimal | DecimalJsLike | number | string | null
    comment?: string | null
    gradedAt?: Date | string | null
  }

  export type ExerciseSubmissionUpdateWithoutExerciseInput = {
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student?: UserUpdateOneRequiredWithoutExerciseSubmissionsNestedInput
    media?: MediaUpdateOneRequiredWithoutExerciseSubmissionsNestedInput
  }

  export type ExerciseSubmissionUncheckedUpdateWithoutExerciseInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    mediaId?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExerciseSubmissionUncheckedUpdateManyWithoutExerciseInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    mediaId?: IntFieldUpdateOperationsInput | number
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    gradedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizSectionCreateManyQuizInput = {
    id?: number
    title: string
    description?: string | null
    orderIndex?: number
  }

  export type QuizQuestionGroupCreateManyQuizInput = {
    id?: number
    sectionId?: number | null
    title?: string | null
    introText?: string | null
    orderIndex?: number
    shuffleInside?: boolean
    pointsPolicy?: string
    createdAt?: Date | string
  }

  export type QuizQuestionCreateManyQuizInput = {
    id?: number
    sectionId?: number | null
    groupId?: number | null
    content: string
    explanation?: string | null
    questionType?: string
    points?: Decimal | DecimalJsLike | number | string
    orderIndex?: number
  }

  export type QuizAttemptCreateManyQuizInput = {
    id?: number
    studentId: number
    startedAt?: Date | string
    submittedAt?: Date | string | null
    status?: string
    scoreRaw?: Decimal | DecimalJsLike | number | string | null
    scoreScaled10?: Decimal | DecimalJsLike | number | string | null
  }

  export type QuizSectionUpdateWithoutQuizInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    questionGroups?: QuizQuestionGroupUpdateManyWithoutSectionNestedInput
    questions?: QuizQuestionUpdateManyWithoutSectionNestedInput
  }

  export type QuizSectionUncheckedUpdateWithoutQuizInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    questionGroups?: QuizQuestionGroupUncheckedUpdateManyWithoutSectionNestedInput
    questions?: QuizQuestionUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type QuizSectionUncheckedUpdateManyWithoutQuizInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type QuizQuestionGroupUpdateWithoutQuizInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    introText?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    shuffleInside?: BoolFieldUpdateOperationsInput | boolean
    pointsPolicy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: QuizSectionUpdateOneWithoutQuestionGroupsNestedInput
    questions?: QuizQuestionUpdateManyWithoutGroupNestedInput
    medias?: QuizQuestionGroupMediaUpdateManyWithoutGroupNestedInput
  }

  export type QuizQuestionGroupUncheckedUpdateWithoutQuizInput = {
    id?: IntFieldUpdateOperationsInput | number
    sectionId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    introText?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    shuffleInside?: BoolFieldUpdateOperationsInput | boolean
    pointsPolicy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuizQuestionUncheckedUpdateManyWithoutGroupNestedInput
    medias?: QuizQuestionGroupMediaUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type QuizQuestionGroupUncheckedUpdateManyWithoutQuizInput = {
    id?: IntFieldUpdateOperationsInput | number
    sectionId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    introText?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    shuffleInside?: BoolFieldUpdateOperationsInput | boolean
    pointsPolicy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionUpdateWithoutQuizInput = {
    content?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: StringFieldUpdateOperationsInput | string
    points?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    section?: QuizSectionUpdateOneWithoutQuestionsNestedInput
    group?: QuizQuestionGroupUpdateOneWithoutQuestionsNestedInput
    options?: QuizOptionUpdateManyWithoutQuestionNestedInput
    answers?: QuizAnswerUpdateManyWithoutQuestionNestedInput
    medias?: QuizQuestionMediaUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateWithoutQuizInput = {
    id?: IntFieldUpdateOperationsInput | number
    sectionId?: NullableIntFieldUpdateOperationsInput | number | null
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: StringFieldUpdateOperationsInput | string
    points?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    options?: QuizOptionUncheckedUpdateManyWithoutQuestionNestedInput
    answers?: QuizAnswerUncheckedUpdateManyWithoutQuestionNestedInput
    medias?: QuizQuestionMediaUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateManyWithoutQuizInput = {
    id?: IntFieldUpdateOperationsInput | number
    sectionId?: NullableIntFieldUpdateOperationsInput | number | null
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: StringFieldUpdateOperationsInput | string
    points?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type QuizAttemptUpdateWithoutQuizInput = {
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    scoreRaw?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    scoreScaled10?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    student?: UserUpdateOneRequiredWithoutQuizAttemptsNestedInput
    answers?: QuizAnswerUpdateManyWithoutAttemptNestedInput
  }

  export type QuizAttemptUncheckedUpdateWithoutQuizInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    scoreRaw?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    scoreScaled10?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    answers?: QuizAnswerUncheckedUpdateManyWithoutAttemptNestedInput
  }

  export type QuizAttemptUncheckedUpdateManyWithoutQuizInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    scoreRaw?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    scoreScaled10?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type QuizQuestionGroupCreateManySectionInput = {
    id?: number
    quizId: number
    title?: string | null
    introText?: string | null
    orderIndex?: number
    shuffleInside?: boolean
    pointsPolicy?: string
    createdAt?: Date | string
  }

  export type QuizQuestionCreateManySectionInput = {
    id?: number
    quizId: number
    groupId?: number | null
    content: string
    explanation?: string | null
    questionType?: string
    points?: Decimal | DecimalJsLike | number | string
    orderIndex?: number
  }

  export type QuizQuestionGroupUpdateWithoutSectionInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    introText?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    shuffleInside?: BoolFieldUpdateOperationsInput | boolean
    pointsPolicy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quiz?: QuizUpdateOneRequiredWithoutQuestionGroupsNestedInput
    questions?: QuizQuestionUpdateManyWithoutGroupNestedInput
    medias?: QuizQuestionGroupMediaUpdateManyWithoutGroupNestedInput
  }

  export type QuizQuestionGroupUncheckedUpdateWithoutSectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    introText?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    shuffleInside?: BoolFieldUpdateOperationsInput | boolean
    pointsPolicy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuizQuestionUncheckedUpdateManyWithoutGroupNestedInput
    medias?: QuizQuestionGroupMediaUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type QuizQuestionGroupUncheckedUpdateManyWithoutSectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    introText?: NullableStringFieldUpdateOperationsInput | string | null
    orderIndex?: IntFieldUpdateOperationsInput | number
    shuffleInside?: BoolFieldUpdateOperationsInput | boolean
    pointsPolicy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionUpdateWithoutSectionInput = {
    content?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: StringFieldUpdateOperationsInput | string
    points?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    quiz?: QuizUpdateOneRequiredWithoutQuestionsNestedInput
    group?: QuizQuestionGroupUpdateOneWithoutQuestionsNestedInput
    options?: QuizOptionUpdateManyWithoutQuestionNestedInput
    answers?: QuizAnswerUpdateManyWithoutQuestionNestedInput
    medias?: QuizQuestionMediaUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateWithoutSectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: StringFieldUpdateOperationsInput | string
    points?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    options?: QuizOptionUncheckedUpdateManyWithoutQuestionNestedInput
    answers?: QuizAnswerUncheckedUpdateManyWithoutQuestionNestedInput
    medias?: QuizQuestionMediaUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateManyWithoutSectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    groupId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: StringFieldUpdateOperationsInput | string
    points?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type QuizQuestionCreateManyGroupInput = {
    id?: number
    quizId: number
    sectionId?: number | null
    content: string
    explanation?: string | null
    questionType?: string
    points?: Decimal | DecimalJsLike | number | string
    orderIndex?: number
  }

  export type QuizQuestionGroupMediaCreateManyGroupInput = {
    id?: number
    mediaId: number
    createdAt?: Date | string
  }

  export type QuizQuestionUpdateWithoutGroupInput = {
    content?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: StringFieldUpdateOperationsInput | string
    points?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    quiz?: QuizUpdateOneRequiredWithoutQuestionsNestedInput
    section?: QuizSectionUpdateOneWithoutQuestionsNestedInput
    options?: QuizOptionUpdateManyWithoutQuestionNestedInput
    answers?: QuizAnswerUpdateManyWithoutQuestionNestedInput
    medias?: QuizQuestionMediaUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    sectionId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: StringFieldUpdateOperationsInput | string
    points?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    options?: QuizOptionUncheckedUpdateManyWithoutQuestionNestedInput
    answers?: QuizAnswerUncheckedUpdateManyWithoutQuestionNestedInput
    medias?: QuizQuestionMediaUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuizQuestionUncheckedUpdateManyWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizId?: IntFieldUpdateOperationsInput | number
    sectionId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    questionType?: StringFieldUpdateOperationsInput | string
    points?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type QuizQuestionGroupMediaUpdateWithoutGroupInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: MediaUpdateOneRequiredWithoutQuizQuestionGroupMediasNestedInput
  }

  export type QuizQuestionGroupMediaUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    mediaId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionGroupMediaUncheckedUpdateManyWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    mediaId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizOptionCreateManyQuestionInput = {
    id?: number
    content: string
    isCorrect?: boolean
    orderIndex?: number
  }

  export type QuizAnswerCreateManyQuestionInput = {
    attemptId: number
    optionId: number
  }

  export type QuizQuestionMediaCreateManyQuestionInput = {
    id?: number
    mediaId: number
    createdAt?: Date | string
  }

  export type QuizOptionUpdateWithoutQuestionInput = {
    content?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
    answers?: QuizAnswerUpdateManyWithoutOptionNestedInput
    medias?: QuizOptionMediaUpdateManyWithoutOptionNestedInput
  }

  export type QuizOptionUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
    answers?: QuizAnswerUncheckedUpdateManyWithoutOptionNestedInput
    medias?: QuizOptionMediaUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type QuizOptionUncheckedUpdateManyWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type QuizAnswerUpdateWithoutQuestionInput = {
    attempt?: QuizAttemptUpdateOneRequiredWithoutAnswersNestedInput
    option?: QuizOptionUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type QuizAnswerUncheckedUpdateWithoutQuestionInput = {
    attemptId?: IntFieldUpdateOperationsInput | number
    optionId?: IntFieldUpdateOperationsInput | number
  }

  export type QuizAnswerUncheckedUpdateManyWithoutQuestionInput = {
    attemptId?: IntFieldUpdateOperationsInput | number
    optionId?: IntFieldUpdateOperationsInput | number
  }

  export type QuizQuestionMediaUpdateWithoutQuestionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: MediaUpdateOneRequiredWithoutQuizQuestionMediasNestedInput
  }

  export type QuizQuestionMediaUncheckedUpdateWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    mediaId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionMediaUncheckedUpdateManyWithoutQuestionInput = {
    id?: IntFieldUpdateOperationsInput | number
    mediaId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizAnswerCreateManyOptionInput = {
    attemptId: number
    questionId: number
  }

  export type QuizOptionMediaCreateManyOptionInput = {
    id?: number
    mediaId: number
    createdAt?: Date | string
  }

  export type QuizAnswerUpdateWithoutOptionInput = {
    attempt?: QuizAttemptUpdateOneRequiredWithoutAnswersNestedInput
    question?: QuizQuestionUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type QuizAnswerUncheckedUpdateWithoutOptionInput = {
    attemptId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
  }

  export type QuizAnswerUncheckedUpdateManyWithoutOptionInput = {
    attemptId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
  }

  export type QuizOptionMediaUpdateWithoutOptionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: MediaUpdateOneRequiredWithoutQuizOptionMediasNestedInput
  }

  export type QuizOptionMediaUncheckedUpdateWithoutOptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    mediaId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizOptionMediaUncheckedUpdateManyWithoutOptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    mediaId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizAnswerCreateManyAttemptInput = {
    questionId: number
    optionId: number
  }

  export type QuizAnswerUpdateWithoutAttemptInput = {
    question?: QuizQuestionUpdateOneRequiredWithoutAnswersNestedInput
    option?: QuizOptionUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type QuizAnswerUncheckedUpdateWithoutAttemptInput = {
    questionId?: IntFieldUpdateOperationsInput | number
    optionId?: IntFieldUpdateOperationsInput | number
  }

  export type QuizAnswerUncheckedUpdateManyWithoutAttemptInput = {
    questionId?: IntFieldUpdateOperationsInput | number
    optionId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}